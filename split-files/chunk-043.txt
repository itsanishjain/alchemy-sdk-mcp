

    expect(response.contracts[0]).not.toEqual(firstPage.contracts[0]);
  });

  it.each(Object.values(NftFilters))(
    `getContractsForOwner() with includeFilters=[%s]`,
    async includeFilter => {
      const expectedIsSpam = includeFilter === NftFilters.SPAM;

      const response = await alchemy.nft.getContractsForOwner(ownerAddress, {
        includeFilters: [includeFilter]
      });

      response.contracts.forEach(nftSale => {
        expect(nftSale.isSpam).toBe(expectedIsSpam);
      });
    }
  );

  it(`getContractsForOwner() with excludeFilter=[${NftFilters.SPAM}]`, async () => {
    const response = await alchemy.nft.getContractsForOwner(ownerAddress, {
      excludeFilters: [NftFilters.SPAM]
    });

    response.contracts.forEach(nftSale => {
      expect(nftSale.isSpam).toBe(false);
    });
  });

  it('getNftsForContract() with pageKey', async () => {
    const nftsForNftContract = await alchemy.nft.getNftsForContract(
      contractAddress
    );

    expect(nftsForNftContract).not.toBeUndefined();
    const nextPage = await alchemy.nft.getNftsForContract(contractAddress, {
      pageKey: nftsForNftContract.pageKey
    });
    expect(nftsForNftContract.nfts[0]).not.toEqual(nextPage.nfts[0]);
  });

  it('getNftsForContract() with limit', async () => {
    const nftsForNftContract = await alchemy.nft.getNftsForContract(
      contractAddress,
      { pageSize: 10 }
    );
    expect(nftsForNftContract.nfts.length).toEqual(10);
  });

  it('getNftsForContract() contract metadata check', async () => {
    const response = await alchemy.nft.getNftsForContract(
      '0x246e29ef6987637e48e7509f91521ce64eb8c831',
      { omitMetadata: false }
    );
    expect(
      response.nfts.filter(
        nft =>
          nft.contract.symbol !== undefined &&
          nft.contract.totalSupply !== undefined
      ).length
    ).toBeGreaterThan(0);
  });

  it('getContractMetadataBatch()', async () => {
    const contractAddresses = [
      '0xe785E82358879F061BC3dcAC6f0444462D4b5330',
      '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D'
    ];
    const response = await alchemy.nft.getContractMetadataBatch(
      contractAddresses
    );
    expect(response.contracts.length).toEqual(2);
    expect(contractAddresses.includes(response.contracts[0].address)).toEqual(
      true
    );
    expect(contractAddresses.includes(response.contracts[1].address)).toEqual(
      true
    );
  });

  it('getNftsForOwnerIterator()', async () => {
    jest.setTimeout(15000);
    let allNfts = [];
    let totalCount = 0;
    for await (const nft of alchemy.nft.getNftsForOwnerIterator(ownerAddress)) {
      if (totalCount === 10) {
        break;
      }
      allNfts.push(nft);
      totalCount += 1;
    }
    expect(allNfts.length).toEqual(totalCount);
    allNfts = [];
    totalCount = 0;

    for await (const nft of alchemy.nft.getNftsForOwnerIterator(ownerAddress, {
      omitMetadata: false
    })) {
      if (totalCount === 10) {
        break;
      }
      allNfts.push(nft);
      totalCount += 1;
    }
    expect(allNfts.length).toEqual(totalCount);
  });

  it('getNftsForContractIterator()', async () => {
    jest.setTimeout(15000);
    const allNfts = [];
    let totalCount = 0;
    for await (const nft of alchemy.nft.getNftsForContractIterator(
      contractAddress,
      {
        omitMetadata: false
      }
    )) {
      if (totalCount === 150) {
        break;
      }
      allNfts.push(nft);
      totalCount += 1;
    }
    expect(allNfts.length).toEqual(totalCount);
  });

  it('getMintedNfts()', async () => {
    // Handles paging
    const response = await alchemy.nft.getMintedNfts('vitalik.eth');
    expect(response.pageKey).toBeDefined();
    expect(response.nfts.length).toBeGreaterThan(0);
    const responseWithPageKey = await alchemy.nft.getMintedNfts('vitalik.eth', {
      pageKey: response.pageKey
    });
    expect(responseWithPageKey.nfts.length).toBeGreaterThan(0);
    expect(response).not.toEqual(responseWithPageKey);

    // Handles ERC1155 NFT mints.
    const response3 = await alchemy.nft.getMintedNfts('vitalik.eth', {
      tokenType: NftTokenType.ERC1155
    });
    const nfts1155 = response3.nfts.filter(
      nft => nft.tokenType === NftTokenType.ERC1155
    );
    expect(nfts1155.length).toEqual(response3.nfts.length);

    // // Handles ERC721 NFT mints.
    const response4 = await alchemy.nft.getMintedNfts('vitalik.eth', {
      tokenType: NftTokenType.ERC721
    });
    const nfts721 = response4.nfts.filter(
      // Some 721 transfers are ingested as NftTokenType.UNKNOWN.
      nft => nft.tokenType !== NftTokenType.ERC1155
    );
    expect(nfts721.length).toEqual(response4.nfts.length);

    // Handles contract address specifying.
    const contractAddresses = [
      '0xa1eB40c284C5B44419425c4202Fa8DabFF31006b',
      '0x8442864d6AB62a9193be2F16580c08E0D7BCda2f'
    ];
    const response5 = await alchemy.nft.getMintedNfts('vitalik.eth', {
      contractAddresses
    });
    const nftsWithAddress = response5.nfts.filter(nft =>
      contractAddresses.includes(nft.contract.address)
    );
    expect(nftsWithAddress.length).toEqual(response5.nfts.length);
  });

  it('getTransfersForOwner()', async () => {
    // Handles paging
    const response = await alchemy.nft.getTransfersForOwner(
      'vitalik.eth',
      GetTransfersForOwnerTransferType.TO
    );
    expect(response.pageKey).toBeDefined();
    expect(response.nfts.length).toBeGreaterThan(0);
    const responseWithPageKey = await alchemy.nft.getTransfersForOwner(
      'vitalik.eth',
      GetTransfersForOwnerTransferType.TO,
      {
        pageKey: response.pageKey
      }
    );
    expect(responseWithPageKey.nfts.length).toBeGreaterThan(0);
    expect(response.nfts[0]).not.toEqual(responseWithPageKey.nfts[0]);

    // Handles ERC1155 NFT transfers.
    const response3 = await alchemy.nft.getTransfersForOwner(
      'vitalik.eth',
      GetTransfersForOwnerTransferType.TO,
      {
        tokenType: NftTokenType.ERC1155
      }
    );
    const nfts1155 = response3.nfts.filter(
      nft => nft.tokenType === NftTokenType.ERC1155
    );
    expect(nfts1155.length).toEqual(response3.nfts.length);

    // Handles ERC721 NFT transfers.
    const response4 = await alchemy.nft.getTransfersForOwner(
      'vitalik.eth',
      GetTransfersForOwnerTransferType.FROM,
      {
        tokenType: NftTokenType.ERC721
      }
    );
    const nfts721 = response4.nfts.filter(
      // Some 721 transfers are ingested as NftTokenType.UNKNOWN.
      nft => nft.tokenType !== NftTokenType.ERC1155
    );
    expect(nfts721.length).toEqual(response4.nfts.length);

    // Handles contract address specifying.
    const contractAddresses = [
      '0xa1eB40c284C5B44419425c4202Fa8DabFF31006b',
      '0x8442864d6AB62a9193be2F16580c08E0D7BCda2f'
    ];
    const response5 = await alchemy.nft.getTransfersForOwner(
      'vitalik.eth',
      GetTransfersForOwnerTransferType.TO,
      {
        contractAddresses
      }
    );
    const nftsWithAddress = response5.nfts.filter(nft =>
      contractAddresses.includes(nft.contract.address)
    );
    expect(nftsWithAddress.length).toEqual(response5.nfts.length);
  });

  it('getTransfersForContract() with multiple transfers for same token', async () => {
    // This is a sanity test since this block range contains two transfers for
    // the same token that will be included in the same NFT metadata batch.
    const CONTRACT = '0x0cdd3cb3bcd969c2b389488b51fb093cc0d703b1';
    const START_BLOCK = 16877400;
    const END_BLOCK = 16877500;

    const transactions = new Set<string>();
    const transfers = await alchemy.nft.getTransfersForContract(CONTRACT, {
      fromBlock: START_BLOCK,
      toBlock: END_BLOCK
    });

    transfers.nfts
      .filter(t => t.tokenId === '238')
      .forEach(t => transactions.add(t.transactionHash));
    console.log(transfers.nfts.length);

    expect(transactions.size).toEqual(2);
  });

  it('getTransfersForContract()', async () => {
    const CRYPTO_PUNKS_CONTRACT = '0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB';
    // Handles paging
    const response = await alchemy.nft.getTransfersForContract(
      CRYPTO_PUNKS_CONTRACT
    );
    expect(response.pageKey).toBeDefined();
    expect(response.nfts.length).toBeGreaterThan(0);
    const responseWithPageKey = await alchemy.nft.getTransfersForContract(
      CRYPTO_PUNKS_CONTRACT,
      {
        pageKey: response.pageKey
      }
    );
    expect(responseWithPageKey.nfts.length).toBeGreaterThan(0);
    expect(response.nfts[0]).not.toEqual(responseWithPageKey.nfts[0]);

    // Handles block ranges and sort order.
    const response2 = await alchemy.nft.getTransfersForContract(
      CRYPTO_PUNKS_CONTRACT,
      {
        fromBlock: 10000000,
        toBlock: 'latest',
        order: SortingOrder.DESCENDING
      }
    );
    expect(response2.nfts.length).toBeGreaterThan(0);
    expect(fromHex(response2.nfts[0].blockNumber)).toBeGreaterThanOrEqual(
      fromHex(response2.nfts[1].blockNumber)
    );
  });

  it('verifyNftOwnership() boolean', async () => {
    const response = await alchemy.nft.verifyNftOwnership(
      ownerAddress,
      contractAddress
    );
    expect(typeof response).toEqual('boolean');
  });

  it('verifyNftOwnership() map', async () => {
    const response = await alchemy.nft.verifyNftOwnership(ownerAddress, [
      contractAddress
    ]);
    expect(response[contractAddress]).toBeDefined();
    expect(typeof response[contractAddress]).toEqual('boolean');
  });

  it('refreshNftMetadata()', async () => {
    const contractAddress = '0x0510745d2ca36729bed35c818527c4485912d99e';
    const tokenId = '404';
    await alchemy.nft.refreshNftMetadata(contractAddress, tokenId);

    const nft = await alchemy.nft.getNftMetadata(contractAddress, tokenId);
    await alchemy.nft.refreshNftMetadata(nft.contract.address, nft.tokenId);
  });

  it('isSpamContract()', async () => {
    const response = await alchemy.nft.isSpamContract(contractAddress);
    expect(typeof response.isSpamContract).toEqual('boolean');
  });

  it('getSpamContracts()', async () => {
    const response = await alchemy.nft.getSpamContracts();
    expect(response.contractAddresses.length).toBeGreaterThan(0);
    expect(typeof response.contractAddresses[0]).toEqual('string');
  });

  it('reportSpam()', async () => {
    const response = await alchemy.nft.reportSpam(contractAddress);
    expect(typeof response).toEqual('undefined');
  });

  it('isAirdropNft()', async () => {
    const response = await alchemy.nft.isAirdropNft(contractAddress, '0');
    expect(typeof response.isAirdrop).toEqual('boolean');
  });

  it('getFloorPrice()', async () => {
    const response = await alchemy.nft.getFloorPrice(contractAddress);
    expect(response.openSea).toBeDefined();
    expect(response.looksRare).toBeDefined();
    expect((response.looksRare as any).error).not.toBeDefined();
  });

  it('getNftSales()', async () => {
    const response = await alchemy.nft.getNftSales();

    expect(response.pageKey).toBeDefined();
    verifyNftSalesData(response);
  });

  it('getNftSales() with token', async () => {
    const response = await alchemy.nft.getNftSales({
      contractAddress: '0xe785E82358879F061BC3dcAC6f0444462D4b5330',
      tokenId: 44
    });

    verifyNftSalesData(response);
    expect(response.nftSales[0].royaltyFee).toBeDefined();
    expect(response.nftSales[0].protocolFee).toBeDefined();
    expect(response.nftSales[0].sellerFee).toBeDefined();
  });

  it('getNftSales() with pageKey', async () => {
    const firstPage = await alchemy.nft.getNftSales();

    expect(firstPage.pageKey).not.toBeUndefined();
    const response = await alchemy.nft.getNftSales({
      pageKey: firstPage?.pageKey
    });

    expect(response.nftSales[0]).not.toEqual(firstPage.nftSales[0]);
  });

  it('getNftSales() with contractAddress', async () => {
    const contractAddress = '0xaF1cfc6b4104c797149fB7A294f7d46F7eC27B80';

    const response = await alchemy.nft.getNftSales({ contractAddress });

    expect(response.nftSales.length).toBeGreaterThan(0);
    expect(response.nftSales[0].contractAddress).toEqual(contractAddress);
  });

  it.each(
    Object.values(NftSaleMarketplace).filter(
      v => v !== NftSaleMarketplace.UNKNOWN
    )
  )(`getNftSales() with marketplace=%s`, async marketplace => {
    const response = await alchemy.nft.getNftSales({
      marketplace,
      limit: 10
    });

    response.nftSales.forEach(nftSale => {
      expect(nftSale.marketplace).toEqual(marketplace);
    });
  });

  it('computeRarity()', async () => {
    const contractAddress = '0x0510745d2ca36729bed35c818527c4485912d99e';
    const tokenId = '403';

    const response = await alchemy.nft.computeRarity(contractAddress, tokenId);

    expect(response).toBeDefined();
    expect(response.rarities.length).toBeGreaterThan(0);
    expect(response.rarities[0].prevalence).toBeDefined();
    expect(response.rarities[0].traitType).toBeDefined();
    expect(response.rarities[0].value).toBeDefined();
  });

  it('searchContractMetadata()', async () => {
    const query = 'meta alchemy';

    const response = await alchemy.nft.searchContractMetadata(query);

    expect(response).toBeDefined();
    expect(response.contracts.length).toBeGreaterThan(0);
    expect(response.contracts[0].address).toBeDefined();
    expect(typeof response.contracts[0].address).toEqual('string');
    expect(response.contracts[0].tokenType).toBeDefined();
  });

  it('summarizeNftAttributes()', async () => {
    const contractAddress = '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D';

    const response = await alchemy.nft.summarizeNftAttributes(contractAddress);

    expect(response).toBeDefined();
    expect(response.contractAddress).toBeDefined();
    expect(response.contractAddress).toEqual(contractAddress);
    expect(response.totalSupply).toBeDefined();
    expect(typeof response.totalSupply).toEqual('string');
    expect(response.summary).toBeDefined();
  });

  it('refreshNftContract()', async () => {
    const contractAddress = '0x0510745d2ca36729bed35c818527c4485912d99e';
    const result = await alchemy.nft.refreshContract(contractAddress);
    expect(result.contractAddress).toBeDefined();
  });
});


================================================================================
File: test\integration\notify.test.ts
Size: 17.07 kB
================================================================================

import {
  AddressActivityWebhook,
  Alchemy,
  CustomGraphqlWebhook,
  Network,
  NftActivityWebhook,
  NftFilter,
  NftMetadataUpdateWebhook,
  WebhookType
} from '../../src';
import { loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);
describe('E2E integration tests', () => {
  let alchemy: Alchemy;
  let appId: string;
  const activityAddresses = [
    '0x6f8d0c2a2c3a189803f5c6482c88be46a55058c1',
    '0x48ea66f94518534ecbc863fbf521896d52b025d9',
    '0xfdb16996831753d5331ff813c29a93c76834a0ad'
  ];
  const nftFilters = [
    {
      contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
      tokenId: 234
    },
    {
      contractAddress: '0x17dc95f9052f86ed576af55b018360f853e19ac2',
      tokenId: '345'
    }
  ];

  const webhookUrl = 'https://www.example.com';
  const graphqlQuery = '{ block { hash } }';

  let addressWh: AddressActivityWebhook;
  let nftWh: NftActivityWebhook;
  let nftMetadataWh: NftMetadataUpdateWebhook;
  let customWh: CustomGraphqlWebhook;

  async function createInitialWebhooks(): Promise<void> {
    addressWh = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.ADDRESS_ACTIVITY,
      { addresses: activityAddresses }
    );
    nftWh = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.NFT_ACTIVITY,
      { filters: nftFilters, network: Network.ETH_MAINNET }
    );
    nftMetadataWh = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.NFT_METADATA_UPDATE,
      { filters: nftFilters, network: Network.ETH_MAINNET }
    );
    customWh = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.GRAPHQL,
      {
        graphqlQuery,
        network: Network.ETH_MAINNET,
        appId,
        skipEmptyMessages: true
      }
    );
  }

  beforeAll(async () => {
    await loadAlchemyEnv();
    appId = process.env.ALCHEMY_APP_ID!;

    alchemy = new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY,
      authToken: process.env.ALCHEMY_AUTH_TOKEN
    });

    await createInitialWebhooks();
  });

  describe('has valid network mappings', () => {
    const UNSUPPORTED_NETWORKS = [
      Network.ASTAR_MAINNET,
      Network.POLYGONZKEVM_MAINNET,
      Network.POLYGONZKEVM_TESTNET
    ];
    const testAddress = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';

    function testNetwork(network: Network) {
      it(`can create a webhook on ${network}`, async () => {
        console.log('testing', network);
        const nftTest = await alchemy.notify.createWebhook(
          webhookUrl,
          WebhookType.ADDRESS_ACTIVITY,
          { addresses: [testAddress], network }
        );

        await alchemy.notify.deleteWebhook(nftTest.id);
      });
    }

    for (const network of Object.values(Network)) {
      if (!UNSUPPORTED_NETWORKS.includes(network)) {
        testNetwork(network);
      }
    }
  });

  it('getAllWebhooks()', async () => {
    const all = await alchemy.notify.getAllWebhooks();
    expect(all.totalCount).toBeGreaterThan(0);
    expect(all.webhooks.length).toEqual(all.totalCount);
  });

  it('getGraphqlQuery()', async () => {
    let response = await alchemy.notify.getGraphqlQuery(customWh);
    expect(response.graphqlQuery).toEqual(graphqlQuery);
    response = await alchemy.notify.getGraphqlQuery(customWh.id);
    expect(response.graphqlQuery).toEqual(graphqlQuery);
  });

  it('getAddresses()', async () => {
    let response = await alchemy.notify.getAddresses(addressWh);
    // Convert to lowercase since ENS resolution capitalizes hex string.
    expect(response.addresses.map(x => x.toLowerCase()).sort()).toEqual(
      activityAddresses.sort()
    );

    response = await alchemy.notify.getAddresses(addressWh.id);
    expect(response.addresses.map(x => x.toLowerCase()).sort()).toEqual(
      activityAddresses.sort()
    );
  });

  it('getAddresses() with limit', async () => {
    const response = await alchemy.notify.getAddresses(addressWh, {
      limit: 1
    });
    expect(response.totalCount).toEqual(3);
    expect(response.addresses.length).toEqual(1);
    expect(response.pageKey).toBeDefined();
    const response2 = await alchemy.notify.getAddresses(addressWh, {
      limit: 1,
      pageKey: response.pageKey
    });
    expect(response2.addresses.length).toEqual(1);
    expect(response2).not.toContain(response.addresses[0]);
  });

  it('getNftFilters()', async () => {
    const expectedNftFilters = [
      {
        contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
        tokenId: '234'
      },
      {
        contractAddress: '0x17dc95f9052f86ed576af55b018360f853e19ac2',
        tokenId: '345'
      }
    ];

    let response = await alchemy.notify.getNftFilters(nftWh);
    const sortFn = (a: NftFilter, b: NftFilter) =>
      (a?.tokenId ?? -1) < (b.tokenId ?? -1) ? 1 : -1;
    expect(response.filters.sort(sortFn)).toEqual(
      expectedNftFilters.sort(sortFn)
    );

    response = await alchemy.notify.getNftFilters(nftWh.id);
    expect(response.filters.sort(sortFn)).toEqual(
      expectedNftFilters.sort(sortFn)
    );
  });

  it('getNftFilters() with limit', async () => {
    const response = await alchemy.notify.getNftFilters(nftWh, {
      limit: 1
    });
    expect(response.totalCount).toEqual(2);
    expect(response.filters.length).toEqual(1);
    expect(response.pageKey).toBeDefined();
    const response2 = await alchemy.notify.getNftFilters(nftWh, {
      limit: 1,
      pageKey: response.pageKey
    });
    expect(response2.filters.length).toEqual(1);
    expect(response2).not.toContain(response.filters[0]);
  });

  it('create and delete MinedTransactionWebhook', async () => {
    const minedTxWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.MINED_TRANSACTION,
      { appId }
    );
    expect(minedTxWebhook.url).toEqual(webhookUrl);
    expect(minedTxWebhook.type).toEqual(WebhookType.MINED_TRANSACTION);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === minedTxWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(minedTxWebhook);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === minedTxWebhook.id).length
    ).toEqual(0);
  });

  it('create and delete DroppedTransactionWebhook', async () => {
    const droppedTxWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.DROPPED_TRANSACTION,
      { appId }
    );
    expect(droppedTxWebhook.url).toEqual(webhookUrl);
    expect(droppedTxWebhook.type).toEqual(WebhookType.DROPPED_TRANSACTION);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === droppedTxWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(droppedTxWebhook);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === droppedTxWebhook.id).length
    ).toEqual(0);
  });

  it('create and delete AddressActivityWebhook', async () => {
    const addressWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.ADDRESS_ACTIVITY,
      { addresses: activityAddresses, network: Network.OPT_MAINNET }
    );
    expect(addressWebhook.url).toEqual(webhookUrl);
    expect(addressWebhook.type).toEqual(WebhookType.ADDRESS_ACTIVITY);
    expect(addressWebhook.network).toEqual(Network.OPT_MAINNET);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === addressWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(addressWebhook);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === addressWebhook.id).length
    ).toEqual(0);
  });

  it('create and delete CustomWebhook', async () => {
    const customWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.GRAPHQL,
      {
        graphqlQuery,
        network: Network.ETH_MAINNET,
        appId,
        skipEmptyMessages: true
      }
    );
    expect(customWebhook.url).toEqual(webhookUrl);
    expect(customWebhook.type).toEqual(WebhookType.GRAPHQL);
    expect(customWebhook.network).toEqual(Network.ETH_MAINNET);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === customWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(customWebhook);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === customWebhook.id).length
    ).toEqual(0);
  });

  it('create AddressActivityWebhook with ENS', async () => {
    const rawAddress = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045';
    const addressWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.ADDRESS_ACTIVITY,
      { addresses: ['vitalik.eth'], network: Network.OPT_MAINNET }
    );

    const response = await alchemy.notify.getAddresses(addressWebhook);
    expect(response.addresses).toContain(rawAddress);
  });

  it('create and delete NftActivityWebhook', async () => {
    const network = Network.ETH_SEPOLIA;
    const nftActivityWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.NFT_ACTIVITY,
      { filters: nftFilters, network }
    );
    expect(nftActivityWebhook.url).toEqual(webhookUrl);
    expect(nftActivityWebhook.type).toEqual(WebhookType.NFT_ACTIVITY);
    expect(nftActivityWebhook.network).toEqual(network);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === nftActivityWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(nftActivityWebhook.id);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === nftActivityWebhook.id).length
    ).toEqual(0);
  });

  it('create and delete NftMetadataUpdateWebhook', async () => {
    const network = Network.ETH_MAINNET;
    const nftActivityWebhook = await alchemy.notify.createWebhook(
      webhookUrl,
      WebhookType.NFT_METADATA_UPDATE,
      { filters: nftFilters, network }
    );
    expect(nftActivityWebhook.url).toEqual(webhookUrl);
    expect(nftActivityWebhook.type).toEqual(WebhookType.NFT_METADATA_UPDATE);
    expect(nftActivityWebhook.network).toEqual(network);
    let response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === nftActivityWebhook.id).length
    ).toEqual(1);

    await alchemy.notify.deleteWebhook(nftActivityWebhook.id);
    response = await alchemy.notify.getAllWebhooks();
    expect(
      response.webhooks.filter(wh => wh.id === nftActivityWebhook.id).length
    ).toEqual(0);
  });

  it('update NftActivityWebhook filter with same filter', async () => {
    const addFilters = [
      // Duplicate filter
      {
        contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
        tokenId: '234'
      },
      // New Filter
      {
        contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
        tokenId: '123'
      }
    ];

    const removeFilters = [
      {
        contractAddress: '0x17dc95f9052f86ed576af55b018360f853e19ac2',
        tokenId: 345
      }
    ];

    await alchemy.notify.updateWebhook(nftWh, {
      addFilters,
      removeFilters
    });

    const response = await alchemy.notify.getNftFilters(nftWh);
    expect(response.filters.length).toEqual(2);

    await alchemy.notify.updateWebhook(nftWh, {
      removeFilters
    });

    await alchemy.notify.updateWebhook(nftWh, {
      addFilters
    });
  });

  it('update NftActivityWebhook status', async () => {
    await alchemy.notify.updateWebhook(nftWh.id, {
      isActive: false
    });
    const response = await alchemy.notify.getAllWebhooks();
    const updated = response.webhooks.filter(wh => wh.id === nftWh.id);
    expect(updated.length).toEqual(1);
    expect(updated[0].isActive).toEqual(false);
  });

  it('update CustomWebhook status', async () => {
    const webhooks = await alchemy.notify.getAllWebhooks();
    const filteredWebhooks = webhooks.webhooks.filter(
      webhook => webhook.id === customWh.id
    );
    expect(filteredWebhooks.length).toEqual(1);
    const customWebhook = filteredWebhooks[0];
    const currStatus = customWebhook.isActive;
    await alchemy.notify.updateWebhook(customWebhook.id, {
      isActive: !currStatus
    });
    const response = await alchemy.notify.getAllWebhooks();
    const updated = response.webhooks.filter(wh => wh.id === customWebhook.id);
    expect(updated.length).toEqual(1);
    expect(updated[0].isActive).toEqual(!currStatus);
  });

  it('update NftMetadataUpdateWebhook status', async () => {
    await alchemy.notify.updateWebhook(nftMetadataWh.id, {
      isActive: false
    });
    const response = await alchemy.notify.getAllWebhooks();
    const updated = response.webhooks.filter(wh => wh.id === nftMetadataWh.id);
    expect(updated.length).toEqual(1);
    expect(updated[0].isActive).toEqual(false);
  });

  it('update NftMetadataUpdateWebhook filter with same filter', async () => {
    const addMetadataFilters = [
      // Duplicate filter
      {
        contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
        tokenId: '234'
      },
      // New Filter
      {
        contractAddress: '0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656',
        tokenId: '123'
      }
    ];

    const removeMetadataFilters = [
      {
        contractAddress: '0x17dc95f9052f86ed576af55b018360f853e19ac2',
        tokenId: 345
      }
    ];

    await alchemy.notify.updateWebhook(nftWh, {
      addFilters: addMetadataFilters,
      removeFilters: removeMetadataFilters
    });

    const response = await alchemy.notify.getNftFilters(nftWh);
    expect(response.filters.length).toEqual(2);

    await alchemy.notify.updateWebhook(nftWh, {
      removeFilters: removeMetadataFilters
    });

    await alchemy.notify.updateWebhook(nftWh, {
      addFilters: addMetadataFilters
    });
  });

  it('update AddressActivityWebhook address', async () => {
    const addAddress = '0x7f268357A8c2552623316e2562D90e642bB538E5';
    const removeAddress = '0xfdb16996831753d5331ff813c29a93c76834a0ad';
    await alchemy.notify.updateWebhook(addressWh, {
      addAddresses: [addAddress],
      removeAddresses: [removeAddress]
    });
    const response = await alchemy.notify.getAddresses(addressWh);
    expect(response.addresses.length).toEqual(3);
    expect(response.addresses).toContain(addAddress);
    expect(response.addresses).not.toContain(removeAddress);

    await alchemy.notify.updateWebhook(addressWh, {
      removeAddresses: [removeAddress]
    });

    await alchemy.notify.updateWebhook(addressWh, {
      addAddresses: [addAddress]
    });
  });

  it('update AddressActivityWebhook address with ENS', async () => {
    const addAddress = 'vitalik.eth';
    const rawAddAddress = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045';
    await alchemy.notify.updateWebhook(addressWh, {
      addAddresses: [addAddress]
    });
    const response = await alchemy.notify.getAddresses(addressWh);
    expect(response.addresses).toContain(rawAddAddress);
  });

  it('override AddressActivityWebhook address', async () => {
    const newAddresses = ['0x7f268357A8c2552623316e2562D90e642bB538E5'];
    await alchemy.notify.updateWebhook(addressWh, {
      newAddresses
    });
    const response = await alchemy.notify.getAddresses(addressWh);
    expect(response.addresses.length).toEqual(1);
    expect(response.addresses[0]).toEqual(newAddresses[0]);
  });

  it('update AddressActivityWebhook status', async () => {
    await alchemy.notify.updateWebhook(addressWh, {
      isActive: false
    });
    const response = await alchemy.notify.getAllWebhooks();
    const updated = response.webhooks.filter(wh => wh.id === addressWh.id);
    expect(updated.length).toEqual(1);
    expect(updated[0].isActive).toEqual(false);
  });

  it('cleans up', async () => {
    const response = await alchemy.notify.getAllWebhooks();
    const tests = response.webhooks.filter(wh => wh.url === webhookUrl);

    await Promise.allSettled(tests.map(wh => alchemy.notify.deleteWebhook(wh)));
    const response2 = await alchemy.notify.getAllWebhooks();
    const remaining = response2.webhooks.filter(wh => wh.url === webhookUrl);
    expect(remaining.length).toEqual(0);
  });
});


================================================================================
File: test\integration\prices.test.ts
Size: 6.11 kB
================================================================================

import { Alchemy, Network } from '../../src';
import {
  HistoricalPriceInterval,
  TokenAddressRequest
} from '../../src/types/prices-types';
import { loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);

describe('Prices API Integration Tests', () => {
  let alchemy: Alchemy;

  beforeAll(async () => {
    await loadAlchemyEnv();
    alchemy = new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY
    });
  });

  describe('getTokenPriceByAddress()', () => {
    it('should get token prices by address', async () => {
      const addresses: TokenAddressRequest[] = [
        {
          network: Network.ETH_MAINNET,
          address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' // WBTC
        },
        {
          network: Network.MATIC_MAINNET,
          address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619' // WETH on Polygon
        }
      ];

      const response = await alchemy.prices.getTokenPriceByAddress(addresses);

      expect(response.data).toBeDefined();
      expect(response.data.length).toBe(2);

      // Check WBTC response
      const wbtcResult = response.data.filter(
        result => result.address === addresses[0].address
      )[0];
      expect(wbtcResult.network).toBe('eth-mainnet');
      expect(wbtcResult.address).toBe(addresses[0].address);
      expect(wbtcResult.prices.length).toBeGreaterThan(0);
      expect(wbtcResult.error).toBeUndefined();
      expect(parseFloat(wbtcResult.prices[0].value)).toBeGreaterThan(0);
      expect(wbtcResult.prices[0].currency).toBe('usd');
      expect(new Date(wbtcResult.prices[0].lastUpdatedAt)).toBeTruthy();

      // Check WETH response
      const wethResult = response.data.filter(
        result => result.address === addresses[1].address
      )[0];
      expect(wethResult.network).toBe('polygon-mainnet');
      expect(wethResult.address).toBe(addresses[1].address);
      expect(wethResult.error).toBeUndefined();
      expect(parseFloat(wethResult.prices[0].value)).toBeGreaterThan(0);
      expect(wethResult.prices[0].currency).toBe('usd');
      expect(new Date(wethResult.prices[0].lastUpdatedAt)).toBeTruthy();
    });

    it('should handle invalid addresses', async () => {
      const addresses: TokenAddressRequest[] = [
        {
          network: Network.ETH_MAINNET,
          address: '0x0000000000000000000000000000000000000000'
        }
      ];

      const response = await alchemy.prices.getTokenPriceByAddress(addresses);

      expect(response.data).toBeDefined();
      expect(response.data.length).toBe(1);
      expect(response.data[0].error).toBeDefined();
      expect(response.data[0].prices).toHaveLength(0);
    });

    it('should handle invalid networks', async () => {
      const addresses: TokenAddressRequest[] = [
        {
          network: 'invalid-network' as any,
          address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599'
        }
      ];

      const response = await alchemy.prices.getTokenPriceByAddress(addresses);
      expect(response.data[0].error).toBeDefined();
      expect(response.data[0].prices).toHaveLength(0);
    });
  });

  describe('getTokenPriceBySymbol()', () => {
    it('should get token prices by symbol', async () => {
      const symbols = ['AAVE', 'UNI', 'INVALID_SYMBOL'];
      const response = await alchemy.prices.getTokenPriceBySymbol(symbols);

      expect(response.data).toBeDefined();
      expect(response.data.length).toBe(3);

      // Check AAVE response
      const aaveResult = response.data[0];
      expect(aaveResult.symbol).toBe('AAVE');
      expect(aaveResult.prices.length).toBeGreaterThan(0);
      expect(aaveResult.error).toBeUndefined();
      expect(parseFloat(aaveResult.prices[0].value)).toBeGreaterThan(0);
      expect(aaveResult.prices[0].currency).toBe('usd');
      expect(new Date(aaveResult.prices[0].lastUpdatedAt)).toBeTruthy();

      // Check UNI response
      const uniResult = response.data[1];
      expect(uniResult.symbol).toBe('UNI');
      expect(uniResult.prices.length).toBeGreaterThan(0);
      expect(uniResult.error).toBeUndefined();
      expect(parseFloat(uniResult.prices[0].value)).toBeGreaterThan(0);

      // Check invalid symbol response
      const invalidResult = response.data[2];
      expect(invalidResult.symbol).toBe('INVALID_SYMBOL');
      expect(invalidResult.prices).toHaveLength(0);
      expect(invalidResult.error).toBeDefined();
    });
  });

  describe('getHistoricalPriceBySymbol()', () => {
    it('should get historical prices by symbol', async () => {
      const response = await alchemy.prices.getHistoricalPriceBySymbol(
        'UNI',
        1704067200,
        '2024-01-02T00:00:00Z',
        HistoricalPriceInterval.ONE_HOUR
      );

      expect(response.symbol).toBe('UNI');
      expect(response.currency).toBe('usd');
      expect(response.data).toBeDefined();
      expect(response.data.length).toBeGreaterThan(0);

      const dataPoint = response.data[0];
      expect(parseFloat(dataPoint.value)).toBeGreaterThan(0);
      expect(new Date(dataPoint.timestamp)).toBeTruthy();
    });
  });

  describe('getHistoricalPriceByAddress()', () => {
    it('should get historical prices by address', async () => {
      const response = await alchemy.prices.getHistoricalPriceByAddress(
        Network.ETH_MAINNET,
        '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984', // UNI token
        '2024-01-01T00:00:00Z',
        1731693158,
        HistoricalPriceInterval.ONE_DAY
      );

      expect(response.network).toBe('eth-mainnet');
      expect(response.address).toBe(
        '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984'
      );
      expect(response.currency).toBe('usd');
      expect(response.data).toBeDefined();
      expect(response.data.length).toBeGreaterThan(0);

      const dataPoint = response.data[0];
      expect(parseFloat(dataPoint.value)).toBeGreaterThan(0);
      expect(new Date(dataPoint.timestamp)).toBeTruthy();
    });
  });
});


================================================================================
File: test\integration\provider.test.ts
Size: 4.38 kB
================================================================================

import { AlchemyProvider as EthersAlchemyProvider } from '@ethersproject/providers';

import {
  Alchemy,
  AlchemyProvider,
  AlchemySubscription,
  AlchemyWebSocketProvider
} from '../../src';
import { EthersNetwork } from '../../src/util/const';
import { loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);
/**
 * These integrations are sanity checks to ensure that the SDK's overriden
 * implementation of {@link AlchemyProvider} is working as expected.
 */
// TODO(ethers): Figure out appropriate unit tests for the SDK's custom AlchemyProvider.
describe('AlchemyProvider', () => {
  let alchemy: Alchemy;
  let wsProvider: AlchemyWebSocketProvider;
  let provider: AlchemyProvider;
  let ethersProvider: EthersAlchemyProvider;

  beforeEach(async () => {
    await loadAlchemyEnv();
    alchemy = new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY
    });
    ethersProvider = new EthersAlchemyProvider(
      EthersNetwork[alchemy.config.network],
      alchemy.config.apiKey
    );
    wsProvider = await alchemy.config.getWebSocketProvider();
    provider = await alchemy.config.getProvider();
  });

  afterEach(async () => {
    await wsProvider.destroy();
  });

  // TODO(ethers): Extract into helper method to verify all inputs.
  it('methods should return the same result', async () => {
    const expected = await ethersProvider.send('eth_getBalance', [
      '0xc94770007dda54cF92009BFF0dE90c06F603a09f',
      'latest'
    ]);
    const actual = await provider.send('eth_getBalance', [
      '0xc94770007dda54cF92009BFF0dE90c06F603a09f',
      'latest'
    ]);
    expect(actual).toEqual(expected);
  });

  it('alchemy_pendingTransactions', done => {
    let eventCount = 0;
    const address = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    wsProvider.on(
      {
        method: AlchemySubscription.PENDING_TRANSACTIONS,
        toAddress: address,
        hashesOnly: true
      },
      (res: string) => {
        expect(res.substring(0, 2)).toEqual('0x');
        if (eventCount === 5) {
          done();
        }
        eventCount++;
      }
    );
  });

  it('alchemy_minedTransactions', done => {
    let eventCount = 0;
    wsProvider.on(
      {
        method: AlchemySubscription.MINED_TRANSACTIONS,
        hashesOnly: true
      },
      (res: any) => {
        expect(res.transaction).toBeDefined();
        expect(typeof res.transaction.hash).toEqual('string');
        if (eventCount === 5) {
          done();
        }
        eventCount++;
      }
    );
  });

  it('once', done => {
    const address = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    let eventCount = 0;
    wsProvider.once(
      {
        method: AlchemySubscription.PENDING_TRANSACTIONS,
        toAddress: address,
        hashesOnly: true
      },
      () => {
        eventCount++;
        if (eventCount > 1) {
          done();
        }
      }
    );

    wsProvider.once(
      {
        method: AlchemySubscription.PENDING_TRANSACTIONS,
        toAddress: address,
        hashesOnly: true
      },
      () => {
        eventCount++;
        if (eventCount > 1) {
          done();
        }
      }
    );
  });

  it('can send normal json-rpc methods', async () => {
    const res = await wsProvider.getBlockNumber();
    expect(typeof res).toBe('number');
  });

  it('full transactions', done => {
    let eventCount = 0;
    wsProvider.on(
      {
        method: AlchemySubscription.PENDING_TRANSACTIONS
      },
      () => {
        if (eventCount === 10) {
          done();
        }
        eventCount++;
      }
    );
  });
  //
  it('handles blocks', done => {
    wsProvider.on('block', res => {
      expect(typeof res).toEqual('number');
      done();
    });
  });

  it('batching mode resolves promises', async () => {
    alchemy = new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY,
      batchRequests: true
    });

    const p1 = alchemy.core.getGasPrice();
    const p2 = alchemy.core.getBlockNumber();
    await p1;
    await p2;
  });

  // // TODO(ethers): Write tests to make sure that the SDK's provider instance
  // // has the correct network mappings compared to Ethers.
  // it('network mappings should be correct', () => {});
});


================================================================================
File: test\integration\transact.test.ts
Size: 17.46 kB
================================================================================

import {
  Alchemy,
  DebugCallType,
  DecodingAuthority,
  GasOptimizedTransactionStatus,
  Network,
  SimulateAssetType,
  SimulateChangeType,
  Utils,
  Wallet
} from '../../src';
import { TESTING_PRIVATE_KEY, loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);
describe('E2E integration tests', () => {
  let alchemy: Alchemy;

  beforeAll(async () => {
    await loadAlchemyEnv();
    alchemy = new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY,
      network: Network.ETH_MAINNET
    });
  });

  it('sendPrivateTransaction()', async () => {
    const transaction = {
      to: '0xa238b6008Bc2FBd9E386A5d4784511980cE504Cd',
      // Use random number to allow back to back runs.
      value: Math.floor(Math.random() * 10000),
      nonce: 2,
      type: 2,
      maxFeePerGas: 30000,
      chainId: 1
    };

    const wallet = new Wallet(TESTING_PRIVATE_KEY);
    const signed = await wallet.signTransaction(transaction);
    const response = await alchemy.transact.sendPrivateTransaction(signed);
    expect(typeof response).toEqual('string');
  });

  describe('simulateAssetChangesBundle()', () => {
    const transferAToB = {
      from: '0x699aeca448ad51effd6dbee0a8618a79cf4370ba',
      to: '0x32e74d0b224e3ab4e854e81adc645dac9968ee93',
      data: '0x23b872dd000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370ba000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bb0000000000000000000000000000000000000000000000000000000000000625'
    };
    const transferBToC = {
      from: '0x699aeca448ad51effd6dbee0a8618a79cf4370bb',
      to: '0x32e74d0b224e3ab4e854e81adc645dac9968ee93',
      data: '0x23b872dd000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bb000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bc0000000000000000000000000000000000000000000000000000000000000625'
    };

    const block = '0xF604F8';

    it('can simulate bundle successfully', async () => {
      const res = await alchemy.transact.simulateAssetChangesBundle(
        [transferAToB, transferBToC],
        block
      );
      expect(res).toHaveLength(2);
      expect(res[0].error).toBeUndefined();
      expect(res[0].changes).toHaveLength(1);
      expect(res[0].changes[0].assetType).toBe(SimulateAssetType.ERC721);
      expect(res[0].changes[0].changeType).toBe(SimulateChangeType.TRANSFER);
      expect(res[0].changes[0].from).toBe(
        '0x699aeca448ad51effd6dbee0a8618a79cf4370ba'
      );
      expect(res[0].changes[0].to).toBe(
        '0x699aeca448ad51effd6dbee0a8618a79cf4370bb'
      );

      expect(res[1].error).toBeUndefined();
      expect(res[1].changes).toHaveLength(1);
      expect(res[1].changes[0].assetType).toBe(SimulateAssetType.ERC721);
      expect(res[1].changes[0].changeType).toBe(SimulateChangeType.TRANSFER);
      expect(res[1].changes[0].from).toBe(
        '0x699aeca448ad51effd6dbee0a8618a79cf4370bb'
      );
      expect(res[1].changes[0].to).toBe(
        '0x699aeca448ad51effd6dbee0a8618a79cf4370bc'
      );
    });

    it('can simulate bundle with revert', async () => {
      const res = await alchemy.transact.simulateAssetChangesBundle(
        [transferBToC, transferAToB],
        block
      );
      expect(typeof res[0].error!.message).toBe('string');
      expect(res[0].changes).toHaveLength(0);
    });
  });

  describe('simulateExecutionBundle()', () => {
    const transferAToB = {
      from: '0x699aeca448ad51effd6dbee0a8618a79cf4370ba',
      to: '0x32e74d0b224e3ab4e854e81adc645dac9968ee93',
      data: '0x23b872dd000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370ba000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bb0000000000000000000000000000000000000000000000000000000000000625'
    };
    const transferBToC = {
      from: '0x699aeca448ad51effd6dbee0a8618a79cf4370bb',
      to: '0x32e74d0b224e3ab4e854e81adc645dac9968ee93',
      data: '0x23b872dd000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bb000000000000000000000000699aeca448ad51effd6dbee0a8618a79cf4370bc0000000000000000000000000000000000000000000000000000000000000625'
    };

    const block = '0xF604F8';

    it('can simulate bundle successfully', async () => {
      const res = await alchemy.transact.simulateExecutionBundle(
        [transferAToB, transferBToC],
        block
      );
      expect(res).toHaveLength(2);
      expect(res[0].calls).toHaveLength(1);
      expect(res[0].logs).toHaveLength(1);

      expect(res[1].calls).toHaveLength(1);
      expect(res[1].logs).toHaveLength(1);
    });

    it('can simulate bundle with revert', async () => {
      const res = await alchemy.transact.simulateExecutionBundle(
        [transferBToC, transferAToB],
        block
      );

      expect(res[0].calls.length).toBe(1);
      expect(typeof res[0].calls[0].error).toBe('string');
    });
  });

  describe('simulateAssetChanges()', () => {
    // vitalik.eth transferring 1 USDC to random address
    const USDC_CONTRACT_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
    const transaction = {
      from: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
      to: USDC_CONTRACT_ADDRESS,
      value: '0x0',
      data: '0xa9059cbb000000000000000000000000fc43f5f9dd45258b3aff31bdbe6561d97e8b71de00000000000000000000000000000000000000000000000000000000000f4240'
    };

    it('can simulate transaction with block identifier', async () => {
      const res = await alchemy.transact.simulateAssetChanges(
        transaction,
        'latest'
      );
      expect(res.changes).toBeDefined();
      expect(res.changes).toHaveLength(1);
      expect(res.error).toBeUndefined();
    });

    it('can simulate transaction with no identifier ', async () => {
      const res = await alchemy.transact.simulateAssetChanges(transaction);
      const change = res.changes[0];
      expect(change.assetType).toBe(SimulateAssetType.ERC20);
      expect(change.changeType).toBe(SimulateChangeType.TRANSFER);
      expect(change.from).toBe(transaction.from.toLowerCase());
      expect(change.to).toBeDefined();
      expect(change.rawAmount).toBe('1000000');
      expect(change.contractAddress).toBe(USDC_CONTRACT_ADDRESS.toLowerCase());
      expect(change.tokenId).toBeUndefined();
      expect(change.decimals).toBe(6);
      expect(change.symbol).toBe('USDC');
      expect(change.name).toBe('USD Coin');
      expect(change.logo).toBe(
        'https://static.alchemyapi.io/images/assets/3408.png'
      );
      expect(change.amount).toBe('1');
    });

    it('can simulate transactions that revert', async () => {
      const transaction = {
        from: '0x538dF212DEf9d27B646B733cB267a69cBE1b77ad',
        to: '0x00000000006c3852cbEf3e08E8dF289169EdE581',
        value: '0x38d7ea4c68000',
        data: '0xfb0f3ee100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e609c82d34e000000000000000000000000000a0553e045fda77dbbe741ffd5b58ae7cefdab380000000000000000000000000004c00500000ad104d7dbd00e3ae0a5c00560c000000000000000000000000003ab3fdd225bb64268d39265c05550427257129b100000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000063d136550000000000000000000000000000000000000000000000000000000063da70d40000000000000000000000000000000000000000000000000000000000000000360c6ebe000000000000000000000000000000000000000060ce396f48879da70000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f00000000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f00000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000006379da05b60000000000000000000000000000000a26b00c1f0df003000390027140000faa719000000000000000000000000000000000000000000000000000c6f3b40b6c00000000000000000000000000059e601a72a776d39efdb33e06b046357f3ce50500000000000000000000000000000000000000000000000000000000000000040aac1402fa335a3bb20a69991578f1a19be008c44d00f8d8bb1619471ef3fd67429b910868e87f42a97ad637d09010d68cdce3011bff12f8ba6448a69ce1bed3400000000360c6ebe',
        gas: '0x266ce'
      };
      const res = await alchemy.transact.simulateAssetChanges(
        transaction,
        'latest'
      );
      expect(res.changes.length).toEqual(0);
      expect(res.gasUsed).toBeUndefined();
      expect(typeof res.error?.message).toEqual('string');
    });

    it('can simulate approvals', async () => {
      const transaction = {
        from: '0xa06c3c08a19e51b33309eddfb356c33ead8517a3',
        to: '0xB54420149dBE2D5B2186A3e6dc6fC9d1A58316d4',
        value: '0x0',
        data: '0xa22cb4650000000000000000000000000dd7eef07982749410eceaa721cdc8ff3167fc9b0000000000000000000000000000000000000000000000000000000000000001',
        gas: '0x266ce'
      };

      const res = await alchemy.transact.simulateAssetChanges(transaction);
      expect(res.changes.length).toEqual(1);
      expect(res.changes[0].changeType).toEqual(SimulateChangeType.APPROVE);
      expect(res.changes[0].decimals).toEqual(0);
    });

    // TODO(bastien): Add test for ERC721 transfer and verify fields
    it('can simulate ERC721 transfers', async () => {});
  });

  describe('simulateExecution()', () => {
    // vitalik.eth transferring 1 USDC to random address
    const USDC_CONTRACT_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
    const transaction = {
      from: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
      to: USDC_CONTRACT_ADDRESS,
      value: '0x0',
      data: '0xa9059cbb000000000000000000000000fc43f5f9dd45258b3aff31bdbe6561d97e8b71de00000000000000000000000000000000000000000000000000000000000f4240'
    };

    it('can simulate a transaction', async () => {
      const res = await alchemy.transact.simulateExecution(transaction);
      expect(res.calls).toBeDefined();
      expect(res.logs).toBeDefined();
      expect(res.logs).toHaveLength(1);
    });

    // TODO(bastien): verify the decoded logs.
    it('can simulate sending 1 USDC', async () => {
      const { calls, logs } = await alchemy.transact.simulateExecution(
        transaction
      );

      expect(calls).toHaveLength(2);
      expect(logs).toHaveLength(1);

      // Call 1
      expect(calls[0].type).toBe(DebugCallType.CALL);
      expect(calls[0].from).toBe('0xd8da6bf26964af9d7eed9e03e53415d37aa96045');
      expect(calls[0].to).toBe('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');
      expect(calls[0].value).toBe('0x0');
      expect(calls[0].gas).toBe('0x7fffffffffffaad0');
      expect(Utils.isHexString(calls[0].gasUsed)).toBe(true);
      expect(calls[0].input).toBe(
        '0xa9059cbb000000000000000000000000fc43f5f9dd45258b3aff31bdbe6561d97e8b71de00000000000000000000000000000000000000000000000000000000000f4240'
      );
      expect(calls[0].output).toBe(
        '0x0000000000000000000000000000000000000000000000000000000000000001'
      );

      // Call 2
      expect(calls[1].type).toBe(DebugCallType.DELEGATECALL);
      expect(calls[1].from).toBe('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48');
      expect(calls[1].to).toBe('0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf');
      expect(calls[1].value).toBeUndefined();
      expect(calls[1].gas).toBe('0x7dffffffffff8ef8');
      expect(calls[1].gasUsed).toBe('0x4cac');
      expect(calls[1].input).toBe(
        '0xa9059cbb000000000000000000000000fc43f5f9dd45258b3aff31bdbe6561d97e8b71de00000000000000000000000000000000000000000000000000000000000f4240'
      );
      expect(calls[1].output).toBe(
        '0x0000000000000000000000000000000000000000000000000000000000000001'
      );
      expect(calls[1].decoded).toStrictEqual({
        authority: DecodingAuthority.ETHERSCAN,
        methodName: 'transfer',
        inputs: [
          {
            name: 'to',
            value: '0xfc43f5f9dd45258b3aff31bdbe6561d97e8b71de',
            type: 'address'
          },
          {
            name: 'value',
            value: '1000000',
            type: 'uint256'
          }
        ],
        outputs: [
          {
            name: '',
            value: 'true',
            type: 'bool'
          }
        ]
      });

      // Logs
      expect(logs[0].topics).toBeDefined();
      expect(logs[0].address).toBe(
        '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
      );
      expect(logs[0].data).toBe(
        '0x00000000000000000000000000000000000000000000000000000000000f4240'
      );
      expect(logs[0].decoded).toBeUndefined();
    });

    it('can simulate transactions that revert', async () => {
      const transaction = {
        from: '0x538dF212DEf9d27B646B733cB267a69cBE1b77ad',
        to: '0x00000000006c3852cbEf3e08E8dF289169EdE581',
        value: '0x38d7ea4c68000',
        data: '0xfb0f3ee100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e609c82d34e000000000000000000000000000a0553e045fda77dbbe741ffd5b58ae7cefdab380000000000000000000000000004c00500000ad104d7dbd00e3ae0a5c00560c000000000000000000000000003ab3fdd225bb64268d39265c05550427257129b100000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000063d136550000000000000000000000000000000000000000000000000000000063da70d40000000000000000000000000000000000000000000000000000000000000000360c6ebe000000000000000000000000000000000000000060ce396f48879da70000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f00000000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f00000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000006379da05b60000000000000000000000000000000a26b00c1f0df003000390027140000faa719000000000000000000000000000000000000000000000000000c6f3b40b6c00000000000000000000000000059e601a72a776d39efdb33e06b046357f3ce50500000000000000000000000000000000000000000000000000000000000000040aac1402fa335a3bb20a69991578f1a19be008c44d00f8d8bb1619471ef3fd67429b910868e87f42a97ad637d09010d68cdce3011bff12f8ba6448a69ce1bed3400000000360c6ebe',
        gas: '0x266ce'
      };
      const res = await alchemy.transact.simulateExecution(transaction);
      expect(res.calls.length).toBe(1);
      expect(typeof res.calls[0].error).toBe('string');
    });
  });

  // TODO(txjob): enable once released
  describe.skip('sendGasOptimizedTransaction()', () => {
    it('can send signed transactions', async () => {
      const response = await alchemy.transact.sendGasOptimizedTransaction([
        '0x02f86f0107847735940085174876e8008252089415fdad99a4b0c72fc5c2761542e1b17cff7357de843b9aca0080c080a0db73b4c108202f2a0d22d8836ccb2052b24aaffbcbd8222e2030d0b8d68c3218a01ec636ff8a3a6125ba524d72348e91c96be5ac8330eadab31e70e753fbe00236'
      ]);
      const tx = await alchemy.transact.getTransaction(
        response.transactionHashes[0]
      );
      expect(tx).toBeDefined();
    });

    it('can send a raw transaction', async () => {
      const transaction = {
        to: '0xa238b6008Bc2FBd9E386A5d4784511980cE504Cd',
        value: 10000,
        nonce: 2,
        type: 2,
        chainId: 5
      };

      const wallet = new Wallet(TESTING_PRIVATE_KEY);
      const response = await alchemy.transact.sendGasOptimizedTransaction(
        transaction,
        wallet
      );
      expect(typeof response.trackingId).toEqual('string');
      expect(response.transactionHashes.length).toEqual(5);
    });
  });

  // TODO(txjob): enable once released
  describe.skip('getGasOptimizedTransactionStatus()', () => {
    it('can get the transaction state', async () => {
      const response = await alchemy.transact.sendGasOptimizedTransaction([
        '0x02f86f0107847735940085174876e8008252089415fdad99a4b0c72fc5c2761542e1b17cff7357de843b9aca0080c080a0db73b4c108202f2a0d22d8836ccb2052b24aaffbcbd8222e2030d0b8d68c3218a01ec636ff8a3a6125ba524d72348e91c96be5ac8330eadab31e70e753fbe00236'
      ]);

      const response2 = await alchemy.transact.getGasOptimizedTransactionStatus(
        response.trackingId
      );
      expect(
        Object.values(GasOptimizedTransactionStatus).includes(
          response2.jobStatus
        )
      ).toBe(true);
      expect(typeof response2.minedTransactionHash).toEqual('string');
    });
  });
});


================================================================================
File: test\integration\wallet.test.ts
Size: 2.41 kB
================================================================================

import { Wallet as EthersWallet } from '@ethersproject/wallet';

import { Alchemy, Network, Wallet } from '../../src';
import { TEST_WALLET_PRIVATE_KEY, loadAlchemyEnv } from '../test-util';

describe('Alchemy-Ethers Wallet', () => {
  let alchemy: Alchemy;

  beforeAll(async () => {
    await loadAlchemyEnv();
    const settings = {
      apiKey: process.env.ALCHEMY_API_KEY,
      network: Network.ETH_MAINNET
    };
    alchemy = new Alchemy(settings);
  });

  it('Matches functionality of Ethers Signer', async () => {
    const alchProvider = await alchemy.config.getProvider();

    const alchWallet = new Wallet(TEST_WALLET_PRIVATE_KEY, alchemy);
    const ethersWallet = new EthersWallet(
      TEST_WALLET_PRIVATE_KEY,
      alchProvider
    );
    const blockTag = 15000000;

    expect(await alchWallet.getBalance(blockTag)).toEqual(
      await ethersWallet.getBalance(blockTag)
    );
    expect(await alchWallet.getTransactionCount(blockTag)).toEqual(
      await ethersWallet.getTransactionCount(blockTag)
    );
    expect(await alchWallet.getChainId()).toEqual(
      await ethersWallet.getChainId()
    );
    expect(await alchWallet.getGasPrice()).toEqual(
      await ethersWallet.getGasPrice()
    );
    expect(await alchWallet.getFeeData()).toEqual(
      await ethersWallet.getFeeData()
    );
    expect(await alchWallet.resolveName('ricmoo.eth')).toEqual(
      await ethersWallet.resolveName('ricmoo.eth')
    );
  });

  it('Works with Alchemy object and Provider object', async () => {
    const alchProvider = await alchemy.config.getProvider();

    const alchWallet = new Wallet(TEST_WALLET_PRIVATE_KEY, alchemy);
    const providerWallet = new Wallet(TEST_WALLET_PRIVATE_KEY, alchProvider);
    const blockTag = 15000000;

    expect(await alchWallet.getBalance(blockTag)).toEqual(
      await providerWallet.getBalance(blockTag)
    );
    expect(await alchWallet.getTransactionCount(blockTag)).toEqual(
      await providerWallet.getTransactionCount(blockTag)
    );
    expect(await alchWallet.getChainId()).toEqual(
      await providerWallet.getChainId()
    );
    expect(await alchWallet.getFeeData()).toEqual(
      await providerWallet.getFeeData()
    );
    expect(await alchWallet.resolveName('ricmoo.eth')).toEqual(
      await providerWallet.resolveName('ricmoo.eth')
    );
  });
});


================================================================================
File: test\test-util.ts
Size: 8.64 kB
================================================================================

import {
  BaseNft,
  Nft,
  NftContract,
  NftSaleMarketplace,
  NftSaleTakerType,
  NftTokenType,
  OwnedBaseNft,
  OwnedNft,
  toHex
} from '../src';
import {
  RawNft,
  RawNftContractForNft,
  RawNftContractForOwner,
  RawNftImage,
  RawNftSale,
  RawNftSaleFeeData,
  RawOpenSeaCollectionMetadata,
  RawOwnedBaseNft,
  RawOwnedNft
} from '../src/internal/raw-interfaces';
import { BlockHead, LogsEvent } from '../src/internal/websocket-backfiller';
import { getNftFromRaw } from '../src/util/util';

export const TEST_WALLET_PRIVATE_KEY =
  'dd5bdf09397b1fdf98e4f72c66047d5104b1511fa7dc1b8fdddd61a150f732c9';
export const TEST_WALLET_PUBLIC_ADDRESS =
  '0x4b9007B0BcE78cfB634032ec31Ed56adB464287b';

export function createRawOpenSeaCollectionMetadata(): RawOpenSeaCollectionMetadata {
  return {
    floorPrice: 2.2998,
    collectionName: 'Collection Name',
    collectionSlug: 'collectionname',
    safelistRequestStatus: 'verified',
    imageUrl: 'http://image.url',
    bannerImageUrl: 'http://banner.url',
    description: 'A sample description',
    externalUrl: 'http://external.url',
    twitterUsername: 'twitter-handle',
    discordUrl: 'https://discord.gg/example',
    lastIngestedAt: '2022-10-26T22:24:49.000Z'
  };
}

export function createRawOwnedBaseNft(
  address: string,
  tokenId: string,
  balance: string
): RawOwnedBaseNft {
  return {
    contractAddress: address,
    tokenId,
    balance
  };
}

export function createOwnedBaseNft(
  address: string,
  tokenId: string,
  balance: string
): OwnedBaseNft {
  return {
    ...createBaseNft(address, tokenId),
    balance
  };
}

export function createBaseNft(
  contractAddress: string,
  tokenId: string
): BaseNft {
  return {
    contractAddress,
    tokenId
  };
}

export function createNft(
  title: string,
  address: string,
  tokenId: string,
  tokenType = NftTokenType.UNKNOWN,
  tokenUri?: string
): Nft {
  return getNftFromRaw(
    createRawNft(address, title, tokenId, tokenType, {
      ...(tokenUri && { tokenUri })
    })
  );
}

export function createRawNftContract(
  address: string,
  overrides: Partial<RawNftContractForNft> = {}
): RawNftContractForNft {
  return {
    address,
    tokenType: NftTokenType.ERC721,
    name: 'NFT Contract',
    symbol: 'NFT',
    totalSupply: '100',
    contractDeployer: '0x000',
    deployedBlockNumber: 1,
    openSeaMetadata: createRawOpenSeaCollectionMetadata(),
    isSpam: false,
    spamClassifications: [],
    ...overrides
  };
}

export function createRawNft(
  contractAddress: string,
  name: string,
  tokenId: string,
  tokenType = NftTokenType.UNKNOWN,
  overrides?: Partial<RawNft>
): RawNft {
  return {
    contract: {
      ...createRawNftContract(contractAddress),
      ...overrides?.contract
    },
    name,
    description: `a truly unique NFT: ${name}`,
    timeLastUpdated: '2022-02-16T17:12:00.280Z',
    tokenId,
    tokenType: tokenType.toString(),
    tokenUri: 'https://token.uri',
    image: emptyNftImage,
    raw: {
      tokenUri: 'https://token.uri',
      metadata: {},
      error: null
    },
    collection: {
      name: 'Collection Name',
      slug: 'collection-name-slug',
      externalUrl: 'https://external.url',
      bannerImageUrl: 'https://banner.image.url'
    },
    ...overrides
  };
}

export function createRawOwnedNft(
  title: string,
  address: string,
  tokenId: string,
  balance: string,
  tokenType = NftTokenType.UNKNOWN,
  contract?: Partial<RawNftContractForNft>
): RawOwnedNft {
  return {
    ...createRawNft(address, title, tokenId, tokenType, {
      contract: {
        ...createRawNftContract(address),
        ...contract
      }
    }),
    balance
  };
}

export function createOwnedNft(
  title: string,
  address: string,
  tokenId: string,
  balance: string,
  tokenType = NftTokenType.UNKNOWN
): OwnedNft {
  return {
    ...createNft(title, address, tokenId, tokenType),
    balance
  };
}

export function createRawNftSale(
  marketplaceAddress: string,
  contractAddress: string,
  tokenId: string,
  marketplace: NftSaleMarketplace,
  taker: NftSaleTakerType,
  buyerAddress: string,
  sellerAddress: string
): RawNftSale {
  const feeData: RawNftSaleFeeData = {
    amount: '100',
    tokenAddress: '0x423',
    decimals: 18,
    symbol: 'ETH'
  };

  return {
    blockNumber: 15948091,
    bundleIndex: 0,
    buyerAddress,
    marketplaceAddress,
    contractAddress,
    logIndex: 392,
    marketplace,
    protocolFee: feeData,
    quantity: '2',
    royaltyFee: feeData,
    sellerFee: feeData,
    sellerAddress,
    taker,
    tokenId,
    transactionHash:
      '0xacad756c9094473a72f042e47cededcd11398333bbc64445f70266b85a929435'
  };
}

const emptyNftImage: RawNftImage = {
  cachedUrl: null,
  thumbnailUrl: null,
  pngUrl: null,
  contentType: null,
  size: null,
  originalUrl: null
};

export function createRawContractForOwner(
  address: string,
  overrides?: Partial<RawNftContractForOwner>
): RawNftContractForOwner {
  return {
    address,
    displayNft: {
      tokenId: '0x0',
      name: null
    },
    image: emptyNftImage,
    openSeaMetadata: createRawOpenSeaCollectionMetadata(),
    isSpam: false,
    totalBalance: '1',
    numDistinctTokensOwned: '1',
    name: 'NFT Name' ?? null,
    totalSupply: '12345' ?? null,
    symbol: 'SYM' ?? null,
    tokenType: NftTokenType.UNKNOWN,
    contractDeployer: '0xabcdef' ?? null,
    deployedBlockNumber: 42 ?? null,
    ...overrides
  };
}

export function verifyNftContractMetadata(
  actualNftContract: NftContract,
  expectedNftContract: NftContract,
  address: string,
  name: string,
  symbol: string,
  totalSupply: string,
  tokenType?: NftTokenType,
  openSea?: RawOpenSeaCollectionMetadata
) {
  expect(actualNftContract).toEqual(expectedNftContract);
  expect(actualNftContract.address).toEqual(address);
  expect(actualNftContract.name).toEqual(name);
  expect(actualNftContract.symbol).toEqual(symbol);
  expect(actualNftContract.totalSupply).toEqual(totalSupply);
  expect(actualNftContract.tokenType).toEqual(tokenType);

  if (openSea) {
    expect(actualNftContract.openSeaMetadata?.floorPrice).toEqual(
      openSea.floorPrice
    );
    expect(actualNftContract.openSeaMetadata?.collectionName).toEqual(
      openSea.collectionName
    );
    expect(actualNftContract.openSeaMetadata?.safelistRequestStatus).toEqual(
      openSea.safelistRequestStatus
    );
    expect(actualNftContract.openSeaMetadata?.imageUrl).toEqual(
      openSea.imageUrl
    );
    expect(actualNftContract.openSeaMetadata?.description).toEqual(
      openSea.description
    );
    expect(actualNftContract.openSeaMetadata?.externalUrl).toEqual(
      openSea.externalUrl
    );
    expect(actualNftContract.openSeaMetadata?.twitterUsername).toEqual(
      openSea.twitterUsername
    );
    expect(actualNftContract.openSeaMetadata?.discordUrl).toEqual(
      openSea.discordUrl
    );
    expect(actualNftContract.openSeaMetadata?.lastIngestedAt).toEqual(
      openSea.lastIngestedAt
    );
  }
}

export type Mocked<T> = T & {
  [K in keyof T]: T[K] extends Function ? T[K] & jest.Mock : T[K];
};

/** A Promise implementation for deferred resolution. */
export class Deferred<R> {
  promise: Promise<R>;

  constructor() {
    this.promise = new Promise<R>(
      (
        resolve: (value: R | Promise<R>) => void,
        reject: (reason: Error) => void
      ) => {
        this.resolve = resolve;
        this.reject = reject;
      }
    );
  }

  resolve: (value: R | Promise<R>) => void = () => {};
  reject: (reason: Error) => void = () => {};
}

export function makeNewHeadsEvent(
  blockNumber: number,
  hash: string
): BlockHead {
  return { hash, number: toHex(blockNumber) } as any;
}

export function makeLogsEvent(
  blockNumber: number,
  blockHash: string,
  isRemoved = false,
  logIndex = 1
): LogsEvent {
  return {
    blockHash,
    blockNumber: toHex(blockNumber),
    logIndex: toHex(logIndex),
    removed: isRemoved
  } as any;
}

export const TESTING_PRIVATE_KEY =
  'dd5bdf09397b1fdf98e4f72c66047d5104b1511fa7dc1b8fdddd61a150f732c9';
export const TESTING_PUBLIC_ADDRESS =
  '0x4b9007B0BcE78cfB634032ec31Ed56adB464287b';

export async function loadAlchemyEnv(): Promise<void> {
  const dotenv = await import('dotenv');
  dotenv.config({ path: 'alchemy.env' });
}


================================================================================
File: test\unit\alchemy.test.ts
Size: 3.45 kB
================================================================================

import { Alchemy, AlchemySettings, Network } from '../../src';
import {
  AlchemyApiType,
  DEFAULT_ALCHEMY_API_KEY,
  DEFAULT_MAX_RETRIES,
  DEFAULT_NETWORK
} from '../../src/util/const';

describe('Alchemy class', () => {
  describe('translates Network to ethers', () => {
    function testNetwork(network: Network) {
      it(`should return a valid provider for ${network}`, async () => {
        const alchemy = new Alchemy({
          network
        });
        await alchemy.config.getProvider();
      });
    }
    for (const network of Object.values(Network)) {
      testNetwork(network);
    }
  });

  it('preserves settings', () => {
    const config: AlchemySettings = {
      apiKey: 'api-key-here',
      network: Network.OPT_GOERLI,
      maxRetries: 2,
      url: 'invalid-url'
    };
    const alchemy = new Alchemy(config);
    config.apiKey = 'new-api-key';
    config.network = Network.OPT_MAINNET;
    config.maxRetries = 3;
    config.url = 'another-url';

    expect(alchemy.config.apiKey).toEqual('api-key-here');
    expect(alchemy.config.network).toEqual(Network.OPT_GOERLI);
    expect(alchemy.config.maxRetries).toEqual(2);
    expect(alchemy.config.url).toEqual('invalid-url');
  });

  it('initializes to default values', () => {
    const alchemy = new Alchemy();
    expect(alchemy.config.apiKey).toEqual(DEFAULT_ALCHEMY_API_KEY);
    expect(alchemy.config.network).toEqual(DEFAULT_NETWORK);
    expect(alchemy.config.maxRetries).toEqual(DEFAULT_MAX_RETRIES);
    expect(alchemy.config.url).toBeUndefined();
  });

  it('reuses the same provider', async () => {
    const alchemy = new Alchemy();
    const provider = await alchemy.config.getProvider();
    const provider2 = await alchemy.config.getProvider();
    expect(provider).toBe(provider2);

    const wsProvider = await alchemy.config.getWebSocketProvider();
    const wsProvider2 = await alchemy.config.getWebSocketProvider();
    expect(wsProvider).toBe(wsProvider2);
  });

  it('providers are loaded once', async () => {
    const alchemy = new Alchemy();
    const providerPromise = alchemy.config.getProvider();
    const provider2Promise = alchemy.config.getProvider();
    const provider = await providerPromise;
    const provider2 = await provider2Promise;
    expect(provider).toBe(provider2);

    const wsProviderPromise = alchemy.config.getWebSocketProvider();
    const wsProvider2Promise = alchemy.config.getWebSocketProvider();
    const wsProvider = await wsProviderPromise;
    const wsProvider2 = await wsProvider2Promise;
    expect(wsProvider).toBe(wsProvider2);
  });

  it('creates a request url based on the api type', () => {
    const alchemy = new Alchemy({
      network: Network.OPT_MAINNET,
      apiKey: 'demo-key'
    });

    expect(alchemy.config._getRequestUrl(AlchemyApiType.NFT)).toEqual(
      'https://opt-mainnet.g.alchemy.com/nft/v3/demo-key'
    );
    expect(alchemy.config._getRequestUrl(AlchemyApiType.BASE)).toEqual(
      'https://opt-mainnet.g.alchemy.com/v2/demo-key'
    );
  });

  it('uses the config url instead of apiKey/network if one was provided', () => {
    const alchemy = new Alchemy({
      apiKey: 'api-key-here',
      network: Network.OPT_GOERLI,
      url: 'custom-url'
    });
    expect(alchemy.config._getRequestUrl(AlchemyApiType.NFT)).toEqual(
      'custom-url'
    );
  });
});


================================================================================
File: test\unit\backoff.test.ts
Size: 1.87 kB
================================================================================

import { ExponentialBackoff } from '../../src/internal/backoff';

describe('Exponential Backoff', () => {
  const observedDelays: number[] = [];
  const noop = () => {};

  function assertDelayEquals(expected: number) {
    expect(observedDelays.shift()).toEqual(expected);
  }

  beforeAll(() => {
    jest.useFakeTimers();
    jest.spyOn(global, 'setTimeout').mockImplementation(
      // @ts-ignore: Mock implementation doesn't need to return a Timeout.
      (callback: () => void, timeout) => {
        if (timeout !== undefined) {
          observedDelays.push(timeout);
        }
        callback();
      }
    );
  });

  it('does not delay the first attempt', async () => {
    const backoff = new ExponentialBackoff();
    await backoff.backoff();
    assertDelayEquals(0);
  });

  it('stops backoff after max attempts reached', async () => {
    const maxAttempts = 3;
    const backoff = new ExponentialBackoff(maxAttempts);
    let numBackoffs = 0;
    try {
      for (let i = 0; i < maxAttempts + 1; i++) {
        await backoff.backoff();
        numBackoffs += 1;
      }
      fail('Should not exceed max attempts');
    } catch (e) {
      expect(numBackoffs).toEqual(3);
      expect((e as Error).message).toContain(
        'Exceeded maximum number of attempts'
      );
    }
  });

  it('cannot queue two backoff() operations simultaneously', async () => {
    const backoff = new ExponentialBackoff();

    // The timeout handler for this test simply idles forever.
    jest.spyOn(global, 'setTimeout').mockImplementation(
      // @ts-ignore: Mock implementation doesn't need to return a Timeout.
      () => {}
    );

    void backoff.backoff().then(noop);
    await expect(backoff.backoff()).rejects.toThrow(
      'A backoff operation is already in progress'
    );
  });
});


================================================================================
File: test\unit\contract.test.ts
Size: 1.47 kB
================================================================================

import { Contract, Wallet } from '../../src';
import {
  TEST_WALLET_PRIVATE_KEY,
  TEST_WALLET_PUBLIC_ADDRESS
} from '../test-util';

const contractAddress = '0x74a9a20f67d5499b62255bfa1dca195d06aa4617';

const abi = [
  {
    constant: true,
    inputs: [],
    name: 'name',
    outputs: [{ name: '', type: 'string' }],
    payable: false,
    stateMutability: 'view',
    type: 'function'
  },
  {
    constant: true,
    inputs: [],
    name: 'getValue',
    outputs: [{ name: '', type: 'string' }],
    payable: false,
    stateMutability: 'view',
    type: 'function'
  },
  {
    constant: false,
    inputs: [{ name: '_name', type: 'string' }],
    name: 'setValue',
    outputs: [{ name: '', type: 'string' }],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function'
  }
];

describe('Alchemy-Ethers Contract', () => {
  it('returns a signer', async () => {
    const wallet = new Wallet(TEST_WALLET_PRIVATE_KEY);
    const contract = new Contract(contractAddress, abi, wallet);
    const signer = contract.signer;
    const address = await signer.getAddress();
    expect(address).toEqual(TEST_WALLET_PUBLIC_ADDRESS);
  });

  it('has the expected address', async () => {
    const wallet = new Wallet(TEST_WALLET_PRIVATE_KEY);
    const contract = new Contract(contractAddress, abi, wallet);
    const address = contract.address;
    expect(address).toEqual(contractAddress);
  });
});


================================================================================
File: test\unit\core-namespace.test.ts
Size: 442 B
================================================================================

import { Alchemy } from '../../src';

describe('Core Namespace', () => {
  let alchemy: Alchemy;
  beforeEach(() => {
    alchemy = new Alchemy();
  });

  describe('getTokenBalances()', () => {
    it('validates inputs', async () => {
      const address = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045';
      await expect(() =>
        alchemy.core.getTokenBalances(address, [])
      ).rejects.toThrow();
    });
  });
});


================================================================================
File: test\unit\logger.test.ts
Size: 2.59 kB
================================================================================

import { setLogLevel } from '../../src';
import { logDebug, logError, logInfo, logWarn } from '../../src/util/logger';

describe('Logger', () => {
  const message = 'Important logging message';
  const mockConsoles = new Map();

  beforeEach(() => {
    mockConsoles.set(
      'debug',
      jest.spyOn(global.console, 'log').mockImplementation(() => {})
    );
    mockConsoles.set(
      'info',
      jest.spyOn(global.console, 'info').mockImplementation(() => {})
    );
    mockConsoles.set(
      'warn',
      jest.spyOn(global.console, 'warn').mockImplementation(() => {})
    );
    mockConsoles.set(
      'error',
      jest.spyOn(global.console, 'error').mockImplementation(() => {})
    );
  });

  afterEach(() => {
    mockConsoles.forEach(mockConsole => mockConsole.mockRestore());
  });

  function testLog(level: string, shouldLog: boolean): void {
    it(`Should ${
      shouldLog ? '' : 'not'
    } call \`console.${level}\` with LogLevel: '${level}'`, () => {
      switch (level) {
        case 'debug':
          logDebug(message);
          break;
        case 'info':
          logInfo(message);
          break;
        case 'warn':
          logWarn(message);
          break;
        case 'error':
          logError(message);
          break;
        default:
          throw new Error(`Unknown log level: ${level}`);
      }
      expect(mockConsoles.get(level)).toHaveBeenCalledTimes(shouldLog ? 1 : 0);
    });
  }

  describe('Debug', () => {
    beforeEach(() => {
      setLogLevel('debug');
    });
    testLog('debug', true);
    testLog('info', true);
    testLog('warn', true);
    testLog('error', true);
  });

  describe('Warn', () => {
    beforeEach(() => {
      setLogLevel('warn');
    });
    testLog('debug', false);
    testLog('info', false);
    testLog('warn', true);
    testLog('error', true);
  });

  describe('Info', () => {
    beforeEach(() => {
      setLogLevel('info');
    });
    testLog('debug', false);
    testLog('info', true);
    testLog('warn', true);
    testLog('error', true);
  });

  describe('Error', () => {
    beforeEach(() => {
      setLogLevel('error');
    });
    testLog('debug', false);
    testLog('info', false);
    testLog('warn', false);
    testLog('error', true);
  });

  describe('Silent', () => {
    beforeEach(() => {
      setLogLevel('silent');
    });
    testLog('debug', false);
    testLog('info', false);
    testLog('warn', false);
    testLog('error', false);
  });
});


================================================================================
File: test\unit\nft-api.test.ts
Size: 61.78 kB
================================================================================

import axios from 'axios';
import MockAdapter from 'axios-mock-adapter';

import {
  Alchemy,
  AssetTransfersCategory,
  AssetTransfersResult,
  BaseNft,
  GetContractsForOwnerOptions,
  GetFloorPriceResponse,
  GetNftSalesOptions,
  GetNftsForOwnerOptions,
  GetOwnersForContractWithTokenBalancesResponse,
  Nft,
  NftAttributesResponse,
  NftContractBaseNftsResponse,
  NftContractNftsResponse,
  NftFilters,
  NftMetadataBatchToken,
  NftOrdering,
  NftRefreshState,
  NftSaleMarketplace,
  NftSaleTakerType,
  NftSpamClassification,
  NftTokenType,
  OpenSeaSafelistRequestStatus,
  OwnedBaseNft,
  OwnedBaseNftsResponse,
  OwnedNft,
  OwnedNftsResponse,
  SortingOrder,
  fromHex,
  toHex
} from '../../src';
import { AlchemyConfig } from '../../src/api/alchemy-config';
import { getNftsForTransfers } from '../../src/internal/nft-api';
import {
  RawGetBaseNftsForContractResponse,
  RawGetBaseNftsResponse,
  RawGetContractsForOwnerResponse,
  RawGetNftSalesResponse,
  RawGetNftsForContractResponse,
  RawGetNftsForOwnerResponse,
  RawGetOwnersForContractWithTokenBalancesResponse,
  RawNftAttributeRarity,
  RawNftImage
} from '../../src/internal/raw-interfaces';
import { getNftContractFromRaw, getNftFromRaw } from '../../src/util/util';
import {
  createBaseNft,
  createNft,
  createOwnedBaseNft,
  createOwnedNft,
  createRawContractForOwner,
  createRawNft,
  createRawNftContract,
  createRawNftSale,
  createRawOpenSeaCollectionMetadata,
  createRawOwnedBaseNft,
  createRawOwnedNft,
  verifyNftContractMetadata
} from '../test-util';

describe('NFT module', () => {
  let alchemy: Alchemy;
  let mock: MockAdapter;

  beforeAll(async () => {
    alchemy = new Alchemy();
    mock = new MockAdapter(axios);

    // Skip all timeouts for testing.
    jest.useFakeTimers();
    jest.spyOn(global, 'setTimeout').mockImplementation((f: any) => f());
  });

  afterEach(() => {
    mock.reset();
  });

  describe('getNftContractMetadata()', () => {
    const address = '0xABC';
    const name = 'NFT Contract Name';
    const symbol = 'NCN';
    const totalSupply = '9999';
    const tokenType = NftTokenType.ERC721;
    const contractDeployer = '0xDEF';
    const deployedBlockNumber = 424242;
    const openSeaMetadata = createRawOpenSeaCollectionMetadata();

    const rawNftContractResponse = {
      address,
      tokenType,
      name,
      symbol,
      totalSupply,
      openSeaMetadata,
      contractDeployer,
      deployedBlockNumber
    };
    const expectedNftContract = getNftContractFromRaw(rawNftContractResponse);

    beforeEach(() => {
      mock.onGet().reply(200, rawNftContractResponse);
    });

    it('returns the api response in the expected format', async () => {
      verifyNftContractMetadata(
        await alchemy.nft.getContractMetadata(address),
        expectedNftContract,
        address,
        name,
        symbol,
        totalSupply,
        tokenType
      );

      expect(mock.history.get.length).toEqual(1);
      expect(mock.history.get[0].params).toHaveProperty(
        'contractAddress',
        address
      );
    });

    it('surfaces errors', async () => {
      mock.reset();
      mock.onGet().reply(500, 'Internal Server Error');
      await expect(alchemy.nft.getContractMetadata(address)).rejects.toThrow(
        'Internal Server Error'
      );
    });
  });

  describe('getNftMetadata()', () => {
    const contractAddress = '0xABC';
    const title = 'NFT Title';
    const tokenId = '42';
    const timeoutInMs = 50;
    const contract = {
      address: contractAddress,
      name: 'NFT Title',
      symbol: 'NCN',
      totalSupply: '9999',
      tokenType: NftTokenType.ERC721,
      contractDeployer: '0xDEF',
      deployedBlockNumber: 424242,
      openSeaMetadata: createRawOpenSeaCollectionMetadata(),
      isSpam: false,
      spamClassifications: [NftSpamClassification.Erc721DishonestTotalSupply]
    };
    // Special case token ID as an integer string, since that's what the NFT
    // API endpoint returns.
    const rawNftResponse = createRawNft(
      contractAddress,
      title,
      tokenId.toString(),
      NftTokenType.UNKNOWN,
      { contract }
    );
    const expectedNft = getNftFromRaw(rawNftResponse);

    beforeEach(() => {
      mock.onGet().reply(200, rawNftResponse);
    });

    function verifyNftMetadata(
      actualNft: Nft,
      expectedNft: Nft,
      contractAddress: string,
      tokenId: string,
      tokenType?: NftTokenType,
      timeoutInMs?: number,
      refreshCache?: boolean
    ) {
      expect(actualNft).toEqual(expectedNft);
      expect(actualNft.tokenId).toEqual(tokenId);
      expect(mock.history.get.length).toEqual(1);
      expect(mock.history.get[0].params).toHaveProperty(
        'contractAddress',
        contractAddress
      );
      expect(mock.history.get[0].params).toHaveProperty('tokenId', tokenId);
      expect(mock.history.get[0].params).toHaveProperty(
        'tokenType',
        tokenType ?? undefined
      );
      expect(mock.history.get[0].params).toHaveProperty(
        'tokenUriTimeoutInMs',
        timeoutInMs ?? undefined
      );
      expect(mock.history.get[0].params).toHaveProperty(
        'refreshCache',
        refreshCache ?? undefined
      );
    }

    it('can be called with raw parameters', async () => {
      verifyNftMetadata(
        await alchemy.nft.getNftMetadata(contractAddress, tokenId, {
          tokenType: NftTokenType.ERC1155,
          tokenUriTimeoutInMs: timeoutInMs,
          refreshCache: true
        }),
        expectedNft,
        contractAddress,
        tokenId,
        NftTokenType.ERC1155,
        timeoutInMs,
        true
      );
    });

    it('normalizes tokenId as a hex string', async () => {
      verifyNftMetadata(
        await alchemy.nft.getNftMetadata(contractAddress, tokenId, {
          tokenType: NftTokenType.ERC1155
        }),
        expectedNft,
        contractAddress,
        tokenId,
        NftTokenType.ERC1155
      );
    });

    it('sets tokenType to undefined if tokenType is UNKNOWN', async () => {
      verifyNftMetadata(
        await alchemy.nft.getNftMetadata(contractAddress, tokenId, {
          tokenType: NftTokenType.UNKNOWN
        }),
        expectedNft,
        contractAddress,
        tokenId
      );
    });

    it('sets tokenType to undefined if tokenType is NOT_A_CONTRACT', async () => {
      verifyNftMetadata(
        await alchemy.nft.getNftMetadata(contractAddress, tokenId, {
          tokenType: NftTokenType.NOT_A_CONTRACT
        }),
        expectedNft,
        contractAddress,
        tokenId
      );
    });

    it('surfaces errors', async () => {
      mock.reset();
      mock.onGet().reply(500, 'Internal Server Error');
      await expect(
        alchemy.nft.getNftMetadata(contractAddress, tokenId)
      ).rejects.toThrow('Internal Server Error');
    });
  });

  describe('getNftMetadataBatch()', () => {
    const contractAddress = '0xABC';
    const contractAddress2 = '0xDEF';
    const title = 'NFT Title';
    const tokenId = '42';
    const tokenId2 = 43;
    const timeoutInMs = 50;
    // Special case token ID as an integer string, since that's what the NFT
    // API endpoint returns.
    const rawNftsResponse = {
      nfts: [
        createRawNft(contractAddress, title, tokenId),
        createRawNft(contractAddress2, title, tokenId2.toString())
      ]
    };
    const expectedNfts = rawNftsResponse.nfts.map(getNftFromRaw);

    beforeEach(() => {
      mock.onPost().reply(200, rawNftsResponse);
    });

    it('can be called with raw parameters', async () => {
      const tokens: NftMetadataBatchToken[] = [
        { contractAddress, tokenId },
        {
          contractAddress: contractAddress2,
          tokenId: tokenId2,
          tokenType: NftTokenType.ERC1155
        }
      ];
      const response = await alchemy.nft.getNftMetadataBatch(tokens, {
        refreshCache: true,
        tokenUriTimeoutInMs: timeoutInMs
      });
      expect(response.nfts).toEqual(expectedNfts);
      expect(mock.history.post.length).toEqual(1);
      const parsedRequest = JSON.parse(mock.history.post[0].data);
      expect(parsedRequest).toHaveProperty('tokens', tokens);
      expect(parsedRequest).toHaveProperty('tokens', tokens);
      expect(parsedRequest).toHaveProperty('refreshCache', true);
    });

    it('surfaces errors', async () => {
      mock.reset();
      mock.onGet().reply(500, 'Internal Server Error');
      await expect(
        alchemy.nft.getNftMetadata(contractAddress, tokenId)
      ).rejects.toThrow('Internal Server Error');
    });
  });

  describe('getNftsForOwner()', () => {
    const ownerAddress = '0xABC';
    const pageKey = 'page-key0';
    const contractAddresses = ['0xCA1', '0xCA2'];
    const excludeFilters = [NftFilters.SPAM];
    const expectedFilters = ['SPAM'];
    const getNftsParams: GetNftsForOwnerOptions = {
      pageKey,
      contractAddresses,
      excludeFilters,
      pageSize: 3,
      tokenUriTimeoutInMs: 50,
      orderBy: NftOrdering.TRANSFERTIME
    };
    const rawValidAt = {
      blockHash: '0x123abc',
      blockNumber: 123,
      blockTimestamp: null
    };
    const baseNftResponse: RawGetBaseNftsResponse = {
      ownedNfts: [
        createRawOwnedBaseNft('0xCA1', '0x1', '1'),
        createRawOwnedBaseNft('0xCA2', '0x2', '2')
      ],
      pageKey: 'page-key1',
      totalCount: 3,
      validAt: rawValidAt
    };

    const nftResponse: RawGetNftsForOwnerResponse = {
      ownedNfts: [
        createRawOwnedNft('a', '0xCA1', '0x1', '1'),
        createRawOwnedNft('b', '0xCA2', '0x2', '2', NftTokenType.ERC1155)
      ],
      pageKey: 'page-key1',
      totalCount: 3,
      validAt: rawValidAt
    };

    const paramCases = [
      [true, false],
      [false, true],
      [undefined, true]
    ];
    it.each(paramCases)(
      'called with the correct parameters',
      async (omitMetadata, expectedWithMetadata) => {
        mock.onGet().reply(200, nftResponse);
        await alchemy.nft.getNftsForOwner(ownerAddress, {
          ...getNftsParams,
          omitMetadata
        });
        expect(mock.history.get.length).toEqual(1);
        expect(mock.history.get[0].params).toHaveProperty(
          'owner',
          ownerAddress
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'contractAddresses',
          contractAddresses
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'excludeFilters',
          expectedFilters
        );
        expect(mock.history.get[0].params).toHaveProperty('pageKey', pageKey);
        expect(mock.history.get[0].params).toHaveProperty('pageSize', 3);
        expect(mock.history.get[0].params).toHaveProperty(
          'withMetadata',
          expectedWithMetadata
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'tokenUriTimeoutInMs',
          50
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'orderBy',
          'TRANSFERTIME'
        );
      }
    );

    const baseExpected: OwnedBaseNftsResponse = {
      ownedNfts: [
        createOwnedBaseNft('0xCA1', '0x1', '1'),
        createOwnedBaseNft('0xCA2', '0x2', '2')
      ],
      pageKey: 'page-key1',
      totalCount: 3,
      validAt: {
        blockHash: '0x123abc',
        blockNumber: 123,
        blockTimestamp: undefined
      }
    };
    const nftExpected: OwnedNftsResponse = {
      ownedNfts: [
        createOwnedNft('a', '0xCA1', '0x1', '1'),
        createOwnedNft('b', '0xCA2', '0x2', '2', NftTokenType.ERC1155)
      ],
      pageKey: 'page-key1',
      totalCount: 3,
      validAt: {
        blockHash: '0x123abc',
        blockNumber: 123,
        blockTimestamp: undefined
      }
    };
    const responseCases: Array<
      [
        boolean,
        RawGetBaseNftsResponse | RawGetNftsForOwnerResponse,
        OwnedBaseNftsResponse | OwnedNftsResponse
      ]
    > = [
      [true, baseNftResponse, baseExpected],
      [false, nftResponse, nftExpected]
    ];
    it.each(responseCases)(
      'normalizes fields in response',
      async (omitMetadata, rawResponse, expected) => {
        mock.onGet().reply(200, rawResponse);
        const response = await alchemy.nft.getNftsForOwner(ownerAddress, {
          ...getNftsParams,
          omitMetadata
        });
        expect(response).toEqual(expected);
      }
    );

    it.each(responseCases)('surfaces errors', async omitMetadata => {
      mock.reset();
      mock.onGet().reply(500, 'Internal Server Error');
      await expect(
        alchemy.nft.getNftsForOwner(ownerAddress, {
          ...getNftsParams,
          omitMetadata
        })
      ).rejects.toThrow('Internal Server Error');
    });

    it('uses the correct overload with no options', async () => {
      mock.onGet().reply(200, nftResponse);
      const response = await alchemy.nft.getNftsForOwner(ownerAddress);
      response.ownedNfts.forEach(nft => expect(nft.contract).toBeDefined());
    });
  });

  describe('getNftsForOwnerIterator()', () => {
    const ownerAddress = '0xABC';
    const contractAddresses = ['0xCA1', '0xCA2'];
    const excludeFilters = [NftFilters.SPAM];
    const expectedFilters = ['SPAM'];
    const rawValidAt = {
      blockHash: '0x123abc',
      blockNumber: 123,
      blockTimestamp: null
    };
    const baseResponses: RawGetBaseNftsResponse[] = [
      {
        ownedNfts: [
          createRawOwnedBaseNft('0xCA1', '0x1', '1'),
          createRawOwnedBaseNft('0xCA2', '0x2', '2')
        ],
        pageKey: 'page-key1',
        totalCount: 3,
        validAt: rawValidAt
      },
      {
        ownedNfts: [createRawOwnedBaseNft('0xCA2', '0x3', '1')],
        totalCount: 3,
        validAt: rawValidAt,
        pageKey: null
      }
    ];
    const nftResponses: RawGetNftsForOwnerResponse[] = [
      {
        ownedNfts: [
          createRawOwnedNft('a', '0xCA1', '0x1', '1'),
          createRawOwnedNft('b', '0xCA2', '0x2', '2', NftTokenType.ERC1155)
        ],
        pageKey: 'page-key1',
        totalCount: 3,
        validAt: rawValidAt
      },
      {
        ownedNfts: [
          createRawOwnedNft('c', '0xCA2', '0x3', '1', NftTokenType.ERC1155)
        ],
        totalCount: 3,
        validAt: rawValidAt,
        pageKey: null
      }
    ];

    function setupMock(
      mockResponses: RawGetBaseNftsResponse[] | RawGetNftsForOwnerResponse[]
    ): void {
      mock
        .onGet()
        .replyOnce(200, mockResponses[0])
        .onGet()
        .replyOnce(200, mockResponses[1]);
    }

    const paramCases: Array<
      [
        RawGetBaseNftsResponse[] | RawGetNftsForOwnerResponse[],
        boolean | undefined,
        boolean
      ]
    > = [
      [baseResponses, true, false],
      [nftResponses, false, true],
      [nftResponses, undefined, true]
    ];
    it.each(paramCases)(
      'traverses all page keys and uses correct parameters',
      async (mockResponses, omitMetadata, expectedWithMetadata) => {
        setupMock(mockResponses);
        const ownedNfts = [];
        for await (const ownedNft of alchemy.nft.getNftsForOwnerIterator(
          ownerAddress,
          {
            excludeFilters,
            contractAddresses,
            omitMetadata
          }
        )) {
          ownedNfts.push(ownedNft);
        }

        expect(mock.history.get.length).toEqual(2);
        expect(mock.history.get[0].params).toHaveProperty('pageKey', undefined);
        expect(mock.history.get[0].params).toHaveProperty(
          'owner',
          ownerAddress
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'contractAddresses',
          contractAddresses
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'withMetadata',
          expectedWithMetadata
        );
        expect(mock.history.get[0].params).toHaveProperty(
          'excludeFilters',
          expectedFilters
        );
        expect(mock.history.get[1].params).toHaveProperty(
          'pageKey',
          'page-key1'
        );
        expect(mock.history.get[1].params).toHaveProperty(
          'owner',
          ownerAddress
        );