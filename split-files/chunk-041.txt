
  const response = await requestHttpWithBackoff<
    GetCollectionMetadataParams,
    RawNftCollection
  >(config, AlchemyApiType.NFT, 'getCollectionMetadata', srcMethod, {
    collectionSlug
  });

  return getNftCollectionFromRaw(response);
}

export async function* getNftsForOwnerIterator(
  config: AlchemyConfig,
  owner: string,
  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions,
  srcMethod = 'getNftsForOwnerIterator'
): AsyncIterable<OwnedBaseNft | OwnedNft> {
  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);
  for await (const response of paginateEndpoint(
    config,
    AlchemyApiType.NFT,
    'getNFTsForOwner',
    srcMethod,
    'pageKey',
    'pageKey',
    {
      contractAddresses: options?.contractAddresses,
      pageKey: options?.pageKey,
      excludeFilters: options?.excludeFilters,
      includeFilters: options?.includeFilters,
      owner,
      withMetadata,
      tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,
      orderBy: options?.orderBy
    }
  )) {
    for (const ownedNft of response.ownedNfts as
      | RawOwnedNft[]
      | RawOwnedBaseNft[]) {
      yield {
        ...nftFromGetNftResponse(ownedNft),
        balance: ownedNft.balance
      };
    }
  }
}

export async function getNftsForOwner(
  config: AlchemyConfig,
  owner: string,
  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions,
  srcMethod = 'getNftsForOwner'
): Promise<OwnedNftsResponse | OwnedBaseNftsResponse> {
  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);
  const response = await requestHttpWithBackoff<
    GetNftsAlchemyParams,
    RawGetBaseNftsResponse | RawGetNftsForOwnerResponse
  >(config, AlchemyApiType.NFT, 'getNFTsForOwner', srcMethod, {
    contractAddresses: options?.contractAddresses,
    pageKey: options?.pageKey,
    excludeFilters: options?.excludeFilters,
    includeFilters: options?.includeFilters,
    owner,
    pageSize: options?.pageSize,
    withMetadata,
    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,
    orderBy: options?.orderBy
  });
  if (withMetadata) {
    return nullsToUndefined<OwnedNftsResponse>({
      ownedNfts: response.ownedNfts.map(res => ({
        ...getNftFromRaw(res as RawOwnedNft),
        balance: res.balance
      })),
      pageKey: response.pageKey,
      totalCount: response.totalCount,
      validAt: response.validAt
    });
  }

  return nullsToUndefined<OwnedBaseNftsResponse>({
    ownedNfts: response.ownedNfts.map(res => ({
      ...getBaseNftFromRaw(res as RawOwnedBaseNft),
      balance: res.balance
    })),
    pageKey: response.pageKey,
    totalCount: response.totalCount,
    validAt: response.validAt
  });
}

export async function getNftsForContract(
  config: AlchemyConfig,
  contractAddress: string,
  options?: GetBaseNftsForContractOptions | GetNftsForContractOptions,
  srcMethod = 'getNftsForContract'
): Promise<NftContractNftsResponse | NftContractBaseNftsResponse> {
  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);
  const response = await requestHttpWithBackoff<
    GetNftsForContractAlchemyParams,
    RawGetBaseNftsForContractResponse | RawGetNftsForContractResponse
  >(config, AlchemyApiType.NFT, 'getNFTsForContract', srcMethod, {
    contractAddress,
    pageKey: options?.pageKey,
    withMetadata,
    limit: options?.pageSize ?? undefined,
    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs
  });

  if (withMetadata) {
    return nullsToUndefined<NftContractNftsResponse>({
      nfts: response.nfts.map(res => getNftFromRaw(res as RawNft)),
      pageKey: response.pageKey
    });
  }

  return nullsToUndefined<NftContractBaseNftsResponse>({
    nfts: response.nfts.map(res =>
      getBaseNftFromRaw(res as RawContractBaseNft, contractAddress)
    ),
    pageKey: response.pageKey
  });
}

export async function* getNftsForContractIterator(
  config: AlchemyConfig,
  contractAddress: string,
  options?: GetBaseNftsForContractOptions | GetNftsForContractOptions,
  srcMethod = 'getNftsForContractIterator'
): AsyncIterable<BaseNft | Nft> {
  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);
  for await (const response of paginateEndpoint(
    config,
    AlchemyApiType.NFT,
    'getNFTsForContract',
    srcMethod,
    'pageKey',
    'pageKey',
    {
      contractAddress,
      pageKey: options?.pageKey,
      withMetadata
    }
  )) {
    for (const nft of response.nfts as RawContractBaseNft[] | RawNft[]) {
      yield nftFromGetNftContractResponse(nft, contractAddress);
    }
  }
}

export async function getOwnersForContract(
  config: AlchemyConfig,
  contractAddress: string,
  options?:
    | GetOwnersForContractWithTokenBalancesOptions
    | GetOwnersForContractOptions,
  srcMethod = 'getOwnersForContract'
): Promise<
  GetOwnersForContractResponse | GetOwnersForContractWithTokenBalancesResponse
> {
  // Cast to `any` to avoid more type wrangling.
  const response = await requestHttpWithBackoff<
    GetOwnersForNftContractAlchemyParams,
    | RawGetOwnersForContractResponse
    | RawGetOwnersForContractWithTokenBalancesResponse
  >(config, AlchemyApiType.NFT, 'getOwnersForContract', srcMethod, {
    ...options,
    contractAddress
  });

  if (options?.withTokenBalances) {
    return nullsToUndefined<GetOwnersForContractWithTokenBalancesResponse>({
      owners: (response as RawGetOwnersForContractWithTokenBalancesResponse)
        .owners,
      pageKey: response.pageKey
    });
  }
  return nullsToUndefined<GetOwnersForContractResponse>({
    owners: response.owners as string[],
    pageKey: response.pageKey
  });
}

export async function getContractsForOwner(
  config: AlchemyConfig,
  owner: string,
  options?: GetContractsForOwnerOptions,
  srcMethod = 'getContractsForOwner'
): Promise<GetContractsForOwnerResponse> {
  const response = await requestHttpWithBackoff<
    GetContractsForOwnerParams,
    RawGetContractsForOwnerResponse
  >(config, AlchemyApiType.NFT, 'getContractsForOwner', srcMethod, {
    owner,
    excludeFilters: options?.excludeFilters,
    includeFilters: options?.includeFilters,
    pageKey: options?.pageKey,
    pageSize: options?.pageSize,
    orderBy: options?.orderBy
  });

  return nullsToUndefined<GetContractsForOwnerResponse>({
    contracts: response.contracts.map(getNftContractsForOwnerFromRaw),
    pageKey: response.pageKey,
    totalCount: response.totalCount
  });
}

export async function getOwnersForNft(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: BigNumberish,
  options?: GetOwnersForContractOptions,
  srcMethod = 'getOwnersForNft'
): Promise<GetOwnersForNftResponse> {
  return requestHttpWithBackoff(
    config,
    AlchemyApiType.NFT,
    'getOwnersForNFT',
    srcMethod,
    {
      contractAddress,
      tokenId: BigNumber.from(tokenId!).toString(),
      ...options
    }
  );
}

export async function getMintedNfts(
  config: AlchemyConfig,
  owner: string,
  options?: GetMintedNftsOptions
): Promise<TransfersNftResponse> {
  const provider = await config.getProvider();
  const ownerAddress = await provider._getAddress(owner);
  const category = nftTokenTypeToCategory(options?.tokenType);
  const params: AssetTransfersParams = {
    fromBlock: '0x0',
    fromAddress: ETH_NULL_ADDRESS,
    toAddress: ownerAddress,
    excludeZeroValue: true,
    contractAddresses: options?.contractAddresses,
    category,
    maxCount: 100,
    pageKey: options?.pageKey
  };
  const response = await getAssetTransfers(config, params, 'getMintedNfts');
  return getNftsForTransfers(config, response);
}

export async function getTransfersForOwner(
  config: AlchemyConfig,
  owner: string,
  transferType: GetTransfersForOwnerTransferType,
  options?: GetTransfersForOwnerOptions
): Promise<TransfersNftResponse> {
  const provider = await config.getProvider();
  const ownerAddress = await provider._getAddress(owner);
  const category = nftTokenTypeToCategory(options?.tokenType);
  const params: AssetTransfersParams = {
    fromBlock: '0x0',
    excludeZeroValue: true,
    contractAddresses: options?.contractAddresses,
    category,
    maxCount: 100,
    pageKey: options?.pageKey
  };

  if (transferType === GetTransfersForOwnerTransferType.TO) {
    params.toAddress = ownerAddress;
  } else {
    params.fromAddress = ownerAddress;
  }
  const transfersResponse = await getAssetTransfers(
    config,
    params,
    'getTransfersForOwner'
  );

  return getNftsForTransfers(config, transfersResponse);
}

export async function getTransfersForContract(
  config: AlchemyConfig,
  contract: string,
  options?: GetTransfersForContractOptions
): Promise<TransfersNftResponse> {
  const category = [
    AssetTransfersCategory.ERC721,
    AssetTransfersCategory.ERC1155,
    AssetTransfersCategory.SPECIALNFT
  ];
  const provider = await config.getProvider();
  const fromBlock = options?.fromBlock
    ? provider.formatter.blockTag(
        await provider._getBlockTag(options.fromBlock)
      )
    : '0x0';
  const toBlock = options?.toBlock
    ? provider.formatter.blockTag(await provider._getBlockTag(options.toBlock))
    : undefined;
  const params: AssetTransfersParams = {
    fromBlock,
    toBlock,
    excludeZeroValue: true,
    contractAddresses: [contract],
    order: options?.order,
    category,
    maxCount: 100,
    pageKey: options?.pageKey
  };

  const transfersResponse = await getAssetTransfers(
    config,
    params,
    'getTransfersForContract'
  );

  return getNftsForTransfers(config, transfersResponse);
}

function nftTokenTypeToCategory(
  tokenType: NftTokenType | undefined
): AssetTransfersCategory[] {
  switch (tokenType) {
    case NftTokenType.ERC721:
      return [AssetTransfersCategory.ERC721];
    case NftTokenType.ERC1155:
      return [AssetTransfersCategory.ERC1155];
    default:
      return [
        AssetTransfersCategory.ERC721,
        AssetTransfersCategory.ERC1155,
        AssetTransfersCategory.SPECIALNFT
      ];
  }
}

function parse1155Transfer(
  transfer: AssetTransfersResult
): NftMetadataBatchToken[] {
  return transfer.erc1155Metadata!.map(metadata => ({
    contractAddress: transfer.rawContract.address!,
    tokenId: metadata.tokenId,
    tokenType: NftTokenType.ERC1155
  }));
}

export async function verifyNftOwnership(
  config: AlchemyConfig,
  owner: string,
  contractAddresses: string | string[],
  srcMethod = 'verifyNftOwnership'
): Promise<boolean | { [contractAddress: string]: boolean }> {
  if (typeof contractAddresses === 'string') {
    const response = await getNftsForOwner(
      config,
      owner,
      {
        contractAddresses: [contractAddresses],
        omitMetadata: true
      },
      srcMethod
    );
    return response.ownedNfts.length > 0;
  } else {
    if (contractAddresses.length === 0) {
      throw new Error('Must provide at least one contract address');
    }
    const response = await getNftsForOwner(
      config,
      owner,
      {
        contractAddresses,
        omitMetadata: true
      },
      srcMethod
    );

    // Create map where all input contract addresses are set to false, then flip
    // owned nfts to true.
    const result = contractAddresses.reduce(
      (acc: { [contractAddress: string]: boolean }, curr) => {
        acc[curr] = false;
        return acc;
      },
      {}
    );
    for (const nft of response.ownedNfts) {
      result[(nft as OwnedBaseNft).contractAddress] = true;
    }
    return result;
  }
}

export async function isSpamContract(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'isSpamContract'
): Promise<IsSpamContractResponse> {
  return requestHttpWithBackoff<
    IsSpamContractParams,
    RawIsSpamContractResponse
  >(config, AlchemyApiType.NFT, 'isSpamContract', srcMethod, {
    contractAddress
  });
}

export async function getSpamContracts(
  config: AlchemyConfig,
  srcMethod = 'getSpamContracts'
): Promise<GetSpamContractsResponse> {
  return requestHttpWithBackoff<undefined, RawGetSpamContractsResponse>(
    config,
    AlchemyApiType.NFT,
    'getSpamContracts',
    srcMethod,
    undefined
  );
}

export async function reportSpam(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'reportSpam'
): Promise<void> {
  void requestHttpWithBackoff<ReportSpamParams, void>(
    config,
    AlchemyApiType.NFT,
    'reportSpam',
    srcMethod,
    {
      contractAddress
    }
  );
}

export async function isAirdropNft(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: string,
  srcMethod = 'isAirdropNft'
): Promise<IsAirdropNftResponse> {
  return requestHttpWithBackoff<isAirdropNftParams, RawIsAirdropNftResponse>(
    config,
    AlchemyApiType.NFT,
    'isAirdropNFT',
    srcMethod,
    {
      contractAddress,
      tokenId
    }
  );
}

export async function getFloorPrice(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'getFloorPrice'
): Promise<GetFloorPriceResponse> {
  const response = await requestHttpWithBackoff<
    GetFloorPriceParams,
    RawGetFloorPriceResponse
  >(config, AlchemyApiType.NFT, 'getFloorPrice', srcMethod, {
    contractAddress
  });
  return nullsToUndefined<GetFloorPriceResponse>(response);
}

export async function getNftSales(
  config: AlchemyConfig,
  options: GetNftSalesOptions | GetNftSalesOptionsByContractAddress = {},
  srcMethod = 'getNftSales'
): Promise<GetNftSalesResponse> {
  // Avoid ts compiler complaining about the contractAddress field.
  const params: Partial<GetNftSalesOptionsByContractAddress> = {
    ...options
  };

  const response = await requestHttpWithBackoff<
    GetNftSalesParams,
    RawGetNftSalesResponse
  >(config, AlchemyApiType.NFT, 'getNFTSales', srcMethod, {
    fromBlock: params?.fromBlock,
    toBlock: params?.toBlock,
    order: params?.order,
    marketplace: params?.marketplace,
    contractAddress: params?.contractAddress,
    tokenId: params?.tokenId
      ? BigNumber.from(params?.tokenId).toString()
      : undefined,
    sellerAddress: params?.sellerAddress,
    buyerAddress: params?.buyerAddress,
    taker: params?.taker,
    limit: params?.limit,
    pageKey: params?.pageKey
  });

  return getNftSalesFromRaw(response);
}

export async function computeRarity(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: BigNumberish,
  srcMethod = 'computeRarity'
): Promise<ComputeRarityResponse> {
  const response = await requestHttpWithBackoff<
    ComputeRarityParams,
    RawComputeRarityResponse
  >(config, AlchemyApiType.NFT, 'computeRarity', srcMethod, {
    contractAddress,
    tokenId: BigNumber.from(tokenId).toString()
  });

  return nullsToUndefined(response);
}

export async function searchContractMetadata(
  config: AlchemyConfig,
  query: string,
  srcMethod = 'searchContractMetadata'
): Promise<SearchContractMetadataResponse> {
  const response = await requestHttpWithBackoff<
    SearchContractMetadataParams,
    RawSearchContractMetadataResponse
  >(config, AlchemyApiType.NFT, 'searchContractMetadata', srcMethod, {
    query
  });

  return {
    contracts: response.contracts.map(getNftContractFromRaw)
  };
}

export async function summarizeNftAttributes(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'summarizeNftAttributes'
): Promise<NftAttributesResponse> {
  return requestHttpWithBackoff<
    SummarizeNftAttributesParams,
    RawNftAttributesResponse
  >(config, AlchemyApiType.NFT, 'summarizeNFTAttributes', srcMethod, {
    contractAddress
  });
}

export async function refreshNftMetadata(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: BigNumberish,
  srcMethod = 'refreshNftMetadata'
): Promise<boolean> {
  const tokenIdString = BigNumber.from(tokenId!).toString();
  const first = await getNftMetadata(
    config,
    contractAddress,
    tokenIdString,
    undefined,
    srcMethod
  );
  const second = await refresh(
    config,
    contractAddress,
    tokenIdString,
    srcMethod
  );
  return first.timeLastUpdated !== second.timeLastUpdated;
}

export async function refreshContract(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'refreshContract'
): Promise<RefreshContractResult> {
  const response = await requestHttpWithBackoff<
    ReingestContractParams,
    RawReingestContractResponse
  >(config, AlchemyApiType.NFT, 'reingestContract', srcMethod, {
    contractAddress
  });

  return {
    contractAddress: response.contractAddress,
    refreshState: parseReingestionState(response.reingestionState),
    progress: response.progress
  };
}

async function refresh(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: BigNumberish,
  srcMethod: string
): Promise<Nft> {
  const response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(
    config,
    AlchemyApiType.NFT,
    'getNFTMetadata',
    srcMethod,
    {
      contractAddress,
      tokenId: BigNumber.from(tokenId!).toString(),
      refreshCache: true
    }
  );
  return getNftFromRaw(response);
}

/**
 * Helper method to convert a NFT response received from Alchemy backend to an
 * SDK NFT type.
 *
 * @internal
 */
function nftFromGetNftResponse(
  ownedNft: RawOwnedBaseNft | RawOwnedNft
): Nft | BaseNft {
  if (isNftWithMetadata(ownedNft)) {
    return getNftFromRaw(ownedNft);
  } else {
    return getBaseNftFromRaw(ownedNft);
  }
}

/**
 * Helper method to convert a NFT response received from Alchemy backend to an
 * SDK NFT type.
 *
 * @internal
 */
function nftFromGetNftContractResponse(
  ownedNft: RawContractBaseNft | RawNft,
  contractAddress: string
): Nft | BaseNft {
  if (isNftWithMetadata(ownedNft)) {
    return getNftFromRaw(ownedNft);
  } else {
    return getBaseNftFromRaw(ownedNft, contractAddress);
  }
}

/** @internal */
// TODO: more comprehensive type check
function isNftWithMetadata(
  response: RawContractBaseNft | RawNft
): response is RawNft {
  return (response as RawNft).name !== undefined;
}

/**
 * Given an AssetTransfersResponse, fetches the NFTs associated with the
 * transfers and collates them with transfer metadata.
 *
 * VISIBLE FOR TESTING
 */
export async function getNftsForTransfers(
  config: AlchemyConfig,
  response: AssetTransfersResponse
): Promise<TransfersNftResponse> {
  const metadataTransfers = response.transfers
    .filter(transfer => transfer.rawContract.address !== null)
    // Use flatMap to flatten 1155 transfers that contain multiple NFTs.
    .flatMap(transfer => {
      const tokens = getTokensFromTransfer(transfer);

      const metadata = {
        from: transfer.from,
        to: transfer.to ?? undefined,
        transactionHash: transfer.hash,
        blockNumber: transfer.blockNum
      };
      return tokens.map(token => ({ metadata, token }));
    });

  if (metadataTransfers.length === 0) {
    return { nfts: [] };
  }

  // If we have more than 100 elements after unrolling 1155 transfers, split
  // transfers into batches of 100 to stay under endpoint batch size limit.
  const batchSize = 100;
  const requestBatches = [];
  for (let i = 0; i < metadataTransfers.length; i += batchSize) {
    requestBatches.push(metadataTransfers.slice(i, i + batchSize));
  }
  const responseBatches = await Promise.all(
    requestBatches.map(batch =>
      getNftMetadataBatch(
        config,
        batch.map(transfer => transfer.token)
      )
    )
  );
  const nfts = responseBatches.map(r => r.nfts).flat();

  // The same NFT can be transferred multiple times in the same transfers response.
  // We want to return one NFT for each transfer, so we create a mapping for
  // each NFT to pair with the transfer metadata.
  const nftsByTokenId = new Map<string, Nft>();
  nfts.forEach(nft => {
    const key = `${nft.contract.address.toLowerCase()}-${BigNumber.from(
      nft.tokenId
    ).toString()}`;
    nftsByTokenId.set(key, nft);
  });

  const transferredNfts = metadataTransfers.map(t => {
    const key = `${t.token.contractAddress.toLowerCase()}-${BigNumber.from(
      t.token.tokenId
    ).toString()}`;
    return {
      ...nftsByTokenId.get(key)!,
      ...t.metadata
    };
  });

  return {
    nfts: transferredNfts,
    pageKey: response.pageKey
  };
}

/**
 * Returns the underlying NFT tokens from a transfer as the params for a
 * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be
 * transferred in a single transaction.
 */
function getTokensFromTransfer(
  transfer: AssetTransfersResult
): NftMetadataBatchToken[] {
  // ERC1155 NFTs can contain multiple tokens in a single transfer, which
  // requires special logic.
  if (transfer.category === AssetTransfersCategory.ERC1155) {
    return parse1155Transfer(transfer);
  } else {
    return [
      {
        contractAddress: transfer.rawContract.address!,
        tokenId: transfer.tokenId!,
        tokenType:
          transfer.category === AssetTransfersCategory.ERC721
            ? NftTokenType.ERC721
            : undefined
      }
    ];
  }
}

/**
 * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter
 * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults
 * to including metadata.
 *
 * @internal
 */
function omitMetadataToWithMetadata(
  omitMetadata: boolean | undefined
): boolean {
  return omitMetadata === undefined ? true : !omitMetadata;
}

function parseReingestionState(reingestionState: string): NftRefreshState {
  switch (reingestionState) {
    case 'does_not_exist':
      return NftRefreshState.DOES_NOT_EXIST;
    case 'already_queued':
      return NftRefreshState.ALREADY_QUEUED;
    case 'in_progress':
      return NftRefreshState.IN_PROGRESS;
    case 'finished':
      return NftRefreshState.FINISHED;
    case 'queued':
      return NftRefreshState.QUEUED;
    case 'queue_failed':
      return NftRefreshState.QUEUE_FAILED;
    default:
      throw new Error('Unknown reingestion state: ' + reingestionState);
  }
}

/**
 * Interface for the `getNftsForNftContract` endpoint.
 *
 * @internal
 */
interface GetNftsForContractAlchemyParams {
  contractAddress: string;
  pageKey?: string;
  withMetadata: boolean;
  limit?: number;
  tokenUriTimeoutInMs?: number;
}

/**
 * Interface for the `getNfts` endpoint. The main difference is that the
 * endpoint has a `withMetadata` parameter, but the SDK exposes the parameter as
 * `omitMetadata`.
 *
 * @internal
 */
interface GetNftsAlchemyParams {
  owner: string;
  pageKey?: string;
  contractAddresses?: string[];
  excludeFilters?: NftFilters[];
  includeFilters?: NftFilters[];
  pageSize?: number;
  withMetadata: boolean;
  tokenUriTimeoutInMs?: number;
  orderBy?: string;
}

/**
 * NftTokenTypes that are allowed as request inputs.
 *
 * @internal
 */
export type InputNftTokenType =
  | NftTokenType.ERC1155
  | NftTokenType.ERC721
  | undefined;

/**
 * Interface for the `getNftMetadata` endpoint.
 *
 * @internal
 */
interface GetNftMetadataParams {
  contractAddress: string;
  tokenId: string;
  tokenType?: InputNftTokenType;
  refreshCache?: boolean;
  tokenUriTimeoutInMs?: number;
}

/**
 * Interface for the `isSpamContract` endpoint.
 *
 * @internal
 */
interface IsSpamContractParams {
  contractAddress: string;
}

/**
 * Interface for the `reportSpam` endpoint.
 *
 * @internal
 */
interface ReportSpamParams {
  contractAddress: string;
}

/**
 * Interface for the `isAirdropNft` endpoint.
 *
 * @internal
 */
interface isAirdropNftParams {
  contractAddress: string;
  tokenId: string;
}

/**
 * Interface for the `getContractMetadata` endpoint.
 *
 * @internal
 */
interface GetContractMetadataParams {
  contractAddress: string;
}
/**
 * Interface for the `getCollectionMetadata` endpoint.
 *
 * @internal
 */
interface GetCollectionMetadataParams {
  collectionSlug: string;
}

/**
 * Interface for the `getOwnersForNftContract` endpoint.
 *
 * @internal
 */
interface GetOwnersForNftContractAlchemyParams {
  contractAddress: string;
}

/**
 * Interface for the `getOwnersForContract` endpoint.
 *
 * @internal
 */
interface GetContractsForOwnerParams {
  owner: string;
  pageKey?: string;
  pageSize?: number;
  includeFilters?: NftFilters[];
  excludeFilters?: NftFilters[];
  orderBy?: NftOrdering;
}

/**
 * Interface for the `getFloorPrice` endpoint.
 *
 * @internal
 */
interface GetFloorPriceParams {
  contractAddress: string;
}

/**
 * Interface for the `getNftSales` endpoint.
 *
 * @internal
 */
interface GetNftSalesParams {
  fromBlock?: number | 'latest';
  toBlock?: number | 'latest';
  order?: SortingOrder;
  marketplace?: NftSaleMarketplace;
  contractAddress?: string;
  tokenId?: string;
  sellerAddress?: string;
  buyerAddress?: string;
  taker?: NftSaleTakerType;
  limit?: number;
  pageKey?: string;
}

/**
 * Interface for the `computeRarity` endpoint.
 *
 * @internal
 */
interface ComputeRarityParams {
  contractAddress: string;
  tokenId: string;
}

/**
 * Interface for the `searchContractMetadata` endpoint.
 *
 * @internal
 */
interface SearchContractMetadataParams {
  query: string;
}

/**
 * Interface for the `summarizeNFTAttributes` endpoint.
 *
 * @internal
 */
interface SummarizeNftAttributesParams {
  contractAddress: string;
}

interface ReingestContractParams {
  contractAddress: string;
}


================================================================================
File: src\internal\prices-api.ts
Size: 3.84 kB
================================================================================

import { AlchemyConfig } from '../api/alchemy-config';
import {
  GetTokenPriceByAddressResponse,
  GetTokenPriceBySymbolRequest,
  GetTokenPriceBySymbolResponse,
  HistoricalPriceByAddressResponse,
  HistoricalPriceBySymbolResponse,
  HistoricalPriceInterval,
  TokenAddressRequest
} from '../types/prices-types';
import { Network } from '../types/types';
import { AlchemyApiType } from '../util/const';
import { nullsToUndefined } from '../util/util';
import { requestHttpWithBackoff } from './dispatch';

const PRICES_BASE_URL = 'https://api.g.alchemy.com/prices/v1/alch-demo';

export async function getTokenPriceByAddress(
  config: AlchemyConfig,
  addresses: TokenAddressRequest[],
  srcMethod = 'getTokenPriceByAddress'
): Promise<GetTokenPriceByAddressResponse> {
  const response = await requestHttpWithBackoff<
    {},
    GetTokenPriceByAddressResponse
  >(
    config,
    AlchemyApiType.PRICES,
    'tokens/by-address',
    srcMethod,
    {},
    {
      method: 'POST',
      data: { addresses },
      baseURL: PRICES_BASE_URL
    }
  );
  return nullsToUndefined<GetTokenPriceByAddressResponse>(response);
}

export async function getTokenPriceBySymbol(
  config: AlchemyConfig,
  symbols: string[],
  srcMethod = 'getTokenPriceBySymbol'
): Promise<GetTokenPriceBySymbolResponse> {
  const response = await requestHttpWithBackoff<
    GetTokenPriceBySymbolRequest,
    GetTokenPriceBySymbolResponse
  >(
    config,
    AlchemyApiType.PRICES,
    'tokens/by-symbol',
    srcMethod,
    {
      symbols
    },
    {
      // We need to serialize the symbols array as URLSearchParams since the
      // Alchemy API expects a query parameter for each symbol. The axios default
      // serializer will not work here because the symbols array is an array of
      // strings.
      // Axios default encoding: ?symbols[]=AAVE&symbols[]=UNI
      // Alchemy requires: ?symbols=AAVE&symbols=UNI
      paramsSerializer: params => {
        const searchParams = new URLSearchParams();
        Object.entries(params).forEach(([key, value]) => {
          value.forEach((v: string) => searchParams.append(key, v));
        });
        return searchParams.toString();
      }
    }
  );
  return nullsToUndefined<GetTokenPriceBySymbolResponse>(response);
}

export async function getHistoricalPriceBySymbol(
  config: AlchemyConfig,
  symbol: string,
  startTime: string | number,
  endTime: string | number,
  interval: HistoricalPriceInterval,
  srcMethod = 'getHistoricalPriceBySymbol'
): Promise<HistoricalPriceBySymbolResponse> {
  const response = await requestHttpWithBackoff<
    {},
    HistoricalPriceBySymbolResponse
  >(
    config,
    AlchemyApiType.PRICES,
    'tokens/historical',
    srcMethod,
    {},
    {
      method: 'POST',
      data: {
        symbol,
        startTime,
        endTime,
        interval
      },
      baseURL: PRICES_BASE_URL
    }
  );
  return nullsToUndefined<HistoricalPriceBySymbolResponse>(response);
}

export async function getHistoricalPriceByAddress(
  config: AlchemyConfig,
  network: Network,
  address: string,
  startTime: string | number,
  endTime: string | number,
  interval: HistoricalPriceInterval,
  srcMethod = 'getHistoricalPriceByAddress'
): Promise<HistoricalPriceByAddressResponse> {
  const response = await requestHttpWithBackoff<
    {},
    HistoricalPriceByAddressResponse
  >(
    config,
    AlchemyApiType.PRICES,
    'tokens/historical',
    srcMethod,
    {},
    {
      method: 'POST',
      data: {
        network,
        address,
        startTime,
        endTime,
        interval
      },
      baseURL: PRICES_BASE_URL
    }
  );
  return nullsToUndefined<HistoricalPriceByAddressResponse>(response);
}


================================================================================
File: src\internal\raw-interfaces.ts
Size: 9.41 kB
================================================================================

/**
 * This file contains the raw HTTP responses returned by the Alchemy endpoints.
 * These types are not exposed to the end user and are instead used internally
 * by the SDK to construct the SDK's returned types.
 */

/**
 * Represents an NFT object along with its metadata received from Alchemy.
 *
 * @internal
 */
export interface RawNft {
  contract: RawNftContractForNft;
  tokenId: string;
  tokenType: string;
  name: string | null;
  description: string | null;
  image: RawNftImage;
  raw: RawNftData;
  tokenUri: string | null;
  timeLastUpdated: string;
  acquiredAt?: RawAcquiredAt;
  mint?: RawNftMint;
  collection: RawBaseNftCollection;
}

/** Information on the time at which an NFT was last acquired. */
export interface RawAcquiredAt {
  /** Timestamp of the block at which an NFT was last acquired. */
  blockTimestamp?: string;

  /** Block number of the block at which an NFT was last acquired. */
  blockNumber?: number;
}

export interface RawNftData {
  tokenUri: string | null;
  metadata: Record<string, any>;
  error: string | null;
}

export interface RawNftMint {
  mintAddress?: string;
  blockNumber?: number;
  timestamp?: string;
  transactionHash?: string;
}

export interface RawNftContract {
  address: string;
  tokenType: string;
  name: string | null;
  symbol: string | null;
  totalSupply: string | null;
  contractDeployer: string | null;
  deployedBlockNumber: number | null;
  openSeaMetadata: RawOpenSeaCollectionMetadata;
}

/**
 * Represents the contract address and metadata of an NFT object received from
 * Alchemy. This field is separated out since not all NFT API endpoints return a
 * contract field.
 *
 * @internal
 */
export interface RawNftContractForNft extends RawNftContract {
  isSpam: boolean | null;
  spamClassifications: string[];
}

export interface RawGetFloorPriceResponse {
  openSea: RawFloorPriceSuccess | RawFloorPriceFailure;
  looksRare: RawFloorPriceSuccess | RawFloorPriceFailure;
}

export interface RawFloorPriceSuccess {
  floorPrice: number;
  priceCurrency: string;
  collectionUrl: string;
  retrievedAt: string;
  error: null;
}

export interface RawFloorPriceFailure {
  floorPrice: null;
  priceCurrency: null;
  collectionUrl: null;
  retrievedAt: null;
  error: string;
}

/**
 * Represents the metadata of an NFT collection received from Alchemy.
 *
 * @internal
 */
export interface RawNftCollection {
  name: string;
  slug: string | null;
  floorPrice: RawNftCollectionFloorPrice;
  description: string | null;
  externalUrl: string | null;
  twitterUsername: string | null;
  discordUrl: string | null;
}

export interface RawNftCollectionFloorPrice {
  marketplace: string | null;
  floorPrice: number | null;
  priceCurrency: string | null;
}

export interface RawBaseNftCollection {
  name: string;
  slug: string | null;
  externalUrl: string | null;
  bannerImageUrl: string | null;
}

/** OpenSea's full metadata for an NFT collection. */
export interface RawOpenSeaCollectionMetadata {
  floorPrice: number | null;
  collectionName: string | null;
  collectionSlug: string | null;
  safelistRequestStatus: string | null;
  imageUrl: string | null;
  bannerImageUrl: string | null;
  description: string | null;
  externalUrl: string | null;
  twitterUsername: string | null;
  discordUrl: string | null;
  lastIngestedAt: string;
}

/**
 * Represents Alchemy's HTTP response for `getNfts` without metadata.
 *
 * @internal
 */
export interface RawGetBaseNftsResponse {
  ownedNfts: RawOwnedBaseNft[];
  totalCount: number;
  validAt: RawNftsForOwnerValidAt;
  pageKey: string | null;
}

/**
 * Represents Alchemy's HTTP response for `getNfts` with metadata.
 *
 * @internal
 */
export interface RawGetNftsForOwnerResponse {
  ownedNfts: RawOwnedNft[];
  totalCount: number;
  validAt: RawNftsForOwnerValidAt;
  pageKey: string | null;
}

/**
 * Represents the `ownedNfts` field from the Alchemy HTTP response when calling
 * the `getNfts` endpoint without metadata.
 *
 * @internal
 */
export interface RawOwnedBaseNft {
  contractAddress: string;
  tokenId: string;
  balance: string;
}

/**
 * Represents the `ownedNfts` field from the Alchemy HTTP response when calling
 * the `getNfts` endpoint with metadata.
 *
 * @internal
 */
export interface RawOwnedNft extends RawNft {
  balance: string;
}

export interface RawNftsForOwnerValidAt {
  blockNumber: number | null;
  blockHash: string;
  blockTimestamp: string | null;
}
/**
 * Represents Alchemy's HTTP response for `getNftsForNftContract` without metadata.
 *
 * @internal
 */
export interface RawGetBaseNftsForContractResponse {
  nfts: RawContractBaseNft[];
  pageKey: string | null;
}

/**
 * Represents Alchemy's HTTP response for `getNftsForNftContract` with metadata.
 *
 * @internal
 */
export interface RawGetNftsForContractResponse {
  nfts: RawNft[];
  pageKey: string | null;
}

/**
 * Represents the `nfts` field from the Alchemy HTTP response when calling the
 * `getNftsForNftContract` endpoint without metadata.
 *
 * @internal
 */
export interface RawContractBaseNft {
  tokenId: string;
}

/**
 * Represents Alchemy's HTTP response for `getOwnersForNftContract`.
 *
 * @internal
 */
export interface RawGetOwnersForContractResponse {
  owners: string[];
  pageKey: string | null;
}

export interface RawGetOwnersForContractWithTokenBalancesResponse {
  owners: RawOwnerAddress[];
  pageKey: string | null;
}

export interface RawOwnerAddress {
  ownerAddress: string;
  tokenBalances: RawTokenBalances[];
}

export interface RawTokenBalances {
  tokenId: string;
  balance: string;
}

export interface RawReingestContractResponse {
  contractAddress: string;
  reingestionState: string;
  progress: string | null;
}

export interface RawWebhook {
  id: string;
  network: string;
  webhook_type: string;
  webhook_url: string;
  is_active: boolean;
  time_created: number;
  signing_key: string;
  version: string;
  app_id?: string;
}

export interface RawWebhookPagination {
  cursors: {
    after?: string;
  };
  total_count: number;
}

export interface RawGetAllWebhooksResponse {
  data: RawWebhook[];
}

export interface RawAddressActivityResponse {
  data: string[];
  pagination: RawWebhookPagination;
}

export interface RawCustomGraphqlWebhookConfig {
  data: {
    webhook_id: string;
    graphql_query: string;
  };
}

export interface RawNftFilter {
  contract_address: string;
  token_id: string;
}

export interface RawNftFiltersResponse {
  data: RawNftFilter[];
  pagination: RawWebhookPagination;
}

export interface RawCreateWebhookResponse {
  data: RawWebhook;
}

export interface RawNftFilterParam {
  contract_address: string;
  token_id?: string;
}

export interface RawSearchContractMetadataResponse {
  contracts: RawNftContract[];
}

export interface RawComputeRarityResponse {
  rarities: RawNftAttributeRarity[];
}

export interface RawNftAttributeRarity {
  value: string;
  traitType: string;
  prevalence: number;
}

export interface RawNftAttributesResponse {
  summary: Record<string, Record<string, number>>;
  totalSupply: string;
  contractAddress: string;
}

export interface RawGetNftSalesResponse {
  nftSales: RawNftSale[];
  validAt: RawNftSaleValidAt;
  pageKey: string | null;
}

export interface RawNftSale {
  marketplace: string;
  marketplaceAddress: string;
  contractAddress: string;
  tokenId: string;
  quantity: string;
  buyerAddress: string;
  sellerAddress: string;
  taker: string;
  sellerFee: RawNftSaleFeeData;
  protocolFee: RawNftSaleFeeData;
  royaltyFee: RawNftSaleFeeData;
  blockNumber: number;
  logIndex: number;
  bundleIndex: number;
  transactionHash: string;
}

export interface RawNftSaleValidAt {
  blockNumber: number;
  blockHash: string | null;
  blockTimestamp: string | null;
}

export interface RawNftSaleFeeData {
  amount: string | null;
  tokenAddress: string | null;
  symbol: string | null;
  decimals: number | null;
}

export interface RawGetContractsForOwnerResponse {
  contracts: RawNftContractForOwner[];
  pageKey: string | null;
  totalCount: number;
}

export interface RawNftContractForOwner
  extends RawNftContract,
    RawNftContractOwnershipInfo {
  displayNft: RawDisplayNftForContract;
  image: RawNftImage;
}

export interface RawGetNftMetadataBatchResponse {
  nfts: Array<RawNft>;
}

export interface RawGetContractMetadataBatchResponse {
  contracts: RawNftContract[];
}

export interface RawIsSpamContractResponse {
  isSpamContract: boolean;
}

export interface RawGetSpamContractsResponse {
  contractAddresses: string[];
}

export interface RawIsAirdropNftResponse {
  isAirdrop: boolean;
}

export interface RawDisplayNftForContract {
  tokenId: string;
  name: string | null;
}

export interface RawNftImage {
  cachedUrl: string | null;
  thumbnailUrl: string | null;
  pngUrl: string | null;
  contentType: string | null;
  size: number | null;
  originalUrl: string | null;
}

export interface RawNftContractOwnershipInfo {
  totalBalance: string;
  numDistinctTokensOwned: string;
  isSpam: boolean;
}


================================================================================
File: src\internal\request-batcher.ts
Size: 3.84 kB
================================================================================

import { JsonRpcRequest, JsonRpcResponse } from './internal-types';

/** Maximum size of a batch on the rpc provider. */
const DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;

/** Timeout interval before the pending batch is sent. */
const DEFAULT_REQUEST_BATCH_DELAY_MS = 10;

/**
 * Internal class to enqueue requests and automatically send/process batches.
 *
 * The underlying batching mechanism is loosely based on ethers.js's
 * `JsonRpcBatchProvider`.
 *
 * @internal
 */
export class RequestBatcher {
  /** Timeout timer that periodically sends the pending batch. */
  private pendingBatchTimer: NodeJS.Timer | undefined;

  /**
   * Array of enqueued requests along with the constructed promise handlers for
   * each request.
   */
  private pendingBatch: Array<BatchRequest> = [];

  constructor(
    private readonly sendBatchFn: SendBatchFn,
    private readonly maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE
  ) {}

  /**
   * Enqueues the provided request. The batch is immediately sent if the maximum
   * batch size is reached. Otherwise, the request is enqueued onto a batch that
   * is sent after 10ms.
   *
   * Returns a promise that resolves with the result of the request.
   */
  async enqueueRequest(request: JsonRpcRequest): Promise<any> {
    const inflightRequest: BatchRequest = {
      request,
      resolve: undefined,
      reject: undefined
    };

    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });

    this.pendingBatch.push(inflightRequest);

    if (this.pendingBatch.length === this.maxBatchSize) {
      // Send batch immediately if we are at the maximum batch size.
      void this.sendBatchRequest();
    } else if (!this.pendingBatchTimer) {
      // Schedule batch for next event loop + short duration
      this.pendingBatchTimer = setTimeout(
        () => this.sendBatchRequest(),
        DEFAULT_REQUEST_BATCH_DELAY_MS
      );
    }

    return promise;
  }

  /**
   * Sends the currently queued batches and resets the batch and timer. Processes
   * the batched response results back to the original promises.
   */
  private async sendBatchRequest(): Promise<void> {
    // Get the current batch and clear it, so new requests
    // go into the next batch
    const batch = this.pendingBatch;
    this.pendingBatch = [];
    if (this.pendingBatchTimer) {
      clearTimeout(this.pendingBatchTimer);
      this.pendingBatchTimer = undefined;
    }

    // Get the request as an array of requests
    const request = batch.map(inflight => inflight.request);

    return this.sendBatchFn(request).then(
      result => {
        // For each result, feed it to the correct Promise, depending
        // on whether it was a success or error
        batch.forEach((inflightRequest, index) => {
          const payload = result[index];
          if (payload.error) {
            const error = new Error(payload.error.message);
            (error as any).code = payload.error.code;
            (error as any).data = payload.error.data;
            inflightRequest.reject!(error);
          } else {
            inflightRequest.resolve!(payload.result);
          }
        });
      },
      error => {
        batch.forEach(inflightRequest => {
          inflightRequest.reject!(error);
        });
      }
    );
  }
}

/** Function type to match the `fetchJson` function in ethers. */
type SendBatchFn = (reqs: JsonRpcRequest[]) => Promise<JsonRpcResponse[]>;

/**
 * Internal interface to represent a request on a batch along with the promises to resolve it.
 */
interface BatchRequest {
  request: JsonRpcRequest;
  resolve?: (result: any) => void;
  reject?: (error: Error) => void;
}


================================================================================
File: src\internal\websocket-backfiller.ts
Size: 12.72 kB
================================================================================

import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';
import { fromHex, toHex } from '../api/util';

export interface BatchPart {
  method: string;
  params?: any;
}

export interface NewHeadsEvent {
  author: string;
  difficulty: string;
  extraData: string;
  gasLimit: string;
  gasUsed: string;
  hash: string;
  logsBloom: string;
  miner: string;
  mixHash: string;
  nonce: string;
  number: string;
  parentHash: string;
  receiptsRoot: string;
  sealFields: string[];
  sha3Uncles: string;
  size: string;
  stateRoot: string;
  timestamp: string;
  transactionsRoot: string;
}

/** The return type of eth_getBlocksByHash. */
export interface BlockHead extends NewHeadsEvent {
  totalDifficulty: string;
  transactions: any[];
  uncles: string[];
}

export interface LogsEvent {
  address: string;
  blockHash: string;
  blockNumber: string;
  data: string;
  logIndex: string;
  topics: string[];
  transactionHash: string;
  transactionIndex: string;
  removed?: boolean;
}

export interface LogsSubscriptionFilter {
  address?: string | string[];
  topics?: Array<string | string[] | null>;
}

export interface GetLogsOptions extends LogsSubscriptionFilter {
  fromBlock?: string;
  toBlock?: string;
}

interface CommonAncestor {
  blockNumber: number;
  logIndex: number;
}

/**
 * The maximum number of blocks to backfill. If more than this many blocks have
 * been missed, then we'll sadly miss data, but we want to make sure we don't
 * end up requesting thousands of blocks if somebody left their laptop closed for a week.
 */
const MAX_BACKFILL_BLOCKS = 120;

/**
 * The WebsocketBackfiller fetches events that were sent since a provided block
 * number. This is used in the {@link AlchemyWebSocketProvider} to backfill
 * events that were transmitted while the websocket connection was down.
 *
 * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.
 *
 * @internal
 */
export class WebsocketBackfiller {
  // TODO: Use HTTP provider to do backfill.
  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;
  constructor(private readonly provider: AlchemyWebSocketProvider) {}

  /**
   * Runs backfill for `newHeads` events.
   *
   * @param isCancelled Whether the backfill request is cancelled.
   * @param previousHeads Previous head requests that were sent.
   * @param fromBlockNumber The block number to start backfilling from.
   * @returns A list of `newHeads` events that were sent since the last backfill.
   */
  async getNewHeadsBackfill(
    isCancelled: () => boolean,
    previousHeads: NewHeadsEvent[],
    fromBlockNumber: number
  ): Promise<NewHeadsEvent[]> {
    throwIfCancelled(isCancelled);
    const toBlockNumber = await this.getBlockNumber();
    throwIfCancelled(isCancelled);

    // If there are no previous heads to fetch, return new heads since
    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.
    if (previousHeads.length === 0) {
      return this.getHeadEventsInRange(
        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,
        toBlockNumber + 1
      );
    }

    // If the last emitted event is too far back in the past, there's no need
    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of
    // new heads.
    const lastSeenBlockNumber = fromHex(
      previousHeads[previousHeads.length - 1].number
    );
    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
    if (lastSeenBlockNumber <= minBlockNumber) {
      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);
    }

    // To capture all `newHeads` events, return all head events from the last
    // seen block number to current + any of the previous heads that were re-orged.
    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(
      isCancelled,
      previousHeads
    );
    throwIfCancelled(isCancelled);
    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(
      lastSeenBlockNumber + 1,
      toBlockNumber + 1
    );
    throwIfCancelled(isCancelled);
    return [...reorgHeads, ...intermediateHeads];
  }

  /**
   * Runs backfill for `logs` events.
   *
   * @param isCancelled Whether the backfill request is cancelled.
   * @param filter The filter object that accompanies a logs subscription.
   * @param previousLogs Previous log requests that were sent.
   * @param fromBlockNumber The block number to start backfilling from.
   */
  async getLogsBackfill(
    isCancelled: () => boolean,
    filter: LogsSubscriptionFilter,
    previousLogs: LogsEvent[],
    fromBlockNumber: number
  ): Promise<LogsEvent[]> {
    throwIfCancelled(isCancelled);
    const toBlockNumber = await this.getBlockNumber();
    throwIfCancelled(isCancelled);

    // If there are no previous logs to fetch, return new logs since
    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.
    if (previousLogs.length === 0) {
      return this.getLogsInRange(
        filter,
        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,
        toBlockNumber + 1
      );
    }

    // If the last emitted log is too far back in the past, there's no need
    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`
    // worth of logs.
    const lastSeenBlockNumber = fromHex(
      previousLogs[previousLogs.length - 1].blockNumber
    );
    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
    if (lastSeenBlockNumber < minBlockNumber) {
      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);
    }

    // Return all log events that have happened along with log events that have
    // been removed due to a chain reorg.
    const commonAncestor = await this.getCommonAncestor(
      isCancelled,
      previousLogs
    );
    throwIfCancelled(isCancelled);

    // All previous logs with a block number greater than the common ancestor
    // were part of a re-org, so mark them as such.
    const removedLogs = previousLogs
      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)
      .map(log => ({ ...log, removed: true }));

    // If no common ancestor was found, start backfill from the oldest log's
    // block number.
    const fromBlockInclusive =
      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY
        ? fromHex(previousLogs[0].blockNumber)
        : commonAncestor.blockNumber;
    let addedLogs = await this.getLogsInRange(
      filter,
      fromBlockInclusive,
      toBlockNumber + 1
    );

    // De-dupe any logs that were already emitted.
    addedLogs = addedLogs.filter(
      log =>
        log &&
        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||
          fromHex(log.logIndex) > commonAncestor.logIndex)
    );

    throwIfCancelled(isCancelled);
    return [...removedLogs, ...addedLogs];
  }

  /**
   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.
   *
   * @internal
   */
  setMaxBackfillBlock(newMax: number): void {
    this.maxBackfillBlocks = newMax;
  }

  /**
   * Gets the current block number as a number.
   *
   * @private
   */
  private async getBlockNumber(): Promise<number> {
    const blockNumberHex: string = await this.provider.send('eth_blockNumber');
    return fromHex(blockNumberHex);
  }

  /**
   * Gets all `newHead` events in the provided range. Note that the returned
   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads
   * that were part of a re-org.
   *
   * @private
   */
  private async getHeadEventsInRange(
    fromBlockInclusive: number,
    toBlockExclusive: number
  ): Promise<NewHeadsEvent[]> {
    if (fromBlockInclusive >= toBlockExclusive) {
      return [];
    }
    const batchParts: BatchPart[] = [];
    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {
      batchParts.push({
        method: 'eth_getBlockByNumber',
        params: [toHex(i), false]
      });
    }

    // TODO: handle errors
    const blockHeads = await this.provider.sendBatch(batchParts);
    return blockHeads.map(toNewHeadsEvent);
  }

  /**
   * Returns all heads that were part of a reorg event.
   *
   * @private
   */
  private async getReorgHeads(
    isCancelled: () => boolean,
    previousHeads: NewHeadsEvent[]
  ): Promise<NewHeadsEvent[]> {
    const result: NewHeadsEvent[] = [];
    // Iterate from the most recent head backwards in order to find the first
    // block that was part of a re-org.
    for (let i = previousHeads.length - 1; i >= 0; i--) {
      const oldEvent = previousHeads[i];
      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));
      throwIfCancelled(isCancelled);

      // If the hashes match, then current head in the iteration was not re-orged.
      if (oldEvent.hash === blockHead.hash) {
        break;
      }

      result.push(toNewHeadsEvent(blockHead));
    }
    return result.reverse();
  }

  /**
   * Simple wrapper around `eth_getBlockByNumber` that returns the complete
   * block information for the provided block number.
   *
   * @private
   */
  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {
    return this.provider.send('eth_getBlockByNumber', [
      toHex(blockNumber),
      false
    ]);
  }

  /**
   * Given a list of previous log events, finds the common block number from the
   * logs that matches the block head.
   *
   * This can be used to identify which logs are part of a re-org.
   *
   * Returns 1 less than the oldest log's block number if no common ancestor was found.
   *
   * @private
   */
  private async getCommonAncestor(
    isCancelled: () => boolean,
    previousLogs: LogsEvent[]
  ): Promise<CommonAncestor> {
    // Iterate from the most recent head backwards in order to find the first
    // block that was part of a re-org.
    let blockHead = await this.getBlockByNumber(
      fromHex(previousLogs[previousLogs.length - 1].blockNumber)
    );
    throwIfCancelled(isCancelled);
    for (let i = previousLogs.length - 1; i >= 0; i--) {
      const oldLog = previousLogs[i];

      // Ensure that updated blocks are fetched every time the log's block number
      // changes.
      if (oldLog.blockNumber !== blockHead.number) {
        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));
      }

      // Since logs are ordered in ascending order, the first log that matches
      // the hash should be the largest logIndex.
      if (oldLog.blockHash === blockHead.hash) {
        return {
          blockNumber: fromHex(oldLog.blockNumber),
          logIndex: fromHex(oldLog.logIndex)
        };
      }
    }
    return {
      blockNumber: Number.NEGATIVE_INFINITY,
      logIndex: Number.NEGATIVE_INFINITY
    };
  }

  /**
   * Gets all `logs` events in the provided range. Note that the returned logs
   * do not include removed logs.
   *
   * @private
   */ private async getLogsInRange(
    filter: LogsSubscriptionFilter,
    fromBlockInclusive: number,
    toBlockExclusive: number
  ): Promise<LogsEvent[]> {
    if (fromBlockInclusive >= toBlockExclusive) {
      return [];
    }
    const rangeFilter: GetLogsOptions = {
      ...filter,
      fromBlock: toHex(fromBlockInclusive),
      toBlock: toHex(toBlockExclusive - 1)
    };
    return this.provider.send('eth_getLogs', [rangeFilter]);
  }
}

function toNewHeadsEvent(head: BlockHead): NewHeadsEvent {
  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };
  delete result.totalDifficulty;
  delete result.transactions;
  delete result.uncles;
  return result;
}

export function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {
  return dedupe(events, event => event.hash);
}

export function dedupeLogs(events: LogsEvent[]): LogsEvent[] {
  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);
}

function dedupe<T>(items: T[], getKey: (item: T) => any): T[] {
  const keysSeen: Set<any> = new Set();
  const result: T[] = [];
  items.forEach(item => {
    const key = getKey(item);
    if (!keysSeen.has(key)) {
      keysSeen.add(key);
      result.push(item);
    }
  });
  return result;
}

const CANCELLED = new Error('Cancelled');
export function throwIfCancelled(isCancelled: () => boolean): void {
  if (isCancelled()) {
    throw CANCELLED;
  }
}


================================================================================
File: src\types\ethers-types.ts
Size: 276 B
================================================================================

export type {
  Block,
  BlockTag,
  BlockWithTransactions,
  EventType,
  FeeData,
  Log,
  TransactionRequest,
  TransactionResponse,
  TransactionReceipt
} from '@ethersproject/abstract-provider';

export type { BigNumberish } from '@ethersproject/bignumber';


================================================================================
File: src\types\nft-types.ts
Size: 38.89 kB
================================================================================

import { BlockTag } from '@ethersproject/abstract-provider';
import { BigNumberish } from '@ethersproject/bignumber';

import { OpenSeaSafelistRequestStatus, SortingOrder } from './types';

/**
 * An enum for specifying the token type on NFTs.
 *
 * @public
 */
export enum NftTokenType {
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
  NO_SUPPORTED_NFT_STANDARD = 'NO_SUPPORTED_NFT_STANDARD',
  NOT_A_CONTRACT = 'NOT_A_CONTRACT',
  UNKNOWN = 'UNKNOWN'
}

/**
 * Represents NFT metadata that holds fields. Note that since there is no
 * standard metadata format, the fields are not guaranteed to be present.
 *
 * @public
 */
export interface NftMetadata extends Record<string, any> {
  /** Name of the NFT asset. */
  name?: string;

  /** A human-readable description of the NFT asset. */
  description?: string;

  /** URL to the NFT asset image. */
  image?: string;

  /**
   * The image URL that appears along the top of the NFT asset page. This tends
   * to be the highest resolution image.
   */
  external_url?: string;

  /** Background color of the NFT item. Usually defined as a 6 character hex string. */
  background_color?: string;

  /** The traits, attributes, and characteristics for the NFT asset. */
  attributes?: Array<Record<string, any>>;
}

/** Media URLs and information for an NFT. */
export interface NftImage {
  /** URL of the image stored in Alchemy's cache. */
  cachedUrl?: string;
  /** URL of a thumbnail sized image. */
  thumbnailUrl?: string;
  /** URL of the image in png format */
  pngUrl?: string;
  /** The type of the media image. */
  contentType?: string;
  /** The size of the media asset in bytes. */
  size?: number;
  /** The original URL of the image as stored on the contract. */
  originalUrl?: string;
}

/** Potential reasons why an NFT contract was classified as spam. */
export enum NftSpamClassification {
  Erc721TooManyOwners = 'Erc721TooManyOwners',
  Erc721TooManyTokens = 'Erc721TooManyTokens',
  Erc721DishonestTotalSupply = 'Erc721DishonestTotalSupply',
  MostlyHoneyPotOwners = 'MostlyHoneyPotOwners',
  OwnedByMostHoneyPots = 'OwnedByMostHoneyPots',
  LowDistinctOwnersPercent = 'LowDistinctOwnersPercent',
  HighHoneyPotOwnerPercent = 'HighHoneyPotOwnerPercent',
  HighHoneyPotPercent = 'HighHoneyPotPercent',
  HoneyPotsOwnMultipleTokens = 'HoneyPotsOwnMultipleTokens',
  NoSalesActivity = 'NoSalesActivity',
  HighAirdropPercent = 'HighAirdropPercent',
  Unknown = 'Unknown'
}

/** Block time and number at which an NFT was acquired. */
export interface AcquiredAt {
  /** Timestamp of the block at which an NFT was last acquired. */
  blockTimestamp?: string;

  /** Block number of the block at which an NFT was last acquired. */
  blockNumber?: number;
}

/**
 * Optional parameters object for the {@link getNftsForOwner} and
 * {@link getNftsForOwnerIterator} functions.
 *
 * This interface is used to fetch NFTs with their associated metadata. To get
 * Nfts without their associated metadata, use {@link GetBaseNftsForOwnerOptions}.
 *
 * @public
 */
export interface GetNftsForOwnerOptions {
  /**
   * Optional page key from an existing {@link OwnedBaseNftsResponse} or
   * {@link OwnedNftsResponse}to use for pagination.
   */
  pageKey?: string;

  /** Optional list of contract addresses to filter the results by. Limit is 20. */
  contractAddresses?: string[];

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are excluded from the response.
   */
  excludeFilters?: NftFilters[];

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are included in the response.
   */
  includeFilters?: NftFilters[];

  /**
   * Sets the total number of NFTs to return in the response. Defaults to 100.
   * Maximum page size is 100.
   */
  pageSize?: number;

  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */
  omitMetadata?: boolean;

  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;

  /**
   * Order in which to return results. By default, results are ordered by
   * contract address and token ID in lexicographic order.
   */
  orderBy?: NftOrdering;
}

/**
 * Optional parameters object for the {@link getNftsForOwner} and
 * {@link getNftsForOwnerIterator} functions.
 *
 * This interface is used to fetch NFTs without their associated metadata. To
 * get Nfts with their associated metadata, use {@link GetNftsForOwnerOptions}.
 *
 * @public
 */
export interface GetBaseNftsForOwnerOptions {
  /**
   * Optional page key from an existing {@link OwnedBaseNftsResponse} or
   * {@link OwnedNftsResponse}to use for pagination.
   */
  pageKey?: string;

  /** Optional list of contract addresses to filter the results by. Limit is 20. */
  contractAddresses?: string[];

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are excluded from the response.
   */
  excludeFilters?: NftFilters[];

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are included in the response.
   */
  includeFilters?: NftFilters[];

  /**
   * Sets the total number of NFTs to return in the response. Defaults to 100.
   * Maximum page size is 100.
   */
  pageSize?: number;

  /** Optional boolean flag to include NFT metadata. Defaults to `false`. */
  omitMetadata: true;

  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;

  /**
   * Order in which to return results. By default, results are ordered by
   * contract address and token ID in lexicographic order.
   */
  orderBy?: NftOrdering;
}

/**
 * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a
 * {@link getContractsForOwner} request.
 *
 * @beta
 */
export enum NftFilters {
  /** NFTs that have been classified as spam. */
  SPAM = 'SPAM',

  /** NFTs that have been airdropped to a user. */
  AIRDROPS = 'AIRDROPS'
}

/**
 * Enum of ordering that can be applied to a {@link getNftsForOwner} or a
 * {@link getContractsForOwner} response.
 *
 * @beta
 */
export enum NftOrdering {
  TRANSFERTIME = 'TRANSFERTIME'
}

/**
 * The response object for the {@link getNftsForOwner} and
 * {@link getNftsForOwnerIterator} functions. The object contains the NFTs with
 * metadata owned by the provided address, along with pagination information and
 * the total count.
 *
 * @public
 */
export interface OwnedNftsResponse {
  /** The NFTs owned by the provided address. */
  ownedNfts: OwnedNft[];

  /**
   * Pagination token that can be passed into another request to fetch the next
   * NFTs. If there is no page key, then there are no more NFTs to fetch.
   */
  pageKey?: string;

  /** The total count of NFTs owned by the provided address. */
  totalCount: number;

  /**
   * Block Information of the block as of which the corresponding data is valid
   */
  validAt: OwnedNftsValidAt;
}

/**
 * The response object for the {@link getNftsForOwner} and
 * {@link getNftsForOwnerIterator} functions. The object contains the NFTs
 * without metadata owned by the provided address, along with pagination
 * information and the total count.
 *
 * @public
 */
export interface OwnedBaseNftsResponse {
  /** The NFTs owned by the provided address. */
  ownedNfts: OwnedBaseNft[];

  /**
   * Pagination token that can be passed into another request to fetch the next
   * NFTs. If there is no page key, then there are no more NFTs to fetch.
   */
  pageKey?: string;

  /** The total count of NFTs owned by the provided address. */
  totalCount: number;

  /**
   * Block Information of the block as of which the corresponding data is valid
   */
  validAt: OwnedNftsValidAt;
}

/**
 * Represents an NFT with metadata owned by an address.
 *
 * @public
 */
export interface OwnedNft extends Nft {
  /** The token balance of the NFT. */
  balance: string;
}

/**
 * Represents an NFT without metadata owned by an address.
 *
 * @public
 */
export interface OwnedBaseNft extends BaseNft {
  /** The token balance of the NFT. */
  balance: string;
}

/** The block information at which the NFT sale information is valid at. */
export interface OwnedNftsValidAt {
  /** The block number the sale information is valid at. */
  blockNumber?: number;
  /** The block hash. Used to detect reorgs. */
  blockHash: string;
  /** The timestamp for the block. */
  blockTimestamp?: string;
}

/**
 * The response object for the {@link getOwnersForNft}.
 *
 * @public
 */
export interface GetOwnersForNftResponse {
  /** An array of owner addresses for the provided token. */
  owners: string[];

  /** Optional The key for the next page of results, if applicable. */
  pageKey?: string;
}

/**
 * The response object for the {@link getOwnersForContract}.
 *
 * @public
 */
export interface GetOwnersForContractResponse {
  /** An array of owner addresses for the provided contract address */
  owners: string[];
  /**
   * Total count of unique owners. Only present if
   * {@link GetOwnersForContractOptions.includeCount} is true.
   */
  totalCount?: number;

  /** Optional page key that is returned when a collection has more than 50,000 owners. */
  pageKey?: string;
}

/**
 * The response object for the {@link getOwnersForContract}.
 *
 * @public
 */
export interface GetOwnersForContractWithTokenBalancesResponse {
  /** An array of owner addresses for the provided contract address */
  owners: NftContractOwner[];

  /** Optional page key that is returned when a collection has more than 50,000 owners. */
  pageKey?: string;
}

export interface GetNftMetadataBatchResponse {
  /** An array of NFT metadata objects. */
  nfts: Nft[];
}

export interface GetContractMetadataBatchResponse {
  contracts: NftContract[];
}

/**
 * An object representing the owner of an NFT and its corresponding token
 * balances in a {@link GetOwnersForContractWithTokenBalancesResponse} object.
 */
export interface NftContractOwner {
  /** The NFT's owner address. */
  ownerAddress: string;

  /** A list of objects containing token balances for the provided NFT contract. */
  tokenBalances: NftContractTokenBalance[];
}

/**
 * An object representing the owned token and balance values in a
 * {@link GetOwnersForContractWithTokenBalancesResponse} object.
 */
export interface NftContractTokenBalance {
  /** The token id owned in the NFT contract. */
  tokenId: string;
  /** The token id balance for the provided owner. */
  balance: string;
}

export interface IsSpamContractResponse {
  isSpamContract: boolean;
}

export interface IsAirdropNftResponse {
  isAirdrop: boolean;
}

export interface GetSpamContractsResponse {
  contractAddresses: string[];
}

/**
 * Additional options for the {@link NftNamespace.getNftMetadata} method.
 */
export interface GetNftMetadataOptions {
  /** Optional field to specify the type of token to speed up the query. */
  tokenType?: NftTokenType;
  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;

  /**
   * Whether to refresh the metadata for the given NFT token before returning
   * the response. Defaults to false for faster response times.
   */
  refreshCache?: boolean;
}

/**
 * Represents an NFT token to fetch metadata for in a
 * {@link NftNamespace.getNftMetadataBatch} method.
 */
export interface NftMetadataBatchToken {
  /** The NFT contract address. Limited to ERC721 and ERC1155 tokens. */
  contractAddress: string;

  /** The id of the NFT. */
  tokenId: BigNumberish;

  /** Optional field to specify the type of token to speed up the query. */
  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;
}

/** Additional options for the {@link NftNamespace.getNftMetadataBatch} method. */
export interface NftMetadataBatchOptions {
  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;

  /**
   * Whether to refresh the metadata for the given NFT token before returning
   * the response. Defaults to false for faster response times.
   */
  refreshCache?: boolean;
}

/**
 * The successful object returned by the {@link getFloorPrice} call for each
 * marketplace (e.g. looksRare).
 *
 * @public
 */
export interface FloorPriceMarketplace {
  /** The floor price of the collection on the given marketplace */
  floorPrice: number;
  /** The currency in which the floor price is denominated */
  priceCurrency: string;
  /** The link to the collection on the given marketplace */
  collectionUrl: string;
  /** UTC timestamp of when the floor price was retrieved from the marketplace */
  retrievedAt: string;
}

/**
 * The failing object returned by the {@link getFloorPrice} call for each
 * marketplace (e.g. looksRare).
 *
 * @public
 */
export interface FloorPriceError {
  /** Error fetching floor prices from the given marketplace */
  error: string;
}

/**
 * The response object for the {@link getFloorPrice} method.
 *
 * @public
 */
export interface GetFloorPriceResponse {
  /**
   * Name of the NFT marketplace where the collection is listed. Current
   * marketplaces supported: OpenSea, LooksRare
   */
  openSea: FloorPriceMarketplace | FloorPriceError;
  looksRare: FloorPriceMarketplace | FloorPriceError;
}

/**
 * Optional parameters object for the {@link getContractsForOwner} method
 *
 * @public
 */
export interface GetContractsForOwnerOptions {
  /** Key for pagination to use to fetch results from the next page if available. */
  pageKey?: string;

  /**
   * Configure the number of NFTs to return in each response. Maximum pages size
   * is 100. Defaults to 100.
   */
  pageSize?: number;

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are included in the response. May not be used in
   * conjunction with {@link excludeFilters}.
   */
  includeFilters?: NftFilters[];

  /**
   * Optional list of filters applied to the query. NFTs that match one or more
   * of these filters are excluded from the response. May not be used in
   * conjunction with {@link includeFilters}
   */
  excludeFilters?: NftFilters[];

  /**
   * Order in which to return results. By default, results are ordered by
   * contract address and token ID in lexicographic order.
   */
  orderBy?: NftOrdering;
}

/**
 * The response for the {@link NftNamespace.getContractsForOwner} method.
 *
 * @public
 */
export interface GetContractsForOwnerResponse {
  /** The list of contracts, that match the query, held by the given address. */
  contracts: NftContractForOwner[];

  /** Key for pagination to use to fetch results from the next page if available. */
  pageKey?: string;

  /** Total number of NFT contracts held by the given address. */
  totalCount: number;
}

/** Represents a single NFT contract data in the {@link GetContractsForOwnerResponse}. */
export interface NftContractForOwner extends NftContract {
  /**
   * Sum of NFT balances across all token IDs held by the owner. For
   * non-fungible tokens this will be equal to the numDistinctTokensOwned, but
   * it may be higher if the user holds some fungible ERC1155 tokens.
   */
  totalBalance: string;

  /**
   * Number of distinct token IDs held by the owner. For non-fungible tokens
   * this will be equal to the totalBalance, but it may be lower if the user
   * holds some fungible ERC1155 tokens.
   */
  numDistinctTokensOwned: string;

  /** Whether the NFT contract is considered spam. */
  isSpam: boolean;

  /**
   * Object containing an NFT owned by the owner for this particular contract.
   * Use this to display a sample NFT for the contract.
   */
  displayNft: DisplayNftForContract;

  /** Object containing different URLs for the NFT media. */
  image: NftImage;
}

/** Sample owned NFT on a {@link NftContract}, used to display placeholder info. */
export interface DisplayNftForContract {
  /** A token id of an NFT owned by the owner on the contract. */
  tokenId: string;
  /** The name of the NFT, if available. */
  name?: string;
}

/**
 * Optional parameters object for the {@link NftNamespace.getTransfersForOwner}
 * method.
 */
export interface GetTransfersForContractOptions {
  /** Starting block (inclusive) to get transfers from. */
  fromBlock?: BlockTag;
  /** Ending block (inclusive) to get transfers from. */
  toBlock?: BlockTag;
  /**
   * Whether to return results in ascending or descending order by block number.
   * Defaults to ascending if omitted.
   */
  order?: SortingOrder;
  /**
   * Optional page key from an existing {@link TransfersNftResponse} to use for
   * pagination.
   */
  pageKey?: string;
}

/**
 * Response object for NFT methods that fetch NFTs that were transferred or
 * minted (ex: {@link NftNamespace.getTransfersForOwner} or
 * {@link NftNamespace.getMintedNfts}).
 */
export interface TransfersNftResponse {
  /** An array of NFTs.*/
  nfts: TransferredNft[];
  /** Optional page key to use to fetch the next group of NFTs. */
  pageKey?: string;
}

/**
 * NFT with extra data for a single NFT that was transferred or minted.
 */
export interface TransferredNft extends Nft {
  /**
   * The address the NFT was from. For minted NFTs, this field is the set to
   * `0x0000000000000000000000000000000000000000`.
   **/
  from: string;
  /** The address the NFT was sent or minted to. */
  to?: string;
  /** The transaction hash where the transfer or mint occurred. */
  transactionHash: string;
  /** The block number as a hex string of when the transfer or mint occurred. */
  blockNumber: string;
}

/**
 * Optional parameters object for the {@link NftNamespace.getMintedNfts} method.
 */
export interface GetMintedNftsOptions {
  /**
   * List of NFT contract addresses to filter mints by. If omitted, defaults to
   * all contract addresses.
   */
  contractAddresses?: string[];

  /**
   * Filter mints by ERC721 vs ERC1155 contracts. If omitted, defaults to all
   * NFTs.
   */
  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;

  /**
   * Optional page key from an existing {@link TransfersNftResponse} to use for
   * pagination.
   */
  pageKey?: string;
}

/**
 * Optional parameters object for the {@link NftNamespace.getNftSales} method.
 *
 * This interface is used to filter the NFT sales data.
 *
 * @public
 */
export interface GetNftSalesOptions {
  /** The block number to start fetching NFT sales data from. */
  fromBlock?: number | 'latest';

  /** The block number limit to fetch NFT sales data from. */
  toBlock?: number | 'latest';

  /** Whether to return the results in ascending or descending order by block number. */
  order?: SortingOrder;

  /** The NFT marketplace to filter sales by. */
  marketplace?: NftSaleMarketplace;

  /** The address of the NFT buyer to filter sales by. */
  buyerAddress?: string;

  /** The address of the NFT seller to filter sales by. */
  sellerAddress?: string;

  /**
   * Filter by whether the buyer or seller was the taker in the NFT trade.
   * Defaults to returning both buyer and seller taker trades.
   */
  taker?: NftSaleTakerType;

  /** The maximum number of NFT sales to return. */
  limit?: number;

  /** Key for pagination to use to fetch results from the next page if available. */
  pageKey?: string;
}

/**
 * Alternative optional parameters object for the {@link NftNamespace.getNftSales}
 * method that allows filtering results by contractAddress.
 *
 * This interface is used to filter the NFT sales data.
 *
 * @public
 */
export interface GetNftSalesOptionsByContractAddress
  extends GetNftSalesOptions {
  /** The contract address of a NFT collection to filter sales by. */
  contractAddress: string;

  /** The token ID of an NFT within the specified contractAddress to filter sales by. */
  tokenId?: BigNumberish;
}

/**
 * The response for the {@link NftNamespace.getNftSales} method.
 *
 * @public
 */
export interface GetNftSalesResponse {
  /** List of NFT sales that match the query */
  nftSales: NftSale[];
  /**
   * Block Information of the block as of which the corresponding data is valid.
   */
  validAt: NftSaleValidAt;
  /**
   * The page key to use to fetch the next page if more results are available.
   */
  pageKey?: string;
}

/** Represents a single NFT sale data in the {@link GetNftSalesResponse}. */
export interface NftSale {
  /** The marketplace the sale took place on. */
  marketplace: NftSaleMarketplace;

  /** The marketplace address the sale was on. */
  marketplaceAddress: string;

  /** The NFT contract address. */
  contractAddress: string;

  /** The decimal token ID of the NFT being sold. */
  tokenId: string;

  /** The number of tokens sold in the sale as a decimal integer string. */
  quantity: string;

  /** The address of the buyer in the NFT sale. */
  buyerAddress: string;

  /** The address of the seller in the NFT sale. */
  sellerAddress: string;

  /** Whether the price taker in the trade was the buyer or the seller. */
  taker: NftSaleTakerType;

  /** The payment from buyer to the seller. */
  sellerFee: NftSaleFeeData;

  /** The payment from buyer to the marketplace. */
  protocolFee: NftSaleFeeData;

  /** The payment from buyer to the royalty address of the NFT collection. */
  royaltyFee: NftSaleFeeData;

  /** The block number the NFT sale took place in. */
  blockNumber: number;

  /** The log number of the sale event emitted within the block. */
  logIndex: number;

  /** The index of the token within the bundle of NFTs sold in the sale. */
  bundleIndex: number;

  /** The transactionHash of the NFT sale. */
  transactionHash: string;
}

/** The block information at which the NFT sale information is valid at. */
export interface NftSaleValidAt {
  /** The block number the sale information is valid at. */
  blockNumber: number;
  /** The block hash. Used to detect reorgs. */
  blockHash?: string;
  /** The timestamp for the block. */
  blockTimestamp?: string;
}

/**
 * Fee detail for an NFT sale.
 *
 * @public
 */
export interface NftSaleFeeData {
  /** The fee payment amount as a decimal integer string. */
  amount?: string;

  tokenAddress?: string;

  /** The symbol of the token used for the payment. */
  symbol?: string;

  /** The number of decimals of the token used for the payment. */
  decimals?: number;
}

/**
 * Enum representing the supported NFT marketplaces by the
 * {@link NftNamespace.getNftSales} method.
 *
 * @public
 */
export enum NftSaleMarketplace {
  SEAPORT = 'seaport',
  LOOKSRARE = 'looksrare',
  X2Y2 = 'x2y2',
  WYVERN = 'wyvern',
  CRYPTOPUNKS = 'cryptopunks',
  BLUR = 'blur',
  UNKNOWN = 'unknown'
}

/**
 * Mint information for the NFT.
 */
export interface NftMint {
  /** The address that the NFT was minted to. */
  mintAddress?: string;
  /** The block number that the NFT was minted on. */
  blockNumber?: number;
  /** The timestamp the NFT was minted on. */
  timestamp?: string;
  /** The transaction hash of the transaction that minted the NFT. */
  transactionHash?: string;
}

/**
 * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}
 * method.
 *
 * @public
 */
export enum NftSaleTakerType {
  BUYER = 'buyer',
  SELLER = 'seller'
}

export interface SearchContractMetadataResponse {
  contracts: NftContract[];
}

/**
 * Response object for the {@link NftNamespace.computeRarity} method.
 */
export interface ComputeRarityResponse {
  rarities: NftAttributeRarity[];
}

/**
 * Information about the rarity of an NFT's attribute in the specified collection.
 *
 * @public
 */
export interface NftAttributeRarity {
  /** Name of the NFT's attribute. */
  value: string;

  /** The type of NFT attribute. */
  traitType: string;

  /**
   * A number from 0 to 1 representing the prevalence of this value for this
   * trait type in the current collection.
   */
  prevalence: number;
}

/**
 * Summary of the attribute prevalence for the specified NFT contract.
 *
 * @public
 */
export interface NftAttributesResponse {
  /** The specified NFT contract's address. */
  contractAddress: string;

  /** The specified NFT contract's total supply. */
  totalSupply: string;

  /**
   * The attribute prevalence of each trait grouped by the trait type for the
   * provided NFT.
   */
  summary: Record<string, Record<string, number>>;
}

/** The current state of the NFT contract refresh process. */
export enum NftRefreshState {
  /** The provided contract is not an NFT or does not contain metadata. */
  DOES_NOT_EXIST = 'does_not_exist',

  /** The contract has already been queued for refresh. */
  ALREADY_QUEUED = 'already_queued',

  /** The contract is currently being refreshed. */
  IN_PROGRESS = 'in_progress',

  /** The contract refresh is complete. */
  FINISHED = 'finished',

  /** The contract refresh has been queued and await execution. */
  QUEUED = 'queued',

  /** The contract was unable to be queued due to an internal error. */
  QUEUE_FAILED = 'queue_failed'
}

/**
 * Metadata object returned in a {@link AssetTransfersResult} object if the asset
 * transferred is an ERC1155.
 *
 * @public
 */
export interface ERC1155Metadata {
  tokenId: string;
  value: string;
}

/**
 * Information about the underlying contract for the asset that was transferred
 * in a {@link AssetTransfersResult} object.
 *
 * @public
 */
export interface RawContract {
  /**
   * The raw transfer value as a hex string. `null` if the transfer was for an
   * ERC721 or ERC1155 token.
   */
  value: string | null;

  /** The contract address. `null` if it was an internal or external transfer. */
  address: string | null;

  /**
   * The number of decimals in the contract as a hex string. `null` if the value
   * is not in the contract and not available from other sources.
   */
  decimal: string | null;
}

/**
 * Optional parameters object for the {@link getNftsForContract} and
 * {@link getNftsForContractIterator} functions.
 *
 * This interface is used to fetch NFTs with their associated metadata. To get
 * Nfts without their associated metadata, use {@link GetBaseNftsForContractOptions}.
 *
 * @public
 */
export interface GetNftsForContractOptions {
  /**
   * Optional page key from an existing {@link NftContractBaseNftsResponse} or
   * {@link NftContractNftsResponse}to use for pagination.
   */
  pageKey?: string;

  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */
  omitMetadata?: boolean;

  /**
   * Sets the total number of NFTs to return in the response. Defaults to 100.
   * Maximum page size is 100.
   */
  pageSize?: number;

  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;
}

/**
 * Optional parameters object for the {@link getNftsForContract} and
 * {@link getNftsForContractIterator} functions.
 *
 * This interface is used to fetch NFTs without their associated metadata. To
 * get Nfts with their associated metadata, use {@link GetNftsForContractOptions}.
 *
 * @public
 */
export interface GetBaseNftsForContractOptions {
  /**
   * Optional page key from an existing {@link NftContractBaseNftsResponse} or
   * {@link NftContractNftsResponse}to use for pagination.
   */
  pageKey?: string;

  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */
  omitMetadata: false;

  /**
   * Sets the total number of NFTs to return in the response. Defaults to 100.
   * Maximum page size is 100.
   */
  pageSize?: number;

  /**
   * No set timeout by default - When metadata is requested, this parameter is
   * the timeout (in milliseconds) for the website hosting the metadata to
   * respond. If you want to only access the cache and not live fetch any
   * metadata for cache misses then set this value to 0.
   */
  tokenUriTimeoutInMs?: number;
}

/**
 * Optional parameters object for the {@link getNftsForContract} method.
 *
 * This interface configures options when fetching the owner addresses of the
 * provided contract.
 *
 * @public
 */
export interface GetOwnersForContractOptions {
  /**
   * Whether to include the token balances per token id for each owner. Defaults
   * to false when omitted.
   */
  withTokenBalances?: boolean;

  /** The block number in hex or decimal to fetch owners for. */
  block?: string;

  /** Optional page key to paginate the next page for large requests. */
  pageKey?: string;

  /**
   * If true, include total count of owners in the response. Only applicable
   * when `withTokenBalances` is not set to `true`.
   */
  includeCount?: boolean;
}

/**
 * Optional parameters object for the {@link getNftsForContract} method.
 *
 * This interface configures options when fetching the owner addresses of the
 * provided contract.
 *
 * @public
 */
export interface GetOwnersForContractWithTokenBalancesOptions {
  /**
   * Whether to include the token balances per token id for each owner. Defaults
   * to false when omitted.
   */
  withTokenBalances: true;

  /** The block number in hex or decimal to fetch owners for. */
  block?: string;

  /** Optional page key to paginate the next page for large requests. */
  pageKey?: string;
}

/**
 * Optional parameters object for the {@link getOwnersForNft} method.
 *
 * This interface configures options when fetching the owner addresses of the
 * provided NFT contract.
 *
 * @public
 */
export interface GetOwnersForNftOptions {
  /** Optional page key to paginate the next page for large requests. */
  pageKey?: string;

  /**
   * Sets the total number of owners to return in the response.
   */
  pageSize?: number;
}

/**
 * The response object for the {@link getNftsForContract} function. The object
 * contains the NFTs without metadata inside the NFT contract.
 *
 * @public
 */
export interface NftContractBaseNftsResponse {
  /** An array of NFTs without metadata. */
  nfts: BaseNft[];

  /**
   * Pagination token that can be passed into another request to fetch the next
   * NFTs. If there is no page key, then there are no more NFTs to fetch.
   */
  pageKey?: string;
}

/**
 * The response object for the {@link getNftsForContract} function. The object
 * contains the NFTs with metadata inside the NFT contract.
 *
 * @public
 */
export interface NftContractNftsResponse {
  /** An array of NFTs with metadata. */
  nfts: Nft[];

  /**
   * Pagination token that can be passed into another request to fetch the next
   * NFTs. If there is no page key, then there are no more NFTs to fetch.
   */
  pageKey?: string;
}

/** OpenSea's metadata for an NFT collection. */
export interface OpenSeaCollectionMetadata {
  /** The floor price of the collection. */
  floorPrice?: number;
  /** The name of the collection on OpenSea. */
  collectionName?: string;
  /** The slug of the collection on OpenSea. */
  collectionSlug?: string;
  /** The approval status of the collection on OpenSea. */
  safelistRequestStatus?: OpenSeaSafelistRequestStatus;
  /** The image URL determined by OpenSea. */
  imageUrl?: string;
  /**
   * The banner image URL determined by OpenSea.
   * @deprecated Use {@link bannerImageUrl} instead.
   */
  imageBannerUrl?: string;
  /** The banner image URL determined by OpenSea. */
  bannerImageUrl?: string;
  /** The description of the collection on OpenSea. */
  description?: string;
  /** The homepage of the collection as determined by OpenSea. */
  externalUrl?: string;
  /** The Twitter handle of the collection. */
  twitterUsername?: string;
  /** The Discord URL of the collection. */
  discordUrl?: string;
  /** Timestamp of when the OpenSea metadata was last ingested by Alchemy. */
  lastIngestedAt: string;
}

/**
 * Alchemy representation of an NFT contract.
 *
 * The BaseNftContract does not hold any metadata information and only contains
 * the address. The NftContract additionally contains the tokenType, name,
 * symbol, and more.
 *
 * @public
 */
export interface NftContract {
  /** The address of the NFT contract. */
  address: string;
  /** The type of the token in the contract. */
  tokenType: NftTokenType;
  /** The name of the contract. */
  name?: string;
  /** The symbol of the contract. */
  symbol?: string;
  /**
   * The number of NFTs in the contract as an integer string. This field is only
   * available on ERC-721 contracts.
   */
  totalSupply?: string;
  /** OpenSea's metadata for the contract. */
  openSeaMetadata: OpenSeaCollectionMetadata;
  /** The address that deployed the NFT contract. */
  contractDeployer?: string;
  /** The block number the NFT contract deployed in. */
  deployedBlockNumber?: number;
}

/** NFT contract metadata with spam information. */
export interface NftContractForNft extends NftContract {
  /** Whether the NFT contract is marked as spam. */
  isSpam?: boolean;
  /** Potential reasons why an NFT Contract was classified as spam. */
  spamClassifications: NftSpamClassification[];
}

/**
 * Alchemy representation of an NFT collection
 *
 * @public
 */
export interface NftCollection {
  /** The name of the collection. */
  name: string;
  /** The OpenSea human-readable slug of the collection. */
  slug?: string;
  /** The floor price of the collection*/
  floorPrice?: NftCollectionFloorPrice;
  /** The description of the collection. */
  description?: string;
  /** The homepage of the collection as determined by OpenSea. */
  externalUrl?: string;
  /** The Twitter handle of the collection. */
  twitterUsername?: string;
  /** The Discord URL of the collection. */
  discordUrl?: string;
}

/**
 * Floor price object for an NFT collection.
 */
export interface NftCollectionFloorPrice {
  /** The marketplace where the floor price was determined. */
  marketplace?: NftCollectionMarketplace;
  /** The floor price of the collection. */
  floorPrice?: number;
  /** The currency of the floor price. */
  priceCurrency?: string;
}

/**
 * Enum representing the supported NFT marketplaces on a
 * {@link NftCollectionFloorPrice} object.
 */
export enum NftCollectionMarketplace {
  OPENSEA = 'OpenSea'
}

/**
 * Alchemy representation of an NFT that doesn't contain metadata.
 *
 * The BaseNft object does not hold any metadata information and only contains
 * the NFT contract and token ID. The Nft object additionally contains the NFT
 * metadata, token URI information, and media.
 *
 * @public
 */
export interface BaseNft {
  /** The contract address of the NFT. */
  contractAddress: string;
  /** The NFT token ID as an integer string. */
  tokenId: string;
}

/**
 * Alchemy representation of an NFT.
 *
 * The BaseNft object does not hold any metadata information and only contains
 * the NFT contract and token ID. The Nft object additionally contains the NFT
 * metadata, token URI information, and media.
 *
 * @public
 */
export interface Nft {
  /** The NFT's underlying contract and relevant contract metadata. */
  contract: NftContractForNft;
  /** The NFT token ID as an integer string. */
  tokenId: string;
  /** The type of NFT.*/
  tokenType: NftTokenType;
  /** The NFT name. */
  name?: string;
  /** The NFT description. */
  description?: string;
  /** Media URLs and information for the NFT */
  image: NftImage;
  /** The raw metadata for the NFT based on the metadata URI on the NFT contract. */
  raw: NftRawMetadata;
  /** URIs for accessing the NFT's metadata blob. */
  tokenUri?: string;
  /** When the NFT was last updated in the blockchain. Represented in ISO-8601 format. */
  timeLastUpdated: string;
  /**
   * Time at which the NFT was most recently acquired by the user. Only
   * available when specifying `orderBy: NftOrdering.TRANSFERTIME` in the
   * request.
   */
  acquiredAt?: AcquiredAt;
  /** Collection metadata for the NFT, if available. */
  collection?: BaseNftCollection;
  /** Mint information for the NFT. */
  mint?: NftMint;
}

/**
 * A base collection object as part of an {@link Nft}.
 */
export interface BaseNftCollection {
  /** The name of the collection. */
  name: string;
  /** The OpenSea human-readable slug of the collection. */
  slug?: string;
  /** The external URL for the collection. */
  externalUrl?: string;
  /** The banner image URL for the collection. */
  bannerImageUrl?: string;
}

/**
 * The raw metadata for the NFT based on the metadata URI on the NFT contract.
 */
export interface NftRawMetadata {
  /** The raw token URI on the NFT contract. */
  tokenUri?: string;
  /** The raw metadata parsed from the raw token URI. */
  metadata: Record<string, any>;
  /** Error message if the raw metadata could not be fetched. */
  error?: string;
}


================================================================================
File: src\types\prices-types.ts
Size: 4.41 kB
================================================================================

import { Network } from './types';

/**
 * The parameter field of {@link PricesNamespace.getTokenPriceByAddress}.
 * Represents a network and address pair for getting token prices.
 *
 * @public
 */
export interface TokenAddressRequest {
  /** The network to get prices for. */
  network: Network;
  /** The contract address to get prices for. */
  address: string;
}

/**
 * The parameter field of {@link PricesNamespace.getTokenPriceBySymbol}.
 * Contains the list of token symbols to get prices for.
 *
 * @public
 */
export interface GetTokenPriceBySymbolRequest {
  /** The token symbols to get prices for. */
  symbols: string[];
}

/**
 * The response type of {@link PricesNamespace.getTokenPriceByAddress}.
 * Contains an array of token price results for each requested address.
 *
 * @public
 */
export interface GetTokenPriceByAddressResponse {
  /** The token price data for each requested address. */
  data: TokenPriceByAddressResult[];
}

/**
 * The response type of {@link PricesNamespace.getTokenPriceBySymbol}.
 * Contains an array of token price results for each requested symbol.
 *
 * @public
 */
export interface GetTokenPriceBySymbolResponse {
  /** The token price data for each requested symbol. */
  data: TokenPriceBySymbolResult[];
}

/**
 * Represents a token's price information at a specific point in time.
 *
 * @public
 */
export interface TokenPrice {
  /** The currency the price is denominated in (e.g. 'usd'). */
  currency: string;
  /** The price value as a string to preserve precision. */
  value: string;
  /** ISO timestamp of when the price was last updated. */
  lastUpdatedAt: string;
}

/**
 * Error information returned when a token price request fails.
 *
 * @public
 */
export interface TokenPriceError {
  /** The error message describing why the request failed. */
  message: string;
}

/**
 * The result object returned for each address in a
 * {@link GetTokenPriceByAddressResponse}.
 *
 * @public
 */
export interface TokenPriceByAddressResult {
  /** The network the token is on. */
  network: string;
  /** The token's contract address. */
  address: string;
  /** Array of price data for the token. Empty if there was an error. */
  prices: TokenPrice[];
  /** Error information if the request failed, null otherwise. */
  error: TokenPriceError | null;
}

/**
 * The result object returned for each symbol in a
 * {@link GetTokenPriceBySymbolResponse}.
 *
 * @public
 */
export interface TokenPriceBySymbolResult {
  /** The token symbol that was queried. */
  symbol: string;
  /** Array of price data for the token. Empty if there was an error. */
  prices: TokenPrice[];
  /** Error information if the request failed, null otherwise. */
  error: TokenPriceError | null;
}

/**
 * Valid time intervals for historical price data.
 *
 * @public
 */
export enum HistoricalPriceInterval {
  /** 5-minute intervals */
  FIVE_MINUTE = '5m',
  /** 1-hour intervals */
  ONE_HOUR = '1h',
  /** 1-day intervals */
  ONE_DAY = '1d'
}

/**
 * Historical price data point.
 *
 * @public
 */
export interface HistoricalPriceDataPoint {
  /** Price value as a string to preserve precision */
  value: string;
  /** ISO timestamp for the price data point */
  timestamp: string;
}

/**