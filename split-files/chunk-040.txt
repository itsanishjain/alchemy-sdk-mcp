
   * @param options - The optional parameters to use for the request.
   * @public
   */
  getNftsForOwnerIterator(
    owner: string,
    options?: GetNftsForOwnerOptions
  ): AsyncIterable<OwnedNft>;
  /**
   * Fetches all NFTs for a given owner and yields them in an async iterable.
   *
   * This method returns the base NFTs that omit the associated metadata and
   * pages through all page keys until all NFTs have been fetched.
   *
   * @param owner - The address of the owner.
   * @param options - The optional parameters to use for the request.
   * @public
   */
  getNftsForOwnerIterator(
    owner: string,
    options?: GetBaseNftsForOwnerOptions
  ): AsyncIterable<OwnedBaseNft>;
  getNftsForOwnerIterator(
    owner: string,
    options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions
  ): AsyncIterable<OwnedBaseNft | OwnedNft> {
    return getNftsForOwnerIterator(this.config, owner, options);
  }

  /**
   * Get all base NFTs for an owner.
   *
   * This method returns the base NFTs that omit the associated metadata. To get
   * all NFTs with their associated metadata, use {@link GetNftsForOwnerOptions}.
   *
   * @param owner - The address of the owner.
   * @param options - The optional parameters to use for the request.
   * @public
   */
  getNftsForOwner(
    owner: string,
    options: GetBaseNftsForOwnerOptions
  ): Promise<OwnedBaseNftsResponse>;
  /**
   * Get all NFTs for an owner.
   *
   * This method returns the full NFTs in the contract. To get all NFTs without
   * their associated metadata, use {@link GetBaseNftsForOwnerOptions}.
   *
   * @param owner - The address of the owner.
   * @param options - The optional parameters to use for the request.
   * @public
   */
  getNftsForOwner(
    owner: string,
    options?: GetNftsForOwnerOptions
  ): Promise<OwnedNftsResponse>;
  getNftsForOwner(
    owner: string,
    options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions
  ): Promise<OwnedNftsResponse | OwnedBaseNftsResponse> {
    return getNftsForOwner(this.config, owner, options);
  }

  /**
   * Get all NFTs for a given contract address.
   *
   * This method returns the full NFTs in the contract. To get all NFTs without
   * their associated metadata, use {@link GetBaseNftsForContractOptions}.
   *
   * @param contractAddress - The contract address of the NFT contract.
   * @param options - The parameters to use for the request. or
   *   {@link NftContractNftsResponse} response.
   * @beta
   */
  getNftsForContract(
    contractAddress: string,
    options?: GetNftsForContractOptions
  ): Promise<NftContractNftsResponse>;
  /**
   * Get all base NFTs for a given contract address.
   *
   * This method returns the base NFTs that omit the associated metadata. To get
   * all NFTs with their associated metadata, use {@link GetNftsForContractOptions}.
   *
   * @param contractAddress - The contract address of the NFT contract.
   * @param options - The optional parameters to use for the request.
   * @beta
   */
  getNftsForContract(
    contractAddress: string,
    options?: GetBaseNftsForContractOptions
  ): Promise<NftContractBaseNftsResponse>;
  getNftsForContract(
    contractAddress: string,
    options?: GetBaseNftsForContractOptions | GetNftsForContractOptions
  ): Promise<NftContractNftsResponse | NftContractBaseNftsResponse> {
    return getNftsForContract(this.config, contractAddress, options);
  }

  /**
   * Fetches all NFTs for a given contract address and yields them in an async iterable.
   *
   * This method returns the full NFTs in the contract and pages through all
   * page keys until all NFTs have been fetched. To get all NFTs without their
   * associated metadata, use {@link GetBaseNftsForContractOptions}.
   *
   * @param contractAddress - The contract address of the NFT contract.
   * @param options - The optional parameters to use for the request.
   * @beta
   */
  getNftsForContractIterator(
    contractAddress: string,
    options?: GetNftsForContractOptions
  ): AsyncIterable<Nft>;
  /**
   * Fetches all base NFTs for a given contract address and yields them in an
   * async iterable.
   *
   * This method returns the base NFTs that omit the associated metadata and
   * pages through all page keys until all NFTs have been fetched. To get all
   * NFTs with their associated metadata, use {@link GetNftsForContractOptions}.
   *
   * @param contractAddress - The contract address of the NFT contract.
   * @param options - The optional parameters to use for the request.
   * @beta
   */
  getNftsForContractIterator(
    contractAddress: string,
    options?: GetBaseNftsForContractOptions
  ): AsyncIterable<BaseNft>;
  getNftsForContractIterator(
    contractAddress: string,
    options?: GetBaseNftsForContractOptions | GetNftsForContractOptions
  ): AsyncIterable<BaseNft | Nft> {
    return getNftsForContractIterator(this.config, contractAddress, options);
  }

  /**
   * Gets all the owners for a given NFT contract along with the token balance.
   *
   * @param contractAddress - The NFT contract to get the owners for.
   * @param options Optional parameters to use for the request.
   * @public
   */
  getOwnersForContract(
    contractAddress: string,
    options: GetOwnersForContractWithTokenBalancesOptions
  ): Promise<GetOwnersForContractWithTokenBalancesResponse>;

  /**
   * Gets all the owners for a given NFT contract.
   *
   * Note that token balances are omitted by default. To include token balances
   * for each owner, use {@link GetOwnersForContractWithTokenBalancesOptions},
   * which has the `withTokenBalances` field set to `true`.
   *
   * @param contractAddress - The NFT contract to get the owners for.
   * @param options Optional parameters to use for the request.
   * @public
   */
  getOwnersForContract(
    contractAddress: string,
    options?: GetOwnersForContractOptions
  ): Promise<GetOwnersForContractResponse>;
  getOwnersForContract(
    contractAddress: string,
    options?:
      | GetOwnersForContractOptions
      | GetOwnersForContractWithTokenBalancesOptions
  ): Promise<
    GetOwnersForContractResponse | GetOwnersForContractWithTokenBalancesResponse
  > {
    return getOwnersForContract(this.config, contractAddress, options);
  }

  /**
   * Gets all the owners for a given NFT contract address and token ID.
   *
   * @param contractAddress - The NFT contract address.
   * @param tokenId - Token id of the NFT.
   * @param options - Optional parameters to use for the request.
   * @beta
   */
  getOwnersForNft(
    contractAddress: string,
    tokenId: BigNumberish,
    options?: GetOwnersForNftOptions
  ): Promise<GetOwnersForNftResponse> {
    return getOwnersForNft(this.config, contractAddress, tokenId, options);
  }

  /**
   * Gets all NFT contracts held by the specified owner address.
   *
   * @param owner - Address for NFT owner (can be in ENS format!).
   * @param options - The optional parameters to use for the request.
   * @public
   */
  // TODO(v3): Add overload for withMetadata=false
  getContractsForOwner(
    owner: string,
    options?: GetContractsForOwnerOptions
  ): Promise<GetContractsForOwnerResponse> {
    return getContractsForOwner(this.config, owner, options);
  }

  /**
   * Gets all NFT transfers for a given owner's address.
   *
   * @param owner The owner to get transfers for.
   * @param category Whether to get transfers to or from the owner address.
   * @param options Additional options for the request.
   */
  getTransfersForOwner(
    owner: string,
    category: GetTransfersForOwnerTransferType,
    options?: GetTransfersForOwnerOptions
  ): Promise<TransfersNftResponse> {
    return getTransfersForOwner(this.config, owner, category, options);
  }

  /**
   * Gets all NFT transfers for a given NFT contract address.
   *
   * Defaults to all transfers for the contract. To get transfers for a specific
   * block range, use {@link GetTransfersForContractOptions}.
   *
   * @param contract The NFT contract to get transfers for.
   * @param options Additional options for the request.
   */
  getTransfersForContract(
    contract: string,
    options?: GetTransfersForContractOptions
  ): Promise<TransfersNftResponse> {
    return getTransfersForContract(this.config, contract, options);
  }

  /**
   * Get all the NFTs minted by a specified owner address.
   *
   * @param owner - Address for the NFT owner (can be in ENS format).
   * @param options - The optional parameters to use for the request.
   */
  async getMintedNfts(
    owner: string,
    options?: GetMintedNftsOptions
  ): Promise<TransfersNftResponse> {
    return getMintedNfts(this.config, owner, options);
  }

  /**
   * Checks that the provided owner address owns one of more of the provided
   * NFT. Returns a boolean indicating whether the owner address owns the provided NFT.
   *
   * @param owner - The owner address to check.
   * @param contractAddress - An NFT contract address to check ownership for.
   */
  verifyNftOwnership(owner: string, contractAddress: string): Promise<boolean>;

  /**
   * Checks which of the provided NFTs the owner address owns. Returns a map of
   * contract address to a boolean indicating whether the owner address owns the NFT.
   *
   * @param owner - The owner address to check.
   * @param contractAddresses - An array NFT contract address to check ownership for.
   */
  verifyNftOwnership(
    owner: string,
    contractAddresses: string[]
  ): Promise<{ [contractAddress: string]: boolean }>;
  verifyNftOwnership(
    owner: string,
    contractAddress: string | string[]
  ): Promise<boolean | { [contractAddress: string]: boolean }> {
    return verifyNftOwnership(this.config, owner, contractAddress);
  }

  /**
   * Returns whether a contract is marked as spam or not by Alchemy. For more
   * information on how we classify spam, go to our NFT API FAQ at
   * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.
   *
   * @param contractAddress - The contract address to check.
   */
  isSpamContract(contractAddress: string): Promise<IsSpamContractResponse> {
    return isSpamContract(this.config, contractAddress);
  }

  /**
   * Returns a list of all spam contracts marked by Alchemy. For details on how
   * Alchemy marks spam contracts, go to
   * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.
   */
  getSpamContracts(): Promise<GetSpamContractsResponse> {
    return getSpamContracts(this.config);
  }

  /**
   * Returns whether a contract is marked as spam or not by Alchemy. For more
   * information on how we classify spam, go to our NFT API FAQ at
   * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.
   *
   * @param contractAddress - The contract address to check.
   */
  reportSpam(contractAddress: string): Promise<void> {
    return reportSpam(this.config, contractAddress);
  }

  /**
   * Returns whether a token is marked as an airdrop or not.
   * Airdrops are defined as NFTs that were minted to a user address in a transaction
   * sent by a different address.
   *
   * @param contractAddress - The contract address to check.
   * @param tokenId - Token id of the NFT.
   */
  isAirdropNft(
    contractAddress: string,
    tokenId: string
  ): Promise<IsAirdropNftResponse> {
    return isAirdropNft(this.config, contractAddress, tokenId);
  }

  /**
   * Returns the floor prices of a NFT contract by marketplace.
   *
   * @param contractAddress - The contract address for the NFT collection.
   * @beta
   */
  getFloorPrice(contractAddress: string): Promise<GetFloorPriceResponse> {
    return getFloorPrice(this.config, contractAddress);
  }

  /**
   * Returns NFT sales that have happened through on-chain marketplaces.
   *
   * @param options - The optional parameters to use for the request.
   * @beta
   */
  getNftSales(options?: GetNftSalesOptions): Promise<GetNftSalesResponse>;
  getNftSales(
    options?: GetNftSalesOptionsByContractAddress
  ): Promise<GetNftSalesResponse>;
  getNftSales(
    options?: GetNftSalesOptions | GetNftSalesOptionsByContractAddress
  ): Promise<GetNftSalesResponse> {
    return getNftSales(this.config, options);
  }

  /**
   * Get the rarity of each attribute of an NFT.
   *
   * @param contractAddress - Contract address for the NFT collection.
   * @param tokenId - Token id of the NFT.
   */
  computeRarity(
    contractAddress: string,
    tokenId: BigNumberish
  ): Promise<ComputeRarityResponse> {
    return computeRarity(this.config, contractAddress, tokenId);
  }

  /**
   * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.
   *
   * @param query - The search string that you want to search for in contract metadata.
   */
  searchContractMetadata(
    query: string
  ): Promise<SearchContractMetadataResponse> {
    return searchContractMetadata(this.config, query);
  }

  /**
   * Get a summary of attribute prevalence for an NFT collection.
   *
   * @param contractAddress - Contract address for the NFT collection.
   */
  summarizeNftAttributes(
    contractAddress: string
  ): Promise<NftAttributesResponse> {
    return summarizeNftAttributes(this.config, contractAddress);
  }

  /**
   * Refreshes the cached metadata for a provided NFT contract address and token
   * id. Returns a boolean value indicating whether the metadata was refreshed.
   *
   * This method is useful when you want to refresh the metadata for a NFT that
   * has been updated since the last time it was fetched. Note that the backend
   * only allows one refresh per token every 15 minutes, globally for all users.
   * The last refresh time for an NFT can be accessed on the
   * {@link Nft.timeLastUpdated} field.
   *
   * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.
   *
   * @param contractAddress - The contract address of the NFT.
   * @param tokenId - The token id of the NFT.
   */
  refreshNftMetadata(
    contractAddress: string,
    tokenId: BigNumberish
  ): Promise<boolean> {
    return refreshNftMetadata(this.config, contractAddress, tokenId);
  }

  /**
   * Triggers a metadata refresh all NFTs in the provided contract address. This
   * method is useful after an NFT collection is revealed.
   *
   * Refreshes are queued on the Alchemy backend and may take time to fully
   * process. To refresh the metadata for a specific token, use the
   * {@link refreshNftMetadata} method instead.
   *
   * @param contractAddress - The contract address of the NFT collection.
   * @beta
   */
  refreshContract(contractAddress: string): Promise<RefreshContractResult> {
    return refreshContract(this.config, contractAddress);
  }
}


================================================================================
File: src\api\notify-namespace.ts
Size: 22.42 kB
================================================================================

import { AxiosRequestConfig, Method } from 'axios';

import { BigNumber } from '@ethersproject/bignumber';

import { requestHttpWithBackoff } from '../internal/dispatch';
import {
  RawAddressActivityResponse,
  RawCreateWebhookResponse,
  RawCustomGraphqlWebhookConfig,
  RawGetAllWebhooksResponse,
  RawNftFilterParam,
  RawNftFiltersResponse,
  RawWebhook
} from '../internal/raw-interfaces';
import {
  AddressActivityResponse,
  AddressActivityWebhook,
  AddressWebhookParams,
  AddressWebhookUpdate,
  CustomGraphqlWebhook,
  CustomGraphqlWebhookConfig,
  CustomGraphqlWebhookParams,
  CustomGraphqlWebhookUpdate,
  DroppedTransactionWebhook,
  GetAddressesOptions,
  GetAllWebhooksResponse,
  MinedTransactionWebhook,
  Network,
  NftActivityWebhook,
  NftFilter,
  NftFiltersResponse,
  NftMetadataUpdateWebhook,
  NftMetadataWebhookUpdate,
  NftWebhookParams,
  NftWebhookUpdate,
  TransactionWebhookParams,
  Webhook,
  WebhookType,
  WebhookVersion
} from '../types/types';
import { AlchemyApiType } from '../util/const';
import { AlchemyConfig } from './alchemy-config';

/**
 * The Notify namespace contains methods used for creating, reading, updating,
 * and deleting webhooks in the Notify API.
 *
 * To use the methods in the API, you must provide your team's auth token in the
 * {@link AlchemySettings.authToken} field when configuring
 * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard
 * on the Notify tab.
 *
 * Note that not all networks are supported in the Notify API. Please consult
 * the documentation for which networks are supported.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the notify
 * namespace via `alchemy.notify`.
 */
export class NotifyNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Get all webhooks on your team.
   *
   * The team is determined by the `authToken` provided into the {@link AlchemySettings}
   * object when creating a new {@link Alchemy} instance.
   *
   * This method returns a response object containing all the webhooks
   */
  async getAllWebhooks(): Promise<GetAllWebhooksResponse> {
    this.verifyConfig();
    const response = await this.sendWebhookRequest<RawGetAllWebhooksResponse>(
      'team-webhooks',
      'getAllWebhooks',
      {}
    );
    return {
      webhooks: parseRawWebhookResponse(response),
      totalCount: response.data.length
    };
  }

  /**
   * Get all addresses tracked for the provided {@link AddressActivityWebhook}.
   *
   * @param addressWebhook The Address Activity webhook.
   * @param options Pagination options when fetching addresses.
   */
  getAddresses(
    addressWebhook: AddressActivityWebhook,
    options?: GetAddressesOptions
  ): Promise<AddressActivityResponse>;

  /**
   * Get all addresses tracked for the provided {@link AddressActivityWebhook}.
   *
   * @param webhookId The id of the address activity webhook. Passing in an id
   *   of a non-address-activity webhook will result in a response object with
   *   no addresses.
   * @param options Pagination options when fetching addresses.
   */
  getAddresses(
    webhookId: string,
    options?: GetAddressesOptions
  ): Promise<AddressActivityResponse>;
  async getAddresses(
    webhookOrId: AddressActivityWebhook | string,
    options?: GetAddressesOptions
  ): Promise<AddressActivityResponse> {
    this.verifyConfig();
    const webhookId =
      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;
    const response = await this.sendWebhookRequest<RawAddressActivityResponse>(
      'webhook-addresses',
      'getAddresses',
      {
        webhook_id: webhookId,
        limit: options?.limit,
        after: options?.pageKey
      }
    );
    return parseRawAddressActivityResponse(response);
  }

  /**
   * Get the graphql query used for the provided {@link CustomGraphqlWebhook}.
   *
   * @param customGraphqlWebhook The webhook to get the graphql query for.
   */
  getGraphqlQuery(
    customGraphqlWebhook: CustomGraphqlWebhook
  ): Promise<CustomGraphqlWebhookConfig>;

  /**
   * Get the graphql query used for the provided {@link CustomGraphqlWebhook}.
   *
   * @param webhookId The id of the custom webhook. Passing in an id
   *   of a non-custom webhook will result in a response object with
   *   no graphql query.
   */
  getGraphqlQuery(webhookId: string): Promise<CustomGraphqlWebhookConfig>;
  async getGraphqlQuery(
    webhookOrId: CustomGraphqlWebhook | string
  ): Promise<CustomGraphqlWebhookConfig> {
    this.verifyConfig();
    const webhookId =
      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;
    const response =
      await this.sendWebhookRequest<RawCustomGraphqlWebhookConfig>(
        'dashboard-webhook-graphql-query',
        'getGraphqlQuery',
        {
          webhook_id: webhookId
        }
      );
    return parseRawCustomGraphqlWebhookResponse(response);
  }

  /**
   * Get all NFTs tracked for the provided {@link NftActivityWebhook}.
   *
   * @param nftWebhook The NFT Activity webhook.
   * @param options Pagination options when fetching NFT filters.
   */
  getNftFilters(
    nftWebhook: NftActivityWebhook,
    options?: GetAddressesOptions
  ): Promise<NftFiltersResponse>;

  /**
   * Get all NFT filters tracked for the provided {@link NftActivityWebhook}.
   *
   * @param webhookId The id of the NFT activity webhook. Passing in an
   *   incorrect id of a non-NFT webhook will result in a response object with
   *   no filters.
   * @param options Pagination options when fetching nft filters.
   */
  getNftFilters(
    webhookId: string,
    options?: GetAddressesOptions
  ): Promise<NftFiltersResponse>;
  async getNftFilters(
    webhookOrId: NftActivityWebhook | string,
    options?: GetAddressesOptions
  ): Promise<NftFiltersResponse> {
    this.verifyConfig();
    const webhookId =
      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;
    const response = await this.sendWebhookRequest<RawNftFiltersResponse>(
      'webhook-nft-filters',
      'getNftFilters',
      {
        webhook_id: webhookId,
        limit: options?.limit,
        after: options?.pageKey
      }
    );
    return parseRawNftFiltersResponse(response);
  }

  /**
   * Update a {@link NftActivityWebhook}'s active status or NFT filters.
   *
   * @param nftWebhook The NFT activity webhook to update.
   * @param update Object containing the update.
   */
  updateWebhook(
    nftWebhook: NftActivityWebhook,
    update: NftWebhookUpdate
  ): Promise<void>;

  /**
   * Update a {@link NftActivityWebhook}'s active status or NFT filters.
   *
   * @param nftWebhookId The id of the NFT activity webhook.
   * @param update Object containing the update.
   */
  updateWebhook(nftWebhookId: string, update: NftWebhookUpdate): Promise<void>;

  /**
   * Update a {@link NftMetadataUpdateWebhook}'s active status or NFT filters.
   *
   * @param nftMetadataWebhookId The id of the NFT activity webhook.
   * @param update Object containing the update.
   */
  updateWebhook(
    nftMetadataWebhookId: string,
    update: NftMetadataWebhookUpdate
  ): Promise<void>;

  /**
   * Update a {@link CustomGraphqlWebhook}'s active status.
   * The graphql query associated with the webhook is immutable.
   *
   * @param customGraphqlWebhookId The id of the custom webhook.
   * @param update Object containing the update.
   */
  updateWebhook(
    customGraphqlWebhookId: string,
    update: CustomGraphqlWebhookUpdate
  ): Promise<void>;

  /**
   * Update a {@link AddressActivityWebhook}'s active status or addresses.
   *
   * @param addressWebhook The address activity webhook to update.
   * @param update Object containing the update.
   */
  updateWebhook(
    addressWebhook: AddressActivityWebhook,
    update: AddressWebhookUpdate
  ): Promise<void>;

  /**
   * Update a {@link AddressActivityWebhook}'s active status or addresses.
   *
   * @param addressWebhookId The id of the address activity webhook.
   * @param update Object containing the update.
   */
  updateWebhook(
    addressWebhookId: string,
    update: AddressWebhookUpdate
  ): Promise<void>;
  async updateWebhook(
    webhookOrId: NftActivityWebhook | AddressActivityWebhook | string,
    update:
      | NftWebhookUpdate
      | AddressWebhookUpdate
      | NftMetadataWebhookUpdate
      | CustomGraphqlWebhookUpdate
  ): Promise<void> {
    const webhookId =
      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;
    let restApiName;
    let methodName;
    let method: Method;
    let data;
    if ('isActive' in update) {
      restApiName = 'update-webhook';
      methodName = 'updateWebhook';
      method = 'PUT';
      data = {
        webhook_id: webhookId,
        is_active: update.isActive
      };
    } else if ('addFilters' in update || 'removeFilters' in update) {
      restApiName = 'update-webhook-nft-filters';
      methodName = 'updateWebhookNftFilters';
      method = 'PATCH';
      data = {
        webhook_id: webhookId,
        nft_filters_to_add: update.addFilters
          ? update.addFilters.map(nftFilterToParam)
          : [],
        nft_filters_to_remove: update.removeFilters
          ? update.removeFilters.map(nftFilterToParam)
          : []
      };
    } else if (
      'addMetadataFilters' in update ||
      'removeMetadataFilters' in update
    ) {
      restApiName = 'update-webhook-nft-metadata-filters';
      methodName = 'updateWebhookNftMetadataFilters';
      method = 'PATCH';
      data = {
        webhook_id: webhookId,
        nft_metadata_filters_to_add: update.addMetadataFilters
          ? update.addMetadataFilters.map(nftFilterToParam)
          : [],
        nft_metadata_filters_to_remove: update.removeMetadataFilters
          ? update.removeMetadataFilters.map(nftFilterToParam)
          : []
      };
    } else if ('addAddresses' in update || 'removeAddresses' in update) {
      restApiName = 'update-webhook-addresses';
      methodName = 'webhook:updateWebhookAddresses';
      method = 'PATCH';
      data = {
        webhook_id: webhookId,
        addresses_to_add: await this.resolveAddresses(update.addAddresses),
        addresses_to_remove: await this.resolveAddresses(update.removeAddresses)
      };
    } else if ('newAddresses' in update) {
      restApiName = 'update-webhook-addresses';
      methodName = 'webhook:updateWebhookAddress';
      method = 'PUT';
      data = {
        webhook_id: webhookId,
        addresses: await this.resolveAddresses(update.newAddresses)
      };
    } else {
      throw new Error('Invalid `update` param passed into `updateWebhook`');
    }

    await this.sendWebhookRequest(
      restApiName,
      methodName,
      {},
      {
        method,
        data
      }
    );
  }
  /**
   * Create a new {@link CustomGraphqlWebhook} to track any event on every block.
   *
   * @param url The URL that the webhook should send events to.
   * @param type The type of webhook to create.
   * @param params Parameters object containing the graphql query to be executed
   * on every block
   */
  createWebhook(
    url: string,
    type: WebhookType.GRAPHQL,
    params: CustomGraphqlWebhookParams
  ): Promise<CustomGraphqlWebhook>;

  /**
   * Create a new {@link MinedTransactionWebhook} to track mined transactions
   * sent by the app associated with the app id.
   *
   * Note that the webhook will be created in the app network of the provided app id.
   *
   * @param url The URL that the webhook should send events to.
   * @param type The type of webhook to create.
   * @param params Parameters object containing the app id.
   */
  // TODO(webhook): Automatically populate app id from api key.
  createWebhook(
    url: string,
    type: WebhookType.MINED_TRANSACTION,
    params: TransactionWebhookParams
  ): Promise<MinedTransactionWebhook>;

  /**
   * Create a new {@link DroppedTransactionWebhook} to track dropped transactions
   * sent by the app associated with the app id.
   *
   * Note that the webhook will be created in the app network of the provided app id.
   *
   * @param url The URL that the webhook should send events to.
   * @param type The type of webhook to create.
   * @param params Parameters object containing the app id.
   */
  // TODO(webhook): Automatically populate app id from api key.
  createWebhook(
    url: string,
    type: WebhookType.DROPPED_TRANSACTION,
    params: TransactionWebhookParams
  ): Promise<DroppedTransactionWebhook>;

  /**
   * Create a new {@link NftActivityWebhook} to track NFT transfers.
   *
   * @param url The URL that the webhook should send events to.
   * @param type The type of webhook to create.
   * @param params Parameters object containing the NFTs to track and the
   *   network the webhook should be created on.
   */
  createWebhook(
    url: string,
    type: WebhookType.NFT_ACTIVITY,
    params: NftWebhookParams
  ): Promise<NftActivityWebhook>;

  createWebhook(
    url: string,
    type: WebhookType.NFT_METADATA_UPDATE,
    params: NftWebhookParams
  ): Promise<NftMetadataUpdateWebhook>;

  /**
   * Create a new {@link AddressActivityWebhook} to track address activity.
   *
   * @param url The URL that the webhook should send events to.
   * @param type The type of webhook to create.
   * @param params Parameters object containing the addresses to track and the
   *   network the webhook should be created on.
   */
  createWebhook(
    url: string,
    type: WebhookType.ADDRESS_ACTIVITY,
    params: AddressWebhookParams
  ): Promise<AddressActivityWebhook>;
  async createWebhook(
    url: string,
    type: WebhookType,
    params:
      | NftWebhookParams
      | AddressWebhookParams
      | TransactionWebhookParams
      | CustomGraphqlWebhookParams
  ): Promise<
    | MinedTransactionWebhook
    | DroppedTransactionWebhook
    | NftActivityWebhook
    | AddressActivityWebhook
    | NftMetadataUpdateWebhook
    | CustomGraphqlWebhook
  > {
    let appId;
    if (
      type === WebhookType.MINED_TRANSACTION ||
      type === WebhookType.DROPPED_TRANSACTION ||
      type === WebhookType.GRAPHQL
    ) {
      if (!('appId' in params)) {
        throw new Error('Transaction and GraphQL Webhooks require an app id.');
      }
      appId = params.appId;
    }

    let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);
    let nftFilterObj;
    let addresses;
    let graphqlQuery;
    let skipEmptyMessages;
    if (
      type === WebhookType.NFT_ACTIVITY ||
      type === WebhookType.NFT_METADATA_UPDATE
    ) {
      if (!('filters' in params) || params.filters.length === 0) {
        throw new Error(
          'Nft Activity Webhooks require a non-empty array input.'
        );
      }
      network = params.network
        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)
        : network;
      const filters = (params.filters as NftFilter[]).map(filter =>
        filter.tokenId
          ? {
              contract_address: filter.contractAddress,
              token_id: BigNumber.from(filter.tokenId).toString()
            }
          : {
              contract_address: filter.contractAddress
            }
      );
      nftFilterObj =
        type === WebhookType.NFT_ACTIVITY
          ? { nft_filters: filters }
          : { nft_metadata_filters: filters };
    } else if (type === WebhookType.ADDRESS_ACTIVITY) {
      if (
        params === undefined ||
        !('addresses' in params) ||
        params.addresses.length === 0
      ) {
        throw new Error(
          'Address Activity Webhooks require a non-empty array input.'
        );
      }
      network = params.network
        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)
        : network;
      addresses = await this.resolveAddresses(params.addresses);
    } else if (type == WebhookType.GRAPHQL) {
      if (
        params === undefined ||
        !('graphqlQuery' in params) ||
        params.graphqlQuery.length === 0
      ) {
        throw new Error('Custom Webhooks require a non-empty graphql query.');
      }
      network = params.network
        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)
        : network;
      graphqlQuery = params.graphqlQuery;
      skipEmptyMessages = params.skipEmptyMessages;
    }

    const data = {
      network,
      webhook_type: type,
      webhook_url: url,
      ...(appId && { app_id: appId }),

      // Only include the filters/addresses in the final response if they're defined
      ...nftFilterObj,
      ...(addresses && { addresses }),
      ...(graphqlQuery && {
        graphql_query: {
          query: graphqlQuery,
          skip_empty_messages: !!skipEmptyMessages
        }
      })
    };

    const response = await this.sendWebhookRequest<RawCreateWebhookResponse>(
      'create-webhook',
      'createWebhook',
      {},
      {
        method: 'POST',
        data
      }
    );

    return parseRawWebhook(response.data);
  }

  /**
   * Delete the provided webhook.
   *
   * @param webhook The webhook to delete.
   */
  deleteWebhook(webhook: Webhook): Promise<void>;

  /**
   * Delete the provided webhook.
   *
   * @param webhookId The id of the webhook to delete.
   */
  deleteWebhook(webhookId: string): Promise<void>;
  async deleteWebhook(webhookOrId: Webhook | string): Promise<void> {
    this.verifyConfig();
    const webhookId =
      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;
    const response = await this.sendWebhookRequest<RawNftFiltersResponse>(
      'delete-webhook',
      'deleteWebhook',
      {
        webhook_id: webhookId
      },
      {
        method: 'DELETE'
      }
    );

    if ('message' in response) {
      throw new Error(
        `Webhook not found. Failed to delete webhook: ${webhookId}`
      );
    }
  }

  private verifyConfig() {
    if (this.config.authToken === undefined) {
      throw new Error(
        'Using the Notify API requires setting the Alchemy Auth Token in ' +
          'the settings object when initializing Alchemy.'
      );
    }
  }

  private sendWebhookRequest<Response>(
    restApiName: string,
    methodName: string,
    params: {},
    overrides?: AxiosRequestConfig
  ): Promise<Response> {
    return requestHttpWithBackoff(
      this.config,
      AlchemyApiType.WEBHOOK,
      restApiName,
      methodName,
      params,
      {
        ...overrides,
        headers: {
          'X-Alchemy-Token': this.config.authToken!,
          ...overrides?.headers
        }
      }
    );
  }

  /** Resolves ENS addresses to the raw address.
   * @internal */
  private async resolveAddresses(
    addresses: string[] | undefined
  ): Promise<string[]> {
    if (addresses === undefined) {
      return [];
    }
    const resolvedAddresses: string[] = [];
    const provider = await this.config.getProvider();
    for (const address of addresses) {
      const rawAddress = await provider.resolveName(address);
      if (rawAddress === null) {
        throw new Error(`Unable to resolve the ENS address: ${address}`);
      }
      resolvedAddresses.push(rawAddress);
    }

    return resolvedAddresses;
  }
}

/**
 * Mapping of webhook network representations to the SDK's network representation.
 *
 * @internal
 */
const WEBHOOK_NETWORK_TO_NETWORK: { [key: string]: Network } =
  Object.fromEntries(Object.entries(Network));

/** Mapping of the SDK's network representation the webhook API's network representation. */
const NETWORK_TO_WEBHOOK_NETWORK: Map<Network, string> = Object.keys(
  Network
).reduce((map: Map<Network, string>, key) => {
  if (key in WEBHOOK_NETWORK_TO_NETWORK) {
    map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);
  }
  return map;
}, new Map());

function parseRawWebhookResponse(
  response: RawGetAllWebhooksResponse
): Webhook[] {
  return response.data.map(parseRawWebhook);
}

function parseRawWebhook(rawWebhook: RawWebhook): Webhook {
  return {
    id: rawWebhook.id,
    network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],
    type: rawWebhook.webhook_type as WebhookType,
    url: rawWebhook.webhook_url,
    isActive: rawWebhook.is_active,
    timeCreated: new Date(rawWebhook.time_created).toISOString(),
    signingKey: rawWebhook.signing_key,
    version: rawWebhook.version as WebhookVersion,
    // Only include the appId in the final response if it's defined
    ...(rawWebhook.app_id !== undefined && { appId: rawWebhook.app_id })
  };
}

function parseRawAddressActivityResponse(
  response: RawAddressActivityResponse
): AddressActivityResponse {
  return {
    addresses: response.data,
    totalCount: response.pagination.total_count,
    pageKey: response.pagination.cursors.after
  };
}

function parseRawCustomGraphqlWebhookResponse(
  response: RawCustomGraphqlWebhookConfig
): CustomGraphqlWebhookConfig {
  return {
    graphqlQuery: response.data.graphql_query
  };
}

function parseRawNftFiltersResponse(
  response: RawNftFiltersResponse
): NftFiltersResponse {
  return {
    filters: response.data.map(f =>
      f.token_id
        ? {
            contractAddress: f.contract_address,
            tokenId: BigNumber.from(f.token_id).toString()
          }
        : {
            contractAddress: f.contract_address
          }
    ),
    totalCount: response.pagination.total_count,
    pageKey: response.pagination.cursors.after
  };
}

function nftFilterToParam(filter: NftFilter): RawNftFilterParam {
  return filter.tokenId
    ? {
        contract_address: filter.contractAddress,
        token_id: BigNumber.from(filter.tokenId).toString()
      }
    : {
        contract_address: filter.contractAddress
      };
}


================================================================================
File: src\api\prices-namespace.ts
Size: 3.34 kB
================================================================================

import {
  getHistoricalPriceByAddress,
  getHistoricalPriceBySymbol,
  getTokenPriceByAddress,
  getTokenPriceBySymbol
} from '../internal/prices-api';
import {
  GetTokenPriceByAddressResponse,
  GetTokenPriceBySymbolResponse,
  HistoricalPriceByAddressResponse,
  HistoricalPriceBySymbolResponse,
  HistoricalPriceInterval,
  TokenAddressRequest
} from '../types/prices-types';
import { Network } from '../types/types';
import { AlchemyConfig } from './alchemy-config';

/**
 * The Prices namespace contains methods for getting token price data.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the prices namespace
 * via `alchemy.prices`.
 */
export class PricesNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Get token prices by network and contract address pairs.
   *
   * @param addresses - Array of network/address pairs to get prices for
   * @returns Promise containing token price data
   * @public
   */
  getTokenPriceByAddress(
    addresses: TokenAddressRequest[]
  ): Promise<GetTokenPriceByAddressResponse> {
    return getTokenPriceByAddress(this.config, addresses);
  }

  /**
   * Get token prices by token symbol.
   *
   * @param symbols - Array of token symbols to get prices for
   * @returns Promise containing token price data
   * @public
   */
  getTokenPriceBySymbol(
    symbols: string[]
  ): Promise<GetTokenPriceBySymbolResponse> {
    return getTokenPriceBySymbol(this.config, symbols);
  }

  /**
   * Get historical token prices by token symbol.
   *
   * @param symbol - The token symbol to get historical prices for
   * @param startTime - Start time in ISO-8601 string format or Unix timestamp in seconds
   * @param endTime - End time in ISO-8601 string format or Unix timestamp in seconds
   * @param interval - Time interval between data points
   * @returns Promise containing historical token price data
   * @public
   */
  getHistoricalPriceBySymbol(
    symbol: string,
    startTime: string | number,
    endTime: string | number,
    interval: HistoricalPriceInterval
  ): Promise<HistoricalPriceBySymbolResponse> {
    return getHistoricalPriceBySymbol(
      this.config,
      symbol,
      startTime,
      endTime,
      interval
    );
  }

  /**
   * Get historical token prices by network and contract address.
   *
   * @param network - The network where the token contract is deployed
   * @param address - The token contract address
   * @param startTime - Start time in ISO-8601 string format or Unix timestamp in seconds
   * @param endTime - End time in ISO-8601 string format or Unix timestamp in seconds
   * @param interval - Time interval between data points
   * @returns Promise containing historical token price data
   * @public
   */
  getHistoricalPriceByAddress(
    network: Network,
    address: string,
    startTime: string | number,
    endTime: string | number,
    interval: HistoricalPriceInterval
  ): Promise<HistoricalPriceByAddressResponse> {
    return getHistoricalPriceByAddress(
      this.config,
      network,
      address,
      startTime,
      endTime,
      interval
    );
  }
}


================================================================================
File: src\api\transact-namespace.ts
Size: 16.41 kB
================================================================================

import {
  TransactionReceipt,
  TransactionRequest,
  TransactionResponse
} from '@ethersproject/abstract-provider';
import type { BigNumber } from '@ethersproject/bignumber';
import { Deferrable } from '@ethersproject/properties';

import {
  BlockIdentifier,
  DebugTransaction,
  GasOptimizedTransactionResponse,
  GasOptimizedTransactionStatusResponse,
  SendPrivateTransactionOptions,
  SimulateAssetChangesResponse,
  SimulateExecutionResponse
} from '../types/types';
import { nullsToUndefined } from '../util/util';
import { AlchemyConfig } from './alchemy-config';
import { Wallet } from './alchemy-wallet';
import { fromHex, toHex } from './util';

/**
 * Multiples to increment fee per gas when using
 * {@link TransactNamespace.sendGasOptimizedTransaction}.
 *
 * @internal
 */
export const GAS_OPTIMIZED_TX_FEE_MULTIPLES = [0.9, 1, 1.1, 1.2, 1.3];

/**
 * The Transact namespace contains methods used for sending transactions and
 * checking on the state of submitted transactions.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the transact
 * namespace via `alchemy.transact`.
 */
export class TransactNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Used to send a single transaction to Flashbots. Flashbots will attempt to
   * send the transaction to miners for the next 25 blocks.
   *
   * Returns the transaction hash of the submitted transaction.
   *
   * @param signedTransaction The raw, signed transaction as a hash.
   * @param maxBlockNumber Optional highest block number in which the
   *   transaction should be included.
   * @param options Options to configure the request.
   */
  async sendPrivateTransaction(
    signedTransaction: string,
    maxBlockNumber?: number,
    options?: SendPrivateTransactionOptions
  ): Promise<string> {
    const provider = await this.config.getProvider();
    const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;
    return provider._send(
      'eth_sendPrivateTransaction',
      [
        {
          tx: signedTransaction,
          maxBlockNumber: hexBlockNumber,
          preferences: options
        }
      ],
      'sendPrivateTransaction'
    );
  }

  /**
   * Stops the provided private transaction from being submitted for future
   * blocks. A transaction can only be cancelled if the request is signed by the
   * same key as the {@link sendPrivateTransaction} call submitting the
   * transaction in first place.
   *
   * Please note that fast mode transactions cannot be cancelled using this method.
   *
   * Returns a boolean indicating whether the cancellation was successful.
   *
   * @param transactionHash Transaction hash of private tx to be cancelled
   */
  async cancelPrivateTransaction(transactionHash: string): Promise<boolean> {
    const provider = await this.config.getProvider();
    return provider._send(
      'eth_cancelPrivateTransaction',
      [
        {
          txHash: transactionHash
        }
      ],
      'cancelPrivateTransaction'
    );
  }

  /**
   * Simulates the asset changes resulting from a list of transactions simulated
   * in sequence.
   *
   * Returns a list of asset changes for each transaction during simulation.
   *
   * @param transactions Transactions list of max 3 transactions to simulate.
   * @param blockIdentifier Optional block identifier to simulate the
   * transaction in.
   */
  async simulateAssetChangesBundle(
    transactions: DebugTransaction[],
    blockIdentifier?: BlockIdentifier
  ): Promise<SimulateAssetChangesResponse[]> {
    const provider = await this.config.getProvider();
    const params =
      blockIdentifier !== undefined
        ? [transactions, blockIdentifier]
        : [transactions];
    const res = await provider._send(
      'alchemy_simulateAssetChangesBundle',
      params,
      'simulateAssetChangesBundle'
    );
    return nullsToUndefined(res);
  }

  /**
   * Simulates the asset changes resulting from a single transaction.
   *
   * Returns list of asset changes that occurred during the transaction
   * simulation. Note that this method does not run the transaction on the
   * blockchain.
   *
   * @param transaction The transaction to simulate.
   * @param blockIdentifier Optional block identifier to simulate the
   * transaction in.
   */
  async simulateAssetChanges(
    transaction: DebugTransaction,
    blockIdentifier?: BlockIdentifier
  ): Promise<SimulateAssetChangesResponse> {
    const provider = await this.config.getProvider();
    const params =
      blockIdentifier !== undefined
        ? [transaction, blockIdentifier]
        : [transaction];
    const res = await provider._send(
      'alchemy_simulateAssetChanges',
      params,
      'simulateAssetChanges'
    );
    return nullsToUndefined(res);
  }

  /**
   * Simulates a list of transactions in sequence and returns list of decoded
   * traces and logs that occurred for each transaction during simulation.
   *
   * Note that this method does not run any transactions on the blockchain.
   *
   * @param transactions Transactions list of max 3 transactions to simulate.
   * @param blockIdentifier Optional block identifier to simulate the
   * transaction in.
   */
  async simulateExecutionBundle(
    transactions: DebugTransaction[],
    blockIdentifier?: BlockIdentifier
  ): Promise<SimulateExecutionResponse[]> {
    const provider = await this.config.getProvider();
    const params =
      blockIdentifier !== undefined
        ? [transactions, blockIdentifier]
        : [transactions];
    const res = provider._send(
      'alchemy_simulateExecutionBundle',
      params,
      'simulateExecutionBundle'
    );
    return nullsToUndefined(res);
  }

  /**
   * Simulates a single transaction and the resulting and returns list of
   * decoded traces and logs that occurred during the transaction simulation.
   *
   * Note that this method does not run the transaction on the blockchain.
   *
   * @param transaction The transaction to simulate.
   * @param blockIdentifier Optional block identifier to simulate the
   * transaction in.
   */
  async simulateExecution(
    transaction: DebugTransaction,
    blockIdentifier?: BlockIdentifier
  ): Promise<SimulateExecutionResponse> {
    const provider = await this.config.getProvider();
    const params =
      blockIdentifier !== undefined
        ? [transaction, blockIdentifier]
        : [transaction];
    const res = provider._send(
      'alchemy_simulateExecution',
      params,
      'simulateExecution'
    );
    return nullsToUndefined(res);
  }

  /**
   * Returns the transaction with hash or null if the transaction is unknown.
   *
   * If a transaction has not been mined, this method will search the
   * transaction pool. Various backends may have more restrictive transaction
   * pool access (e.g. if the gas price is too low or the transaction was only
   * recently sent and not yet indexed) in which case this method may also return null.
   *
   * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.
   *
   * @param transactionHash The hash of the transaction to get.
   * @public
   */
  async getTransaction(
    transactionHash: string | Promise<string>
  ): Promise<TransactionResponse | null> {
    const provider = await this.config.getProvider();
    return provider.getTransaction(transactionHash);
  }

  /**
   * Submits transaction to the network to be mined. The transaction must be
   * signed, and be valid (i.e. the nonce is correct and the account has
   * sufficient balance to pay for the transaction).
   *
   * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.
   *
   * @param signedTransaction The signed transaction to send.
   * @public
   */
  async sendTransaction(
    signedTransaction: string | Promise<string>
  ): Promise<TransactionResponse> {
    const provider = await this.config.getProvider();
    return provider.sendTransaction(signedTransaction);
  }

  /**
   * Returns an estimate of the amount of gas that would be required to submit
   * transaction to the network.
   *
   * An estimate may not be accurate since there could be another transaction on
   * the network that was not accounted for, but after being mined affects the
   * relevant state.
   *
   * This is an alias for {@link CoreNamespace.estimateGas}.
   *
   * @param transaction The transaction to estimate gas for.
   * @public
   */
  async estimateGas(
    transaction: Deferrable<TransactionRequest>
  ): Promise<BigNumber> {
    const provider = await this.config.getProvider();
    return provider.estimateGas(transaction);
  }

  /**
   * Returns a fee per gas (in wei) that is an estimate of how much you can pay
   * as a priority fee, or "tip", to get a transaction included in the current block.
   *
   * This number is generally used to set the `maxPriorityFeePerGas` field in a
   * transaction request.
   *
   * @public
   */
  async getMaxPriorityFeePerGas(): Promise<number> {
    const provider = await this.config.getProvider();
    const feeHex = await provider._send(
      'eth_maxPriorityFeePerGas',
      [],
      'getMaxPriorityFeePerGas'
    );
    return fromHex(feeHex);
  }

  /**
   * Returns a promise which will not resolve until specified transaction hash is mined.
   *
   * If {@link confirmations} is 0, this method is non-blocking and if the
   * transaction has not been mined returns null. Otherwise, this method will
   * block until the transaction has confirmed blocks mined on top of the block
   * in which it was mined.
   *
   * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.
   *
   * @param transactionHash The hash of the transaction to wait for.
   * @param confirmations The number of blocks to wait for.
   * @param timeout The maximum time to wait for the transaction to confirm.
   * @public
   */
  async waitForTransaction(
    transactionHash: string,
    confirmations?: number,
    timeout?: number
  ): Promise<TransactionReceipt | null> {
    const provider = await this.config.getProvider();
    return provider.waitForTransaction(transactionHash, confirmations, timeout);
  }

  /**
   * Instead of sending a single transaction that might not get mined, this
   * method allows you to send the same transaction multiple times, with
   * different gas prices and gas limits. This should result in lower fees paid.
   *
   * Alchemy will submit the cheapest transaction, and if it does not get mined,
   * the next cheapest transaction will be submitted. This process will continue
   * until one of the transactions is mined, or until all transactions are rejected.
   *
   * To have Alchemy automatically generate a fee and gas spread, pass in a
   * {@link TransactionRequest} object and a {@link Wallet} as a signer.
   *
   * This method returns a response object containing the transaction hash for
   * each of the signed transactions and a transaction job id that can be used
   * to track the state of the transaction job.
   *
   * @param signedTransactions An array of signed transactions to send. Each
   *   transaction in the array must have the same values, but with different
   *   gas and fee values.
   * @internal
   */
  // TODO(txjob): Remove internal tag once this feature is released.
  async sendGasOptimizedTransaction(
    signedTransactions: string[]
  ): Promise<GasOptimizedTransactionResponse>;

  /**
   * Instead of sending a single transaction that might not get mined, this
   * method will generate a series of five EIP-1559 transactions with different
   * gas prices in order to minimize the final fees paid.
   *
   * Alchemy will submit the cheapest transaction, and if it does not get mined,
   * the next cheapest transaction will be submitted. This process will continue
   * until one of the transactions is mined, or until all transactions are rejected.
   *
   * To calculate the fee, gas, and gas spread for each transaction, this method
   * first calculates the base fee from the latest block, estimates the gas for
   * the transaction, and then calculates the fee and gas spread for the
   * transaction. The five transactions will have 90%, 100%, 110%, 120%, and
   * 130% of the max priority fee per gas.
   *
   * Note that you can also pass in an array of pre-signed transactions with set
   * gas levels for more granular control over gas.
   *
   * This method returns a response object containing the transaction hash for
   * each of the signed transactions and a transaction job id that can be used
   * to track the state of the transaction job.
   *
   * @param transaction The raw transaction to send.
   * @param wallet A wallet to use to sign the transaction.
   * @internal
   */
  // TODO(txjob): Remove internal tag once this feature is released.
  async sendGasOptimizedTransaction(
    transaction: TransactionRequest,
    wallet: Wallet
  ): Promise<GasOptimizedTransactionResponse>;
  async sendGasOptimizedTransaction(
    transactionOrSignedTxs: TransactionRequest | string[],
    wallet?: Wallet
  ): Promise<GasOptimizedTransactionResponse> {
    if (Array.isArray(transactionOrSignedTxs)) {
      return this._sendGasOptimizedTransaction(
        transactionOrSignedTxs,
        'sendGasOptimizedTransactionPreSigned'
      );
    }

    let gasLimit;
    let priorityFee;
    let baseFee;
    const provider = await this.config.getProvider();
    try {
      gasLimit = await this.estimateGas(transactionOrSignedTxs);
      priorityFee = await this.getMaxPriorityFeePerGas();
      const currentBlock = await provider.getBlock('latest');
      baseFee = currentBlock.baseFeePerGas!.toNumber();
    } catch (e) {
      throw new Error(`Failed to estimate gas for transaction: ${e}`);
    }

    const gasSpreadTransactions = generateGasSpreadTransactions(
      transactionOrSignedTxs,
      gasLimit.toNumber(),
      baseFee,
      priorityFee
    );
    const signedTransactions = await Promise.all(
      gasSpreadTransactions.map(tx => wallet!.signTransaction(tx))
    );

    return this._sendGasOptimizedTransaction(
      signedTransactions,
      'sendGasOptimizedTransactionGenerated'
    );
  }

  /**
   * Returns the state of the transaction job returned by the
   * {@link sendGasOptimizedTransaction}.
   *
   * @param trackingId The tracking id from the response of the sent gas optimized transaction.
   * @internal
   */
  // TODO(txjob): Remove internal tag once this feature is released.
  async getGasOptimizedTransactionStatus(
    trackingId: string
  ): Promise<GasOptimizedTransactionStatusResponse> {
    const provider = await this.config.getProvider();
    return provider._send(
      'alchemy_getGasOptimizedTransactionStatus',
      [trackingId],
      'getGasOptimizedTransactionStatus'
    );
  }

  /** @internal */
  private async _sendGasOptimizedTransaction(
    signedTransactions: string[],
    methodName: string
  ): Promise<GasOptimizedTransactionResponse> {
    const provider = await this.config.getProvider();
    return provider._send(
      'alchemy_sendGasOptimizedTransaction',
      [
        {
          rawTransactions: signedTransactions
        }
      ],
      methodName
    );
  }
}

/**
 * Helper method to generate the raw transaction with the given gas limit and
 * priority fee across a spread of different gas prices.
 *
 * @internal
 */
// Visible for testing
export function generateGasSpreadTransactions(
  transaction: TransactionRequest,
  gasLimit: number,
  baseFee: number,
  priorityFee: number
): TransactionRequest[] {
  return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map(feeMultiplier => {
    return {
      ...transaction,
      gasLimit,
      maxFeePerGas: Math.round(
        baseFee * feeMultiplier + priorityFee * feeMultiplier
      ),
      maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)
    };
  });
}


================================================================================
File: src\api\util.ts
Size: 729 B
================================================================================

import { BigNumber } from '@ethersproject/bignumber';

/**
 * Converts a hex string to a decimal number.
 *
 * @param hexString - The hex string to convert.
 * @public
 */
export function fromHex(hexString: string): number {
  return BigNumber.from(hexString).toNumber();
}

/**
 * Converts a number to a hex string.
 *
 * @param num - The number to convert to hex.
 * @public
 */
export function toHex(num: number): string {
  return BigNumber.from(num).toHexString();
}

/**
 * Checks if a value is a hex string.
 *
 * @param possibleHexString - The value to check.
 * @public
 */
export function isHex(possibleHexString: string): boolean {
  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);
}


================================================================================
File: src\api\utils.ts
Size: 630 B
================================================================================

'use strict';
export {
  dnsEncode,
  hashMessage,
  id,
  isValidName,
  namehash
} from '@ethersproject/hash';

export {
  arrayify,
  concat,
  hexConcat,
  hexDataSlice,
  hexDataLength,
  hexlify,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  isBytes,
  isBytesLike,
  isHexString,
  joinSignature,
  zeroPad,
  splitSignature,
  stripZeros
} from '@ethersproject/bytes';

export {
  formatEther,
  parseEther,
  parseUnits,
  formatUnits
} from '@ethersproject/units';

export { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';

export { Interface } from '@ethersproject/abi';


================================================================================
File: src\api\websocket-namespace.ts
Size: 7.01 kB
================================================================================

import type { Listener } from '@ethersproject/abstract-provider';

import { isAlchemyEvent } from '../internal/ethers-event';
import {
  AlchemyEventType,
  AlchemyMinedTransactionsAddress,
  AlchemySubscription,
  NonEmptyArray
} from '../types/types';
import { AlchemyConfig } from './alchemy-config';

/**
 * The Websocket namespace contains all subscription related functions that
 * allow you to subscribe to events and receive updates as they occur. The
 * underlying WebSocket provider has additional logic to handle reconnections
 * and automatically backfills missed events.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the core namespace
 * via `alchemy.ws`.
 */
export class WebSocketNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Adds a listener to be triggered for each {@link eventName} event. Also
   * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for
   * how to use them.
   *
   * @param eventName The event to listen for.
   * @param listener The listener to call when the event is triggered.
   * @public
   */
  on(eventName: AlchemyEventType, listener: Listener): this {
    void (async () => {
      const provider = await this.config.getWebSocketProvider();
      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);
      provider.on(processedEvent, listener);
    })();
    return this;
  }

  /**
   * Adds a listener to be triggered for only the next {@link eventName} event,
   * after which it will be removed. Also includes Alchemy's Subscription API
   * events. See {@link AlchemyEventType} for how to use them.
   *
   * @param eventName The event to listen for.
   * @param listener The listener to call when the event is triggered.
   * @public
   */
  once(eventName: AlchemyEventType, listener: Listener): this {
    void (async () => {
      const provider = await this.config.getWebSocketProvider();
      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);
      provider.once(processedEvent, listener);
    })();
    return this;
  }

  /**
   * Removes the provided {@link listener} for the {@link eventName} event. If no
   * listener is provided, all listeners for the event will be removed.
   *
   * @param eventName The event to unlisten to.
   * @param listener The listener to remove.
   * @public
   */
  off(eventName: AlchemyEventType, listener?: Listener): this {
    void (async () => {
      const provider = await this.config.getWebSocketProvider();
      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);
      return provider.off(processedEvent, listener);
    })();
    return this;
  }

  /**
   * Remove all listeners for the provided {@link eventName} event. If no event
   * is provided, all events and their listeners are removed.
   *
   * @param eventName The event to remove all listeners for.
   * @public
   */
  removeAllListeners(eventName?: AlchemyEventType): this {
    void (async () => {
      const provider = await this.config.getWebSocketProvider();
      const processedEvent = eventName
        ? await this._resolveEnsAlchemyEvent(eventName)
        : undefined;
      provider.removeAllListeners(processedEvent);
    })();
    return this;
  }

  /**
   * Returns the number of listeners for the provided {@link eventName} event. If
   * no event is provided, the total number of listeners for all events is returned.
   *
   * @param eventName The event to get the number of listeners for.
   * @public
   */
  async listenerCount(eventName?: AlchemyEventType): Promise<number> {
    const provider = await this.config.getWebSocketProvider();
    const processedEvent = eventName
      ? await this._resolveEnsAlchemyEvent(eventName)
      : undefined;
    return provider.listenerCount(processedEvent);
  }

  /**
   * Returns an array of listeners for the provided {@link eventName} event. If
   * no event is provided, all listeners will be included.
   *
   * @param eventName The event to get the listeners for.
   */
  async listeners(eventName?: AlchemyEventType): Promise<Listener[]> {
    const provider = await this.config.getWebSocketProvider();
    const processedEvent = eventName
      ? await this._resolveEnsAlchemyEvent(eventName)
      : undefined;
    return provider.listeners(processedEvent);
  }

  /**
   * Converts ENS addresses in an Alchemy Event to the underlying resolved
   * address.
   *
   * VISIBLE ONLY FOR TESTING.
   *
   * @internal
   */
  async _resolveEnsAlchemyEvent(
    eventName: AlchemyEventType
  ): Promise<AlchemyEventType> {
    if (!isAlchemyEvent(eventName)) {
      return eventName;
    }

    if (
      eventName.method === AlchemySubscription.MINED_TRANSACTIONS &&
      eventName.addresses
    ) {
      const processedAddresses: AlchemyMinedTransactionsAddress[] = [];
      for (const address of eventName.addresses) {
        if (address.to) {
          address.to = await this._resolveNameOrError(address.to);
        }
        if (address.from) {
          address.from = await this._resolveNameOrError(address.from);
        }
        processedAddresses.push(address);
      }
      eventName.addresses =
        processedAddresses as NonEmptyArray<AlchemyMinedTransactionsAddress>;
    } else if (eventName.method === AlchemySubscription.PENDING_TRANSACTIONS) {
      if (eventName.fromAddress) {
        if (typeof eventName.fromAddress === 'string') {
          eventName.fromAddress = await this._resolveNameOrError(
            eventName.fromAddress
          );
        } else {
          eventName.fromAddress = await Promise.all(
            eventName.fromAddress.map(address =>
              this._resolveNameOrError(address)
            )
          );
        }
      }
      if (eventName.toAddress) {
        if (typeof eventName.toAddress === 'string') {
          eventName.toAddress = await this._resolveNameOrError(
            eventName.toAddress
          );
        } else {
          eventName.toAddress = await Promise.all(
            eventName.toAddress.map(address =>
              this._resolveNameOrError(address)
            )
          );
        }
      }
    }

    return eventName;
  }

  /**
   * Converts the provided ENS address or throws an error. This improves code
   * readability and type safety in other methods.
   *
   * VISIBLE ONLY FOR TESTING.
   *
   * @internal
   */
  async _resolveNameOrError(name: string): Promise<string> {
    const provider = await this.config.getProvider();
    const resolved = await provider.resolveName(name);
    if (resolved === null) {
      throw new Error(`Unable to resolve the ENS address: ${name}`);
    }
    return resolved;
  }
}


================================================================================
File: src\index.ts
Size: 1.52 kB
================================================================================

/** This is the main entry point for the library and exports user-facing API. */
// IMPORTANT: when adding namespace imports (imports of the form
// `import * as X from "./y"`), be sure to also update rollup.config.js so they
// will be treeshaken correctly.
// Namespace imports here:
import * as Utils from './api/utils';

export { Utils };

// End namespace imports

export * from './types/types';

export * from './types/nft-types';

export * from './types/prices-types';

export { Alchemy } from './api/alchemy';

export { Wallet } from './api/alchemy-wallet';

export { Contract, ContractFactory } from './api/alchemy-contract';

export { BigNumber } from '@ethersproject/bignumber';

export type { AlchemyConfig } from './api/alchemy-config';

export type { AlchemyProvider } from './api/alchemy-provider';

export type { AlchemyWebSocketProvider } from './api/alchemy-websocket-provider';

export type { NftNamespace } from './api/nft-namespace';

export type { WebSocketNamespace } from './api/websocket-namespace';

export type { CoreNamespace } from './api/core-namespace';

export type { TransactNamespace } from './api/transact-namespace';

export type { NotifyNamespace } from './api/notify-namespace';

export type { DebugNamespace } from './api/debug-namespace';

export type { PricesNamespace } from './api/prices-namespace';

export { fromHex, toHex, isHex } from './api/util';

export { setLogLevel, LogLevelString as LogLevel } from './util/logger';


================================================================================
File: src\internal\backoff.ts
Size: 2.39 kB
================================================================================

import { logDebug } from '../util/logger';

export const DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;
export const DEFAULT_BACKOFF_MULTIPLIER = 1.5;
export const DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;
export const DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;

/**
 * Helper class for implementing exponential backoff and max retry attempts.
 *
 * @private
 * @internal
 */
export class ExponentialBackoff {
  private readonly initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;
  private readonly backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;
  private readonly maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;

  private numAttempts = 0;
  private currentDelayMs = 0;
  private isInBackoff = false;

  constructor(private readonly maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS) {}

  /**
   * Returns a promise that resolves after the the backoff delay. The delay is
   * increased for each attempt. The promise is rejected if the maximum number
   * of attempts is exceeded.
   */
  // TODO: beautify this into an async iterator.
  backoff(): Promise<void> {
    if (this.numAttempts >= this.maxAttempts) {
      return Promise.reject(
        new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`)
      );
    }
    if (this.isInBackoff) {
      return Promise.reject(
        new Error('A backoff operation is already in progress')
      );
    }

    const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);
    if (backoffDelayWithJitterMs > 0) {
      logDebug(
        'ExponentialBackoff.backoff',
        `Backing off for ${backoffDelayWithJitterMs}ms`
      );
    }

    // Calculate the next delay.
    this.currentDelayMs *= this.backoffMultiplier;
    this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);
    this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);
    this.numAttempts += 1;

    return new Promise(resolve => {
      this.isInBackoff = true;
      setTimeout(() => {
        this.isInBackoff = false;
        resolve();
      }, backoffDelayWithJitterMs);
    });
  }

  /**
   * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.
   *
   * @private
   * @param delayMs
   */
  private withJitterMs(delayMs: number): number {
    return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);
  }
}


================================================================================
File: src\internal\core-api.ts
Size: 5.9 kB
================================================================================

import type { Log } from '@ethersproject/abstract-provider';
import { resolveProperties } from '@ethersproject/properties';

import { AlchemyConfig } from '../api/alchemy-config';
import { toHex } from '../api/util';
import {
  AssetTransfersParams,
  AssetTransfersResponse,
  AssetTransfersWithMetadataParams,
  AssetTransfersWithMetadataResponse,
  Filter,
  FilterByBlockHash,
  TransactionReceiptsParams,
  TransactionReceiptsResponse
} from '../types/types';
import { formatBlock } from '../util/util';

/**
 * This file contains the underlying implementations for exposed API surface in
 * the {@link CoreNamespace}. By moving the methods out into a separate file,
 * other namespaces can access these methods without depending on the entire
 * CoreNamespace, or override the `srcMethod` param used for logging.
 */

/**
 * Gets the asset transfers for the provided params.
 */
export async function getAssetTransfers(
  config: AlchemyConfig,
  params: AssetTransfersWithMetadataParams | AssetTransfersParams,
  srcMethod = 'getAssetTransfers'
): Promise<AssetTransfersResponse | AssetTransfersWithMetadataResponse> {
  const provider = await config.getProvider();
  if (params.fromAddress) {
    params.fromAddress = await provider._getAddress(params.fromAddress);
  }
  if (params.toAddress) {
    params.toAddress = await provider._getAddress(params.toAddress);
  }
  return provider._send(
    'alchemy_getAssetTransfers',
    [
      {
        ...params,
        fromBlock:
          params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,
        toBlock:
          params.toBlock != null ? formatBlock(params.toBlock) : undefined,
        maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined
      }
    ],
    srcMethod
  );
}

export async function getTransactionReceipts(
  config: AlchemyConfig,
  params: TransactionReceiptsParams,
  srcMethod = 'getTransactionReceipts'
): Promise<TransactionReceiptsResponse> {
  const provider = await config.getProvider();
  return provider._send('alchemy_getTransactionReceipts', [params], srcMethod);
}

/**
 * This method is based on the ethers implementation of getLogs, but is expanded
 * to support specifying an address array in the filter.
 *
 * The main modifications made to support an address array are:
 * - Custom `getFilter()` method that supports an address array
 * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.
 * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.
 */
export async function getLogs(
  config: AlchemyConfig,
  filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>
): Promise<Array<Log>> {
  const provider = await config.getProvider();
  await provider.getNetwork();
  const params = await resolveProperties({
    filter: getFilter(config, filter)
  });

  const logs: Array<Log> = await provider.send('eth_getLogs', [params.filter]);
  logs.forEach(log => {
    if (log.removed == null) {
      log.removed = false;
    }
  });
  return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);
}

/**
 * This method is based on and copied from the ethers implementation of
 * `JsonRpcProvider._getFilter()`, but is extended to support an address array.
 *
 * This implementation is a hacky way to get around the ethers formatter. The
 * formatter is used to check the types of the `filter` params, but ethers does
 * not allow an array in the `address` field. To preserve the ethers formatter
 * on the other fields, we use the formatter to check the types of those other
 * fields, and then manually check the `address` field last.
 */
async function getFilter(
  config: AlchemyConfig,
  filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>
): Promise<Filter | FilterByBlockHash> {
  // START MODIFIED CODE
  const provider = await config.getProvider();
  const resolvedFilter = await filter;
  let result: any = {};
  // END MODIFIED CODE

  ['blockHash', 'topics'].forEach(key => {
    if ((resolvedFilter as any)[key] == null) {
      return;
    }
    result[key] = (resolvedFilter as any)[key];
  });

  ['fromBlock', 'toBlock'].forEach(key => {
    if ((resolvedFilter as any)[key] == null) {
      return;
    }
    result[key] = provider._getBlockTag((resolvedFilter as any)[key]);
  });

  // BEGIN MODIFIED CODE
  // Format the `result` object using the ethers formatter without the `address`
  // field.
  result = provider.formatter.filter(await resolveProperties(result));

  // After formatting the other fields, manually format the `address` field
  // before adding it to the `result` object.
  if (Array.isArray(resolvedFilter.address)) {
    result.address = await Promise.all(
      resolvedFilter.address.map(async (address: string) =>
        provider._getAddress(address)
      )
    );
  } else if (resolvedFilter.address != null) {
    result.address = await provider._getAddress(resolvedFilter.address);
  }

  return result;
  // END MODIFIED CODE
}

/**
 * DO NOT MODIFY.
 *
 * This function is directly copied over from ethers implementation of
 * `Formatter.arrayOf()`. It is copied here to avoid having to import the
 * `Formatter` class or `FormatterFunc` type from ethers, that are not part of
 * the default export.
 *
 * This function returns a function that applies the formatter to an array of
 * values, and is used to format the logs returned by `getLogs()`.
 */
function arrayOf(format: any): any {
  return function (array: any): Array<any> {
    if (!Array.isArray(array)) {
      throw new Error('not an array');
    }

    const result: any = [];

    array.forEach(value => {
      result.push(format(value));
    });

    return result;
  };
}


================================================================================
File: src\internal\dispatch.ts
Size: 3.69 kB
================================================================================

import axios, { AxiosError, AxiosRequestConfig } from 'axios';

import { AlchemyConfig } from '../api/alchemy-config';
import { AlchemyApiType } from '../util/const';
import { logDebug, logInfo } from '../util/logger';
import { sendAxiosRequest } from '../util/sendRest';
import { ExponentialBackoff } from './backoff';

/**
 * A wrapper function to make http requests and retry if the request fails.
 *
 * @internal
 */
// TODO: Wrap Axios error in AlchemyError.
export async function requestHttpWithBackoff<Req, Res>(
  config: AlchemyConfig,
  apiType: AlchemyApiType,
  restApiName: string,
  methodName: string,
  params: Req,
  overrides?: AxiosRequestConfig
): Promise<Res> {
  let lastError: Error | undefined = undefined;
  const backoff = new ExponentialBackoff(config.maxRetries);
  for (let attempt = 0; attempt < config.maxRetries + 1; attempt++) {
    try {
      if (lastError !== undefined) {
        logInfo('requestHttp', `Retrying after error: ${lastError.message}`);
      }

      try {
        await backoff.backoff();
      } catch (err) {
        // Backoff errors when the maximum number of attempts is reached. Break
        // out of the loop to preserve the last error.
        break;
      }

      const response = await sendAxiosRequest<Req, Res>(
        config._getRequestUrl(apiType),
        restApiName,
        methodName,
        params,
        {
          ...overrides,
          timeout: config.requestTimeout
        }
      );

      if (response.status === 200) {
        logDebug(restApiName, `Successful request: ${restApiName}`);
        return response.data;
      } else {
        logInfo(
          restApiName,
          `Request failed: ${restApiName}, ${response.status}, ${response.data}`
        );
        lastError = new Error(response.status + ': ' + response.data);
      }
    } catch (err) {
      if (!axios.isAxiosError(err) || err.response === undefined) {
        throw err;
      }
      // TODO: Standardize all errors into AlchemyError
      lastError = new Error(
        err.response.status + ': ' + JSON.stringify(err.response.data)
      );
      if (!isRetryableHttpError(err, apiType)) {
        break;
      }
    }
  }
  return Promise.reject(lastError);
}

function isRetryableHttpError(
  err: AxiosError,
  apiType: AlchemyApiType
): boolean {
  // TODO: remove 500s after webhooks are more stable.
  const retryableCodes =
    apiType === AlchemyApiType.WEBHOOK ? [429, 500] : [429];
  return (
    err.response !== undefined && retryableCodes.includes(err.response.status)
  );
}

/**
 * Fetches all pages in a paginated endpoint, given a `pageKey` field that
 * represents the property name containing the next page token.
 *
 * @internal
 */
export async function* paginateEndpoint<
  ReqPageKey extends string,
  ResPageKey extends string,
  Req extends Partial<Record<string, any> & Record<ReqPageKey, string>>,
  Res extends Partial<Record<string, any> & Record<ResPageKey, string>>
>(
  config: AlchemyConfig,
  apiType: AlchemyApiType,
  restApiName: string,
  methodName: string,
  reqPageKey: ReqPageKey,
  resPageKey: ResPageKey,
  params: Req
): AsyncIterable<Res> {
  let hasNext = true;
  const requestParams = { ...params };
  while (hasNext) {
    const response = await requestHttpWithBackoff<Req, Res>(
      config,
      apiType,
      restApiName,
      methodName,
      requestParams
    );
    yield response;
    if (response[resPageKey] !== null) {
      requestParams[reqPageKey] = response[resPageKey] as any;
    } else {
      hasNext = false;
    }
  }
}


================================================================================
File: src\internal\ethers-event.ts
Size: 10.89 kB
================================================================================

import { EventType, Filter, Listener } from '@ethersproject/abstract-provider';

import {
  AlchemyEventFilter,
  AlchemyEventType,
  AlchemyMinedTransactionsAddress,
  AlchemyMinedTransactionsEventFilter,
  AlchemyPendingTransactionsEventFilter,
  AlchemySubscription,
  NonEmptyArray
} from '../types/types';
import {
  ALCHEMY_EVENT_TYPES,
  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,
  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE
} from './internal-types';

/**
 * DO NOT MODIFY.
 *
 * Event class copied directly over from ethers.js's `BaseProvider` class.
 *
 * This class is used to represent events and their corresponding listeners. The
 * SDK needs to extend this class in order to support Alchemy's custom
 * Subscription API types. The original class is not exported by ethers. Minimal
 * changes have been made in order to get TS to compile.
 */
class Event {
  readonly listener: Listener;
  readonly once: boolean;
  readonly tag: string;

  _lastBlockNumber: number;
  _inflight: boolean;

  constructor(tag: string, listener: Listener, once: boolean) {
    this.listener = listener;
    this.tag = tag;
    this.once = once;
    this._lastBlockNumber = -2;
    this._inflight = false;
  }

  get event(): EventType {
    switch (this.type) {
      case 'tx':
        return this.hash!;
      case 'filter':
        return this.filter!;
      default:
        return this.tag;
    }
  }

  get type(): string {
    return this.tag.split(':')[0];
  }

  get hash(): string {
    const comps = this.tag.split(':');
    if (comps[0] !== 'tx') {
      throw new Error('Not a transaction event');
    }
    return comps[1];
  }

  get filter(): Filter {
    const comps = this.tag.split(':');
    if (comps[0] !== 'filter') {
      throw new Error('Not a transaction event');
    }
    const address = comps[1];

    const topics = deserializeTopics(comps[2]);
    const filter: Filter = {};

    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== '*') {
      filter.address = address;
    }

    return filter;
  }

  pollable(): boolean {
    const PollableEvents = ['block', 'network', 'pending', 'poll'];
    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}

/**
 * Wrapper class around the ethers `Event` class in order to add support for
 * Alchemy's custom subscriptions types.
 *
 * The serialization and deserialization mechanism requires the order of the
 * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before
 * using a getter on a new event filter, make sure that the position of the
 * field in serialization is correct.
 *
 * The getters on this class deserialize the event tag generated by
 * {@link getAlchemyEventTag} into the original fields passed into the event.
 */
export class EthersEvent extends Event {
  /**
   * Converts the event tag into the original `fromAddress` field in
   * {@link AlchemyPendingTransactionsEventFilter}.
   */
  get fromAddress(): string | string[] | undefined {
    const comps = this.tag.split(':');
    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
      return undefined;
    }
    if (comps[1] && comps[1] !== '*') {
      return deserializeAddressField(comps[1]);
    } else {
      return undefined;
    }
  }

  /**
   * Converts the event tag into the original `toAddress` field in
   * {@link AlchemyPendingTransactionsEventFilter}.
   */
  get toAddress(): string | string[] | undefined {
    const comps = this.tag.split(':');
    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
      return undefined;
    }
    if (comps[2] && comps[2] !== '*') {
      return deserializeAddressField(comps[2]);
    } else {
      return undefined;
    }
  }

  /**
   * Converts the event tag into the original `hashesOnly` field in
   * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.
   */
  get hashesOnly(): boolean | undefined {
    const comps = this.tag.split(':');
    if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {
      return undefined;
    }
    if (comps[3] && comps[3] !== '*') {
      return comps[3] === 'true';
    } else {
      return undefined;
    }
  }

  get includeRemoved(): boolean | undefined {
    const comps = this.tag.split(':');
    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
      return undefined;
    }
    if (comps[2] && comps[2] !== '*') {
      return comps[2] === 'true';
    } else {
      return undefined;
    }
  }

  get addresses(): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {
    const comps = this.tag.split(':');
    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
      return undefined;
    }
    if (comps[1] && comps[1] !== '*') {
      return deserializeAddressesField(comps[1]);
    } else {
      return undefined;
    }
  }
}

export function isAlchemyEvent(
  event: AlchemyEventType
): event is
  | AlchemyMinedTransactionsEventFilter
  | AlchemyPendingTransactionsEventFilter {
  return typeof event === 'object' && 'method' in event;
}

/**
 * Creates a string representation of an `alchemy_pendingTransaction`
 * subscription filter that is compatible with the ethers implementation of
 * `getEventTag()`. The method is not an exported function in ethers, which is
 * why the SDK has its own implementation.
 *
 * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.
 *
 * @example
 *   ```js
 *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'
 *   const eventTag =  getAlchemyEventTag(
 *   {
 *     "method": "alchemy_pendingTransactions",
 *     "fromAddress": "0xABC",
 *     "toAddress": ["0xDEF", "0xGHI"],
 *     "hashesOnly: true
 *   });
 *   ```;
 *
 * @param event
 * @internal
 */
export function getAlchemyEventTag(event: AlchemyEventType): string {
  if (!isAlchemyEvent(event)) {
    throw new Error('Event tag requires AlchemyEventType');
  }

  if (event.method === AlchemySubscription.PENDING_TRANSACTIONS) {
    return serializePendingTransactionsEvent(event);
  } else if (event.method === AlchemySubscription.MINED_TRANSACTIONS) {
    return serializeMinedTransactionsEvent(event);
  } else {
    throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);
  }
}

export function verifyAlchemyEventName(eventName: AlchemyEventFilter): void {
  if (!Object.values(AlchemySubscription).includes(eventName.method)) {
    throw new Error(
      `Invalid method name ${
        eventName.method
      }. Accepted method names: ${Object.values(AlchemySubscription)}`
    );
  }
}

/**
 * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers
 * compatible event tag.
 *
 * For the example event:
 * ```
 *  {
 *     "method": "alchemy_pendingTransactions",
 *     "fromAddress": "0xABC",
 *     "toAddress": ["0xDEF", "0xGHI"],
 *     "hashesOnly: true
 *   }
 * ```
 *
 * The resulting serialization is:
 * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`
 *
 * If a field is omitted, it is replaced with a `*`.
 */
function serializePendingTransactionsEvent(
  event: AlchemyPendingTransactionsEventFilter
): string {
  const fromAddress = serializeAddressField(event.fromAddress);
  const toAddress = serializeAddressField(event.toAddress);
  const hashesOnly = serializeBooleanField(event.hashesOnly);
  return (
    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +
    ':' +
    fromAddress +
    ':' +
    toAddress +
    ':' +
    hashesOnly
  );
}

/**
 * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers
 * compatible event tag.
 *
 * For the example event:
 * ```
 *  {
 *     "method": "alchemy_minedTransactions",
 *     "addresses": [
 *       {
 *         from: "0xABC"
 *       },
 *       {
 *         to: "0xDEF",
 *         from: "0x123"
 *       }
 *     ]
 *     "includeRemoved": false
 *     "hashesOnly: true
 *   }
 * ```
 *
 * The resulting serialization is:
 * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`
 *
 * If a field is omitted, it is replaced with a `*`.
 *
 * The `addresses` array is split by the '|' character, and each to/from address
 * pair is separated by a ',' character.
 *
 */
function serializeMinedTransactionsEvent(
  event: AlchemyMinedTransactionsEventFilter
): string {
  const addresses = serializeAddressesField(event.addresses);
  const includeRemoved = serializeBooleanField(event.includeRemoved);
  const hashesOnly = serializeBooleanField(event.hashesOnly);
  return (
    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE +
    ':' +
    addresses +
    ':' +
    includeRemoved +
    ':' +
    hashesOnly
  );
}

function serializeAddressesField(
  addresses: AlchemyMinedTransactionsAddress[] | undefined
): string {
  if (addresses === undefined) {
    return '*';
  }

  return addresses
    .map(
      filter =>
        serializeAddressField(filter.to) +
        ',' +
        serializeAddressField(filter.from)
    )
    .join('|');
}

function serializeAddressField(
  field: string | Array<string> | undefined
): string {
  if (field === undefined) {
    return '*';
  } else if (Array.isArray(field)) {
    return field.join('|');
  } else {
    return field;
  }
}

function serializeBooleanField(field: boolean | undefined): string | undefined {
  if (field === undefined) {
    return '*';
  } else {
    return field.toString();
  }
}

export function deserializeTopics(data: string): any {
  if (data === '') {
    return [];
  }

  return data.split(/&/g).map(topic => {
    if (topic === '') {
      return [];
    }

    const comps = topic.split('|').map(topic => {
      return topic === 'null' ? null : topic;
    });

    return comps.length === 1 ? comps[0] : comps;
  });
}

function deserializeAddressField(data: string): string | string[] | undefined {
  if (data === '') {
    return undefined;
  }

  const addresses = data.split('|');
  return addresses.length === 1 ? addresses[0] : addresses;
}

function deserializeAddressesField(
  data: string
): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {
  if (data === '') {
    return undefined;
  }

  // Perform a cast here since TS doesn't know we're guaranteed a non-empty
  // array from deserializing.
  return data
    .split('|')
    .map(addressStr => addressStr.split(','))
    .map(addressPair => ({
      ...(addressPair[0] !== '*' && { to: addressPair[0] }),
      ...(addressPair[1] !== '*' && { from: addressPair[1] })
    })) as NonEmptyArray<AlchemyMinedTransactionsAddress>;
}


================================================================================
File: src\internal\internal-types.ts
Size: 1.58 kB
================================================================================

/** This file contains internal types used by the SDK and are not exposed to the end user. */

type JsonRpcId = string | number | null;

/**
 * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to
 * ethers events.
 *
 * This tag is used internally by ethers to track different event filters.
 */
export const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE =
  'alchemy-pending-transactions';

/**
 * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.
 *
 * This tag is used internally by ethers to track different event filters.
 */
export const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE =
  'alchemy-mined-transactions';

/**
 * Array containing all the custom event tags used internally by ethers to track
 * event filters.
 */
export const ALCHEMY_EVENT_TYPES = [
  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,
  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE
];

export interface JsonRpcRequest {
  jsonrpc: '2.0';
  method: string;
  params?: any[];
  id?: JsonRpcId;
}

export interface JsonRpcResponse<T = any> {
  jsonrpc: '2.0';
  result?: T;
  error?: JsonRpcError;
  id: JsonRpcId;
}

interface JsonRpcError<T = any> {
  code: number;
  message: string;
  data?: T;
}

export type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;
export type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];
export interface SubscriptionEvent<T = any> {
  jsonrpc: '2.0';
  method: 'eth_subscription';
  params: {
    subscription: string;
    result: T;
  };
}


================================================================================
File: src\internal\nft-api.ts
Size: 31.75 kB
================================================================================

import { BigNumber, BigNumberish } from '@ethersproject/bignumber';

import { AlchemyConfig } from '../api/alchemy-config';
import {
  BaseNft,
  ComputeRarityResponse,
  GetBaseNftsForContractOptions,
  GetBaseNftsForOwnerOptions,
  GetContractMetadataBatchResponse,
  GetContractsForOwnerOptions,
  GetContractsForOwnerResponse,
  GetFloorPriceResponse,
  GetMintedNftsOptions,
  GetNftMetadataBatchResponse,
  GetNftMetadataOptions,
  GetNftSalesOptions,
  GetNftSalesOptionsByContractAddress,
  GetNftSalesResponse,
  GetNftsForContractOptions,
  GetNftsForOwnerOptions,
  GetOwnersForContractOptions,
  GetOwnersForContractResponse,
  GetOwnersForContractWithTokenBalancesOptions,
  GetOwnersForContractWithTokenBalancesResponse,
  GetOwnersForNftResponse,
  GetSpamContractsResponse,
  GetTransfersForContractOptions,
  IsAirdropNftResponse,
  IsSpamContractResponse,
  Nft,
  NftAttributesResponse,
  NftCollection,
  NftContract,
  NftContractBaseNftsResponse,
  NftContractNftsResponse,
  NftFilters,
  NftMetadataBatchOptions,
  NftMetadataBatchToken,
  NftOrdering,
  NftRefreshState,
  NftSaleMarketplace,
  NftSaleTakerType,
  NftTokenType,
  OwnedBaseNft,
  OwnedBaseNftsResponse,
  OwnedNft,
  OwnedNftsResponse,
  SearchContractMetadataResponse,
  TransfersNftResponse
} from '../types/nft-types';
import {
  AssetTransfersCategory,
  AssetTransfersParams,
  AssetTransfersResponse,
  AssetTransfersResult,
  GetTransfersForOwnerOptions,
  GetTransfersForOwnerTransferType,
  RefreshContractResult,
  SortingOrder
} from '../types/types';
import { AlchemyApiType, ETH_NULL_ADDRESS } from '../util/const';
import { sanitizeTokenType } from '../util/inputSanitization';
import {
  getBaseNftFromRaw,
  getNftCollectionFromRaw,
  getNftContractFromRaw,
  getNftContractsForOwnerFromRaw,
  getNftFromRaw,
  getNftSalesFromRaw,
  nullsToUndefined
} from '../util/util';
import { getAssetTransfers } from './core-api';
import { paginateEndpoint, requestHttpWithBackoff } from './dispatch';
import {
  RawComputeRarityResponse,
  RawContractBaseNft,
  RawGetBaseNftsForContractResponse,
  RawGetBaseNftsResponse,
  RawGetContractMetadataBatchResponse,
  RawGetContractsForOwnerResponse,
  RawGetFloorPriceResponse,
  RawGetNftMetadataBatchResponse,
  RawGetNftSalesResponse,
  RawGetNftsForContractResponse,
  RawGetNftsForOwnerResponse,
  RawGetOwnersForContractResponse,
  RawGetOwnersForContractWithTokenBalancesResponse,
  RawGetSpamContractsResponse,
  RawIsAirdropNftResponse,
  RawIsSpamContractResponse,
  RawNft,
  RawNftAttributesResponse,
  RawNftCollection,
  RawNftContractForNft,
  RawOwnedBaseNft,
  RawOwnedNft,
  RawReingestContractResponse,
  RawSearchContractMetadataResponse
} from './raw-interfaces';

/**
 * This file contains the underlying implementations for exposed API surface in
 * the {@link NftNamespace}. By moving the methods out into a separate file,
 * other namespaces can access these methods without depending on the entire
 * NftNamespace.
 */

/**
 * Get the NFT metadata for the provided contract address.
 */
export async function getNftMetadata(
  config: AlchemyConfig,
  contractAddress: string,
  tokenId: BigNumberish,
  options?: GetNftMetadataOptions,
  srcMethod = 'getNftMetadata'
): Promise<Nft> {
  const response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(
    config,
    AlchemyApiType.NFT,
    'getNFTMetadata',
    srcMethod,
    {
      contractAddress,
      tokenId: BigNumber.from(tokenId!).toString(),
      tokenType: sanitizeTokenType(options?.tokenType),
      tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,
      refreshCache: options?.refreshCache
    }
  );
  return getNftFromRaw(response);
}

export async function getNftMetadataBatch(
  config: AlchemyConfig,
  tokens: Array<NftMetadataBatchToken>,
  options?: NftMetadataBatchOptions
): Promise<GetNftMetadataBatchResponse> {
  const data = {
    tokens,
    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,
    refreshCache: options?.refreshCache
  };
  const response = await requestHttpWithBackoff<
    {},
    RawGetNftMetadataBatchResponse
  >(
    config,
    AlchemyApiType.NFT,
    'getNFTMetadataBatch',
    'getNftMetadataBatch',
    {},
    {
      method: 'POST',
      data
    }
  );
  return {
    nfts: response.nfts.map(nft => getNftFromRaw(nft))
  };
}

export async function getContractMetadata(
  config: AlchemyConfig,
  contractAddress: string,
  srcMethod = 'getContractMetadata'
): Promise<NftContract> {
  const response = await requestHttpWithBackoff<
    GetContractMetadataParams,
    RawNftContractForNft
  >(config, AlchemyApiType.NFT, 'getContractMetadata', srcMethod, {
    contractAddress
  });

  return getNftContractFromRaw(response);
}

export async function getContractMetadataBatch(
  config: AlchemyConfig,
  contractAddresses: string[]
): Promise<GetContractMetadataBatchResponse> {
  const response = await requestHttpWithBackoff<
    {},
    RawGetContractMetadataBatchResponse
  >(
    config,
    AlchemyApiType.NFT,
    'getContractMetadataBatch',
    'getContractMetadataBatch',
    {},
    {
      method: 'POST',
      data: { contractAddresses }
    }
  );

  return {
    contracts: response.contracts.map(getNftContractFromRaw)
  };
}

export async function getCollectionMetadata(
  config: AlchemyConfig,
  collectionSlug: string,
  srcMethod = 'getCollectionMetadata'
): Promise<NftCollection> {