
 * Base interface for historical price responses.
 *
 * @public
 */
interface BaseHistoricalPriceResponse {
  /** Currency the prices are denominated in */
  currency: string;
  /** Array of historical price data points */
  data: HistoricalPriceDataPoint[];
}

/**
 * Response type for historical prices by symbol requests.
 *
 * @public
 */
export interface HistoricalPriceBySymbolResponse
  extends BaseHistoricalPriceResponse {
  /** Token symbol that was queried */
  symbol: string;
}

/**
 * Response type for historical prices by network/address requests.
 *
 * @public
 */
export interface HistoricalPriceByAddressResponse
  extends BaseHistoricalPriceResponse {
  /** Network that was queried */
  network: string;
  /** Contract address that was queried */
  address: string;
}

/**
 * Type helper to infer the correct response type based on the request type.
 *
 * @public
 */
export type HistoricalPriceResponse =
  | HistoricalPriceBySymbolResponse
  | HistoricalPriceByAddressResponse;


================================================================================
File: src\types\types.ts
Size: 50.06 kB
================================================================================

import {
  BlockTag,
  EventType,
  TransactionReceipt
} from '@ethersproject/abstract-provider';
import { BigNumberish } from '@ethersproject/bignumber';
import { ConnectionInfo } from '@ethersproject/web';

import {
  ERC1155Metadata,
  NftRefreshState,
  NftTokenType,
  RawContract
} from './nft-types';

export * from './ethers-types';

// TODO: separate this file into other files.

/**
 * Options object used to configure the Alchemy SDK.
 *
 * @public
 */
export interface AlchemySettings {
  /**
   * The Alchemy API key that can be found in the Alchemy dashboard.
   *
   * Defaults to: "demo" (a rate-limited public API key)
   */
  apiKey?: string;

  /**
   * The name of the network. Once configured, the network cannot be changed. To
   * use a different network, instantiate a new `Alchemy` instance.
   *
   * Defaults to: Network.ETH_MAINNET
   */
  network?: Network;

  /** The maximum number of retries to attempt if a request fails. Defaults to 5. */
  maxRetries?: number;

  /**
   * Optional URL endpoint to use for all requests. Setting this field will
   * override the URL generated by the {@link network} and {@link apiKey} fields.
   *
   * This field is useful for testing or for using a custom node endpoint. Note
   * that not all methods will work with custom URLs.
   */
  url?: string;

  /**
   * Alchemy auth token required to use the Notify API. This token can be found
   * in the Alchemy Dashboard on the Notify tab.
   */
  authToken?: string;

  /**
   * Optional Request timeout provided in `ms` while using NFT and NOTIFY API.
   * Default to 0 (No timeout).
   */
  requestTimeout?: number;

  /**
   * Optional setting that automatically batches and sends json-rpc requests for
   * higher throughput and reduced network IO. Defaults to false.
   *
   * This implementation is based on the `JsonRpcBatchProvider` in ethers.
   */
  batchRequests?: boolean;

  /**
   * Optional overrides on the Ethers `ConnectionInfo` object used to configure
   * the underlying JsonRpcProvider. This field is for advanced users who want
   * to customize the provider's behavior.
   *
   * This override is applied last, so it will override any other
   * AlchemySettings properties that affect the connection.
   *
   * Note that modifying the ConnectionInfo may break Alchemy SDK's default
   * connection/url logic. It also does not affect `nft` and `notify`
   * namespaces.
   *
   * {@link https://docs.ethers.org/v5/api/utils/web/#ConnectionInfo}
   */
  connectionInfoOverrides?: Partial<ConnectionInfo>;
}

/**
 * The supported networks by Alchemy. Note that some functions are not available
 * on all networks. Please refer to the Alchemy documentation for which APIs are
 * available on which networks
 * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}
 *
 * @public
 */
export enum Network {
  ETH_MAINNET = 'eth-mainnet',
  /** @deprecated */
  ETH_GOERLI = 'eth-goerli',
  ETH_SEPOLIA = 'eth-sepolia',
  ETH_HOLESKY = 'eth-holesky',
  OPT_MAINNET = 'opt-mainnet',
  /** @deprecated */
  OPT_GOERLI = 'opt-goerli',
  OPT_SEPOLIA = 'opt-sepolia',
  ARB_MAINNET = 'arb-mainnet',
  /** @deprecated */
  ARB_GOERLI = 'arb-goerli',
  ARB_SEPOLIA = 'arb-sepolia',
  MATIC_MAINNET = 'polygon-mainnet',
  /** @deprecated */
  MATIC_MUMBAI = 'polygon-mumbai',
  MATIC_AMOY = 'polygon-amoy',
  ASTAR_MAINNET = 'astar-mainnet',
  POLYGONZKEVM_MAINNET = 'polygonzkevm-mainnet',
  /** @deprecated */
  POLYGONZKEVM_TESTNET = 'polygonzkevm-testnet',
  POLYGONZKEVM_CARDONA = 'polygonzkevm-cardona',
  BASE_MAINNET = 'base-mainnet',
  /** @deprecated */
  BASE_GOERLI = 'base-goerli',
  BASE_SEPOLIA = 'base-sepolia',
  ZKSYNC_MAINNET = 'zksync-mainnet',
  ZKSYNC_SEPOLIA = 'zksync-sepolia',
  SHAPE_MAINNET = 'shape-mainnet',
  SHAPE_SEPOLIA = 'shape-sepolia',
  LINEA_MAINNET = 'linea-mainnet',
  LINEA_SEPOLIA = 'linea-sepolia',
  FANTOM_MAINNET = 'fantom-mainnet',
  FANTOM_TESTNET = 'fantom-testnet',
  ZETACHAIN_MAINNET = 'zetachain-mainnet',
  ZETACHAIN_TESTNET = 'zetachain-testnet',
  ARBNOVA_MAINNET = 'arbnova-mainnet',
  BLAST_MAINNET = 'blast-mainnet',
  BLAST_SEPOLIA = 'blast-sepolia',
  MANTLE_MAINNET = 'mantle-mainnet',
  MANTLE_SEPOLIA = 'mantle-sepolia',
  SCROLL_MAINNET = 'scroll-mainnet',
  SCROLL_SEPOLIA = 'scroll-sepolia',
  GNOSIS_MAINNET = 'gnosis-mainnet',
  GNOSIS_CHIADO = 'gnosis-chiado',
  BNB_MAINNET = 'bnb-mainnet',
  BNB_TESTNET = 'bnb-testnet',
  AVAX_MAINNET = 'avax-mainnet',
  AVAX_FUJI = 'avax-fuji',
  CELO_MAINNET = 'celo-mainnet',
  CELO_ALFAJORES = 'celo-alfajores',
  METIS_MAINNET = 'metis-mainnet',
  OPBNB_MAINNET = 'opbnb-mainnet',
  OPBNB_TESTNET = 'opbnb-testnet',
  BERACHAIN_BARTIO = 'berachain-bartio',
  BERACHAIN_MAINNET = 'berachain-mainnet',
  SONEIUM_MAINNET = 'soneium-mainnet',
  SONEIUM_MINATO = 'soneium-minato',
  WORLDCHAIN_MAINNET = 'worldchain-mainnet',
  WORLDCHAIN_SEPOLIA = 'worldchain-sepolia',
  ROOTSTOCK_MAINNET = 'rootstock-mainnet',
  ROOTSTOCK_TESTNET = 'rootstock-testnet',
  FLOW_MAINNET = 'flow-mainnet',
  FLOW_TESTNET = 'flow-testnet',
  ZORA_MAINNET = 'zora-mainnet',
  ZORA_SEPOLIA = 'zora-sepolia',
  FRAX_MAINNET = 'frax-mainnet',
  FRAX_SEPOLIA = 'frax-sepolia',
  POLYNOMIAL_MAINNET = 'polynomial-mainnet',
  POLYNOMIAL_SEPOLIA = 'polynomial-sepolia',
  CROSSFI_MAINNET = 'crossfi-mainnet',
  CROSSFI_TESTNET = 'crossfi-testnet',
  APECHAIN_MAINNET = 'apechain-mainnet',
  APECHAIN_CURTIS = 'apechain-curtis',
  LENS_SEPOLIA = 'lens-sepolia',
  GEIST_MAINNET = 'geist-mainnet',
  GEIST_POLTER = 'geist-polter',
  LUMIA_PRISM = 'lumia-prism',
  LUMIA_TESTNET = 'lumia-testnet',
  UNICHAIN_MAINNET = 'unichain-mainnet',
  UNICHAIN_SEPOLIA = 'unichain-sepolia',
  SONIC_MAINNET = 'sonic-mainnet',
  SONIC_BLAZE = 'sonic-blaze',
  XMTP_TESTNET = 'xmtp-testnet',
  ABSTRACT_MAINNET = 'abstract-mainnet',
  ABSTRACT_TESTNET = 'abstract-testnet',
  DEGEN_MAINNET = 'degen-mainnet',
  INK_MAINNET = 'ink-mainnet',
  INK_SEPOLIA = 'ink-sepolia',
  SEI_TESTNET = 'sei-testnet'
}

/** Token Types for the `getTokenBalances()` endpoint. */
export enum TokenBalanceType {
  /**
   * Option to fetch the top 100 tokens by 24-hour volume. This option is only
   * available on Mainnet in Ethereum, Polygon, and Arbitrum.
   */
  DEFAULT_TOKENS = 'DEFAULT_TOKENS',

  /**
   * Option to fetch the set of ERC-20 tokens that the address as ever held. his
   * list is produced by an address's historical transfer activity and includes
   * all tokens that the address has ever received.
   */
  ERC20 = 'erc20'
}

/**
 * Optional params to pass into `getTokenBalances()` to fetch all ERC-20 tokens
 * instead of passing in an array of contract addresses to fetch balances for.
 */
export interface TokenBalancesOptionsErc20 {
  /** The ERC-20 token type. */
  type: TokenBalanceType.ERC20;

  /** Optional page key for pagination (only applicable to TokenBalanceType.ERC20) */
  pageKey?: string;
}

/**
 * Optional params to pass into `getTokenBalances()` to fetch the top 100 tokens
 * instead of passing in an array of contract addresses to fetch balances for.
 */
export interface TokenBalancesOptionsDefaultTokens {
  /** The top 100 token type. */
  type: TokenBalanceType.DEFAULT_TOKENS;
}

/**
 * Response object for when the {@link TokenBalancesOptionsErc20} options are
 * used. A page key may be returned if the provided address has many transfers.
 */
export interface TokenBalancesResponseErc20 extends TokenBalancesResponse {
  /**
   * An optional page key to passed into the next request to fetch the next page
   * of token balances.
   */
  pageKey?: string;
}

/** @public */
export interface TokenBalancesResponse {
  address: string;
  tokenBalances: TokenBalance[];
}

/** @public */
export type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;

/** @public */
export interface TokenBalanceSuccess {
  contractAddress: string;
  tokenBalance: string;
  error: null;
}

/** @public */
export interface TokenBalanceFailure {
  contractAddress: string;
  tokenBalance: null;
  error: string;
}

/**
 * Optional params to pass into {@link CoreNamespace.getTokensForOwner}.
 */
export interface GetTokensForOwnerOptions {
  /**
   * List of contract addresses to filter by. If omitted, defaults to
   * {@link TokenBalanceType.ERC20}.
   */
  contractAddresses?: string[] | TokenBalanceType;
  /**
   * Optional page key from an existing {@link GetTokensForOwnerResponse} to use for
   * pagination.
   */
  pageKey?: string;
}

/**
 * Response object for {@link CoreNamespace.getTokensForOwner}.
 */
export interface GetTokensForOwnerResponse {
  /** Owned tokens for the provided addresses along with relevant metadata. */
  tokens: OwnedToken[];
  /** Page key for the next page of results, if one exists. */
  pageKey?: string;
}

/**
 * Represents an owned token on a {@link GetTokensForOwnerResponse}.
 */
export interface OwnedToken {
  /** The contract address of the token. */
  contractAddress: string;
  /**
   * The raw value of the balance field as a hex string. This value is undefined
   * if the {@link error} field is present.
   */
  rawBalance?: string;
  /**
   * The formatted value of the balance field as a hex string. This value is
   * undefined if the {@link error} field is present, or if the `decimals` field=
   * is undefined.
   */
  balance?: string;
  /** */
  /**
   * The token's name. Is undefined if the name is not defined in the contract and
   * not available from other sources.
   */
  name?: string;
  /**
   * The token's symbol. Is undefined if the symbol is not defined in the contract
   * and not available from other sources.
   */
  symbol?: string;
  /**
   * The number of decimals of the token. Is undefined if not defined in the
   * contract and not available from other sources.
   */
  decimals?: number;
  /** URL link to the token's logo. Is undefined if the logo is not available. */
  logo?: string;
  /**
   * Error from fetching the token balances. If this field is defined, none of
   * the other fields will be defined.
   */
  error?: string;
}

/**
 * Response object for the {@link CoreNamespace.getTokenMetadata} method.
 *
 * @public
 */
export interface TokenMetadataResponse {
  /**
   * The token's name. Is `null` if the name is not defined in the contract and
   * not available from other sources.
   */
  name: string | null;

  /**
   * The token's symbol. Is `null` if the symbol is not defined in the contract
   * and not available from other sources.
   */
  symbol: string | null;

  /**
   * The number of decimals of the token. Returns `null` if not defined in the
   * contract and not available from other sources.
   */
  decimals: number | null;

  /** URL link to the token's logo. Is `null` if the logo is not available. */
  logo: string | null;
}

/**
 * Parameters for the {@link CoreNamespace.getAssetTransfers} method.
 *
 * @public
 */
export interface AssetTransfersParams {
  /**
   * The starting block to check for transfers. This value is inclusive and
   * defaults to `0x0` if omitted.
   */
  fromBlock?: string;

  /**
   * The ending block to check for transfers. This value is inclusive and
   * defaults to the latest block if omitted.
   */
  toBlock?: string;

  /**
   * Whether to return results in ascending or descending order by block number.
   * Defaults to ascending if omitted.
   */
  order?: SortingOrder;

  /**
   * The from address to filter transfers by. This value defaults to a wildcard
   * for all addresses if omitted.
   */
  fromAddress?: string;

  /**
   * The to address to filter transfers by. This value defaults to a wildcard
   * for all address if omitted.
   */
  toAddress?: string;

  /**
   * List of contract addresses to filter for - only applies to "erc20",
   * "erc721", "erc1155" transfers. Defaults to all address if omitted.
   */
  contractAddresses?: string[];

  /**
   * Whether to exclude transfers with zero value. Note that zero value is
   * different than null value. Defaults to `true` if omitted.
   */
  excludeZeroValue?: boolean;

  /** REQUIRED field. An array of categories to get transfers for. */
  category: AssetTransfersCategory[];

  /** The maximum number of results to return per page. Defaults to 1000 if omitted. */
  maxCount?: number;

  /**
   * Optional page key from an existing {@link OwnedBaseNftsResponse}
   * {@link AssetTransfersResult}to use for pagination.
   */
  pageKey?: string;

  /**
   * Whether to include additional metadata about each transfer event. Defaults
   * to `false` if omitted.
   */
  withMetadata?: boolean;
}

/**
 * Parameters for the {@link CoreNamespace.getAssetTransfers} method that
 * includes metadata.
 *
 * @public
 */
export interface AssetTransfersWithMetadataParams extends AssetTransfersParams {
  withMetadata: true;
}

/**
 * Categories of transfers to use with the {@link AssetTransfersParams} request
 * object when using {@link CoreNamespace.getAssetTransfers}.
 *
 * @public
 */
export enum AssetTransfersCategory {
  /**
   * Top level ETH transactions that occur where the `fromAddress` is an
   * external user-created address. External addresses have private keys and are
   * accessed by users.
   */
  EXTERNAL = 'external',

  /**
   * Top level ETH transactions that occur where the `fromAddress` is an
   * internal, smart contract address. For example, a smart contract calling
   * another smart contract or sending
   */
  INTERNAL = 'internal',

  /** ERC20 transfers. */
  ERC20 = 'erc20',

  /** ERC721 transfers. */
  ERC721 = 'erc721',

  /** ERC1155 transfers. */
  ERC1155 = 'erc1155',

  /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */
  SPECIALNFT = 'specialnft'
}

/**
 * Response object for the {@link CoreNamespace.getAssetTransfers} method.
 *
 * @public
 */
export interface AssetTransfersResponse {
  transfers: AssetTransfersResult[];
  /** Page key for the next page of results, if one exists. */
  pageKey?: string;
}

/**
 * Response object for the {@link CoreNamespace.getAssetTransfers} method when
 * the {@link AssetTransfersWithMetadataParams} are used.
 *
 * @public
 */
export interface AssetTransfersWithMetadataResponse {
  transfers: AssetTransfersWithMetadataResult[];
  pageKey?: string;
}

/**
 * Represents a transfer event that is returned in a {@link AssetTransfersResponse}.
 *
 * @public
 */
export interface AssetTransfersResult {
  /** The unique ID of the transfer. */
  uniqueId: string;

  /** The category of the transfer. */
  category: AssetTransfersCategory;

  /** The block number where the transfer occurred. */
  blockNum: string;

  /** The from address of the transfer. */
  from: string;

  /** The to address of the transfer. */
  to: string | null;

  /**
   * Converted asset transfer value as a number (raw value divided by contract
   * decimal). `null` if ERC721 transfer or contract decimal not available.
   */
  value: number | null;

  /**
   * The raw ERC721 token id of the transfer as a hex string. `null` if not an
   * ERC721 transfer.
   */
  erc721TokenId: string | null;

  /**
   * A list of ERC1155 metadata objects if the asset transferred is an ERC1155
   * token. `null` if not an ERC1155 transfer.
   */
  erc1155Metadata: ERC1155Metadata[] | null;

  /** The token id of the token transferred. */
  tokenId: string | null;

  /**
   * Returns the token's symbol or ETH for other transfers. `null` if the
   * information was not available.
   */
  asset: string | null;

  /** The transaction hash of the transfer transaction. */
  hash: string;

  /** Information about the raw contract of the asset transferred. */
  rawContract: RawContract;
}

/**
 * Represents a transfer event that is returned in a
 * {@link AssetTransfersResponse} when {@link AssetTransfersWithMetadataParams} are used.
 *
 * @public
 */
export interface AssetTransfersWithMetadataResult extends AssetTransfersResult {
  /** Additional metadata about the transfer event. */
  metadata: AssetTransfersMetadata;
}

/**
 * The metadata object for a {@link AssetTransfersResult} when the
 * {@link AssetTransfersParams.withMetadata} field is set to true.
 *
 * @public
 */
export interface AssetTransfersMetadata {
  /** Timestamp of the block from which the transaction event originated. */
  blockTimestamp: string;
}

/**
 * The type of transfer for the request. Note that using `TO` will also include
 * NFTs that were minted by the owner.
 */
export enum GetTransfersForOwnerTransferType {
  'TO' = 'TO',
  'FROM' = 'FROM'
}

/**
 * Optional parameters object for the {@link NftNamespace.getTransfersForOwner} method.
 */
export interface GetTransfersForOwnerOptions {
  /**
   * List of NFT contract addresses to filter mints by. If omitted, defaults to
   * all contract addresses.
   */
  contractAddresses?: string[];

  /**
   * Filter mints by ERC721 vs ERC1155 contracts. If omitted, defaults to all
   * NFTs.
   */
  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;

  /**
   * Optional page key from an existing {@link TransfersNftResponse} to use for
   * pagination.
   */
  pageKey?: string;
}

/**
 * Enum for representing the supported sorting orders of the API.
 *
 * @public
 */
export enum SortingOrder {
  ASCENDING = 'asc',
  DESCENDING = 'desc'
}

/** The refresh result response object returned by {@link refreshContract}. */
export interface RefreshContractResult {
  /** The NFT contract address that was passed in to be refreshed. */
  contractAddress: string;

  /** The current state of the refresh request. */
  refreshState: NftRefreshState;

  /**
   * Percentage of tokens currently refreshed, represented as an integer string.
   * Field can be null if the refresh has not occurred.
   */
  progress: string | null;
}

/**
 * The parameter field of {@link TransactionReceiptsParams}.
 *
 * @public
 */
export interface TransactionReceiptsBlockNumber {
  /** The block number to get transaction receipts for. */
  blockNumber: string;
}

/**
 * The parameter field of {@link TransactionReceiptsParams}.
 *
 * @public
 */
export interface TransactionReceiptsBlockHash {
  /** The block hash to get transaction receipts for. */
  blockHash: string;
}

/**
 * The parameters to use with the {@link CoreNamespace.getTransactionReceipts} method.
 *
 * @public
 */
export type TransactionReceiptsParams =
  | TransactionReceiptsBlockNumber
  | TransactionReceiptsBlockHash;

/**
 * Response object for a {@link CoreNamespace.getTransactionReceipts} call.
 *
 * @public
 */
export interface TransactionReceiptsResponse {
  /** A list of transaction receipts for the queried block. */
  receipts: TransactionReceipt[] | null;
}

/** An OpenSea collection's approval status. */
export enum OpenSeaSafelistRequestStatus {
  /** Verified collection. */
  VERIFIED = 'verified',
  /** Collections that are approved on open sea and can be found in search results. */
  APPROVED = 'approved',
  /** Collections that requested safelisting on OpenSea. */
  REQUESTED = 'requested',
  /** Brand new collections. */
  NOT_REQUESTED = 'not_requested'
}

/**
 * The response object for the {@link findContractDeployer} function.
 *
 * @public
 */
export interface DeployResult {
  /** The address of the contract deployer, if it is available. */
  deployerAddress?: string;

  /** The block number the contract was deployed in. */
  blockNumber: number;
}

/**
 * Method names for Alchemy's custom Subscription API endpoints.
 *
 * This value is provided in the `method` field when creating an event filter on
 * the Websocket Namespace.
 */
export enum AlchemySubscription {
  PENDING_TRANSACTIONS = 'alchemy_pendingTransactions',
  MINED_TRANSACTIONS = 'alchemy_minedTransactions'
}

/**
 * Event filter for the {@link AlchemyWebSocketProvider.on} and
 * {@link AlchemyWebSocketProvider.once} methods to use Alchemy's custom
 * `alchemy_pendingTransactions` endpoint.
 *
 * Returns the transaction information for all pending transactions that match a
 * given filter. For full documentation, see:
 * {@link https://docs.alchemy.com/reference/alchemy-pendingtransactions}
 *
 * Note that excluding all optional parameters will return transaction
 * information for ALL pending transactions that are added to the mempool.
 *
 * @public
 */
export interface AlchemyPendingTransactionsEventFilter {
  method: AlchemySubscription.PENDING_TRANSACTIONS;

  /**
   * Filter pending transactions sent FROM the provided address or array of
   * addresses.
   *
   * If a {@link AlchemyPendingTransactionsEventFilter.toAddress} is also
   * present, then this filter will return transactions sent from the
   * `fromAddress` OR transactions received by the `toAddress`.
   */
  fromAddress?: string | string[];

  /**
   * Filter pending transactions sent TO the provided address or array of
   * addresses.
   *
   * If a {@link AlchemyPendingTransactionsEventFilter.fromAddress} is also
   * present, then this filter will return transactions sent from the
   * `fromAddress` OR transactions received by the `toAddress`.
   */
  toAddress?: string | string[];

  /**
   * Whether to only include transaction hashes and exclude the rest of the
   * transaction response for a smaller payload. Defaults to false (by default,
   * the entire transaction response is included).
   *
   * Note that setting only {@link hashesOnly} to true will return the same
   * response as subscribing to `newPendingTransactions`.
   */
  hashesOnly?: boolean;
}

/**
 * Event filter for the {@link AlchemyWebSocketProvider.on} and
 * {@link AlchemyWebSocketProvider.once} methods to use Alchemy's custom
 * `alchemy_minedTransactions` endpoint.
 *
 * Returns the transaction information for all mined transactions that match the
 * provided filter. For full documentation, see:
 * {@link https://docs.alchemy.com/reference/alchemy-minedtransactions}
 *
 * Note that excluding all optional parameters will return transaction
 * information for ALL mined transactions.
 *
 * @public
 */
export interface AlchemyMinedTransactionsEventFilter {
  method: AlchemySubscription.MINED_TRANSACTIONS;

  /**
   * Address filters to subscribe to. Defaults to all transactions if omitted.
   * Limit 100 address filters. Requires a non-empty array.
   */
  addresses?: NonEmptyArray<AlchemyMinedTransactionsAddress>;

  /**
   * Whether to include transactions that were removed from the mempool.
   * Defaults to false.
   */
  includeRemoved?: boolean;

  /**
   * Whether to only include transaction hashes and exclude the rest of the
   * transaction response for a smaller payload. Defaults to false (by default,
   * the entire transaction response is included).
   */
  hashesOnly?: boolean;
}

/**
 * Address filters for {@link AlchemyMinedTransactionsEventFilter}. Requires at
 * least one of the fields to be set.
 */
export type AlchemyMinedTransactionsAddress = RequireAtLeastOne<{
  to?: string;
  from?: string;
}>;

/**
 * Alchemy's event type that extends the default {@link EventType} interface to
 * also include Alchemy's Subscription API.
 *
 * @public
 */
export type AlchemyEventType = EventType | AlchemyEventFilter;

/**
 * This type represents the Alchemy's Subscription API endpoints as event
 * filters compatible with other ethers events.
 */
export type AlchemyEventFilter =
  | AlchemyMinedTransactionsEventFilter
  | AlchemyPendingTransactionsEventFilter;

/** Options for the {@link TransactNamespace.sendPrivateTransaction} method. */
export interface SendPrivateTransactionOptions {
  /**
   * Whether to use fast-mode. Defaults to false. Please note that fast mode
   * transactions cannot be cancelled using
   * {@link TransactNamespace.cancelPrivateTransaction}. method.
   *
   * See {@link https://docs.flashbots.net/flashbots-protect/rpc/fast-mode} for
   * more details.
   */
  fast: boolean;
}

/**
 * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.
 * Allows you to determine if the assets approved or / and transferred are
 * native, tokens or NFTs.
 */
export enum SimulateAssetType {
  /**
   * Native transfers that involve the currency of the chain the simulation is
   * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).
   */
  NATIVE = 'NATIVE',
  /** ERC20 approval or transfers. */
  ERC20 = 'ERC20',
  /** ERC721 approval or transfers. */
  ERC721 = 'ERC721',
  /** ERC1155 approval or transfers. */
  ERC1155 = 'ERC1155',
  /**
   * Special contracts that don't follow ERC 721/1155.Currently limited to
   * CryptoKitties and CryptoPunks.
   */
  SPECIAL_NFT = 'SPECIAL_NFT'
}

/**
 * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.
 */
export enum SimulateChangeType {
  /**
   * Represents a transaction that approved or disapproved permissions for a
   * contract.
   *
   * APPROVE without token ID → approve all tokens
   * APPROVE without amount → approve all amount
   * APPROVE with zero amount → approval being cleared
   */
  APPROVE = 'APPROVE',

  /**
   * Represents a transaction that transferred tokens from one address to another.
   */
  TRANSFER = 'TRANSFER'
}

/**
 * The error field returned in a {@link SimulateAssetChangesResponse} if the
 * simulation failed.
 */
export interface SimulateAssetChangesError extends Record<string, any> {
  /** The error message. */
  message: string;
}

/**
 * Represents an asset change from a call to
 * {@link TransactNamespace.simulateAssetChanges}.
 */
export interface SimulateAssetChangesChange {
  /** The type of asset from the transaction. */
  assetType: SimulateAssetType;

  /** The type of change from the transaction. */
  changeType: SimulateChangeType;

  /** The from address. */
  from: string;

  /** The to address. */
  to: string;

  /**
   * The raw amount as an integer string. Only available on TRANSFER changes for
   * NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes (field set to
   * '0').
   */
  rawAmount?: string;

  /**
   * The amount as an integer string. This value is calculated by applying the
   * `decimals` field to the `rawAmount` field. Only available on TRANSFER
   * changes for NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes
   * (field set to '0').
   */
  amount?: string;

  /** The name of the asset transferred, if available. */
  name?: string;

  /** The symbol of the asset transferred if available. */
  symbol?: string;

  /**
   * The number of decimals used by the ERC20 token. Set to 0 for APPROVE
   * changes. Field is undefined if it's not defined in the contract and not
   * available from other sources.
   */
  decimals?: number;

  /**
   * The contract address of the asset. Only applicable to ERC20, ERC721,
   * ERC1155, NFT and SPECIAL_NFT transactions.
   */
  contractAddress?: string;

  /**
   * URL for the logo of the asset, if available. Only applicable to ERC20 transactions.
   */
  logo?: string;

  /**
   * The token id of the asset transferred. Only applicable to ERC721,
   * ERC1155 and SPECIAL_NFT NFTs.
   */
  tokenId?: string;
}

/**
 * Response object for the {@link TransactNamespace.simulateAssetChanges} method.
 */
export interface SimulateAssetChangesResponse {
  /** An array of asset changes that resulted from the transaction. */
  changes: SimulateAssetChangesChange[];
  /**
   * The amount of gas used by the transaction represented as a hex string. The
   * field is undefined if an error occurred.
   */
  gasUsed?: string;
  /** Optional error field that is present if an error occurred. */
  error?: SimulateAssetChangesError;
}

/**
 * Authority used to decode calls and logs when using the
 * {@link TransactNamespace.simulateExecution} method.
 */
export enum DecodingAuthority {
  ETHERSCAN = 'ETHERSCAN'
}

/** The input or output parameters from a {@link DecodedDebugCallTrace}. */
export interface DecodedCallParam {
  /** Value of the parameter. */
  value: string;
  /** The name of the parameter. */
  name: string;
  /** The type of the parameter.*/
  type: string;
}

/** The input parameters from a {@link DecodedLog}. */
export interface DecodedLogInput extends DecodedCallParam {
  /** Whether the log is marked as indexed in the smart contract. */
  indexed: boolean;
}

/**
 * Decoded representation of the call trace that is part of a
 * {@link SimulationCallTrace}.
 */
export interface DecodedDebugCallTrace {
  /** The smart contract method called. */
  methodName: string;
  /** Method inputs. */
  inputs: DecodedCallParam[];
  /** Method outputs. */
  outputs: DecodedCallParam[];
  /** The source used to provide the decoded call trace. */
  authority: DecodingAuthority;
}

/** The type of call in a debug call trace. */
export enum DebugCallType {
  CREATE = 'CREATE',
  CALL = 'CALL',
  STATICCALL = 'STATICCALL',
  DELEGATECALL = 'DELEGATECALL'
}

/**
 * Debug call trace in a {@link SimulateExecutionResponse}.
 */
export interface SimulationCallTrace
  extends Omit<DebugCallTrace, 'revertReason' | 'calls'> {
  /** The type of call. */
  type: DebugCallType;
  /** A decoded version of the call. Provided on a best-effort basis. */
  decoded?: DecodedDebugCallTrace;
}

/**
 * Decoded representation of the debug log that is part of a
 * {@link SimulationDebugLog}.
 */

export interface DecodedLog {
  /** The decoded name of the log event. */
  eventName: string;
  /** The decoded inputs to the log. */
  inputs: DecodedLogInput[];
  /** The source used to provide the decoded log. */
  authority: DecodingAuthority;
}

/**
 * Debug log in a {@link SimulateExecutionResponse}.
 */
export interface SimulationDebugLog {
  /** An array of topics in the log. */
  topics: string[];
  /** The address of the contract that generated the log. */
  address: string;
  /** The data included the log. */
  data: string;
  /** A decoded version of the log. Provided on a best-effort basis. */
  decoded?: DecodedLog;
}

/** Response object for the {@link TransactNamespace.simulateExecution} method. */
export interface SimulateExecutionResponse {
  /**
   * An array of traces generated during simulation that represent the execution
   * of the transaction along with the decoded calls if available.
   */
  calls: SimulationCallTrace[];

  /**
   * An array of logs emitted during simulation along with the decoded logs if
   * available.
   */
  logs: SimulationDebugLog[];
}

/**
 * Response object for the {@link TransactNamespace.sendGasOptimizedTransaction} method.
 *
 * @internal
 */
// TODO(txjob): Remove internal tag once this feature is released.
export interface GasOptimizedTransactionResponse {
  /**
   * The tracking id. This can be used to check the status of the transaction
   * via {@link TransactNamespace.getGasOptimizedTransactionStatus}.
   */
  trackingId: string;

  /* An array of the transaction hashes from submitted transactions. */
  transactionHashes: string[];
}

/**
 * Response object for the
 * {@link TransactNamespace.getGasOptimizedTransactionStatus} method.
 *
 * @internal
 */
// TODO(txjob): Remove internal tag once this feature is released.
export interface GasOptimizedTransactionStatusResponse {
  /** The status of the submitted transaction job. */
  jobStatus: GasOptimizedTransactionStatus;

  /** An array of the submitted transactions hashes that have been attempted. */
  transactionHashesAttempted: string[];

  /** The final mined transaction hash if the job was completed successfully. */
  minedTransactionHash?: string;
}

/**
 * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}
 *
 * @internal
 */
// TODO(txjob): Remove internal tag once this feature is released.
export enum GasOptimizedTransactionStatus {
  UNSPECIFIED = 'TRANSACTION_JOB_STATUS_UNSPECIFIED',
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETE = 'COMPLETE',
  ABANDONED = 'ABANDONED'
}

/** SDK representation of a Webhook in the Notify API. */
export interface Webhook {
  /** The webhook's unique id. */
  id: string;
  /** The network the webhook is on. */
  network: Network;
  /** The type of webhook. */
  type: WebhookType;
  /** The url that the webhook sends its payload to. */
  url: string;
  /** Whether the webhook is currently active */
  isActive: boolean;
  /** The creation time of the webhook as an ISO string. */
  timeCreated: string;
  /** The signing key used to verify payloads for the webhook. */
  signingKey: string;
  /** The webhook version. All newly created webhooks default to V2. */
  version: WebhookVersion;
  /**
   * The app id of the app used for the webhook. This field is only present on
   * {@link MinedTransactionWebhook} and {@link DroppedTransactionWebhook}
   */
  appId?: string;
}

/** The version of the webhook. All newly created webhooks default to V2. */
export enum WebhookVersion {
  V1 = 'V1',
  V2 = 'V2'
}

/** The type of {@link Webhook}. */
export enum WebhookType {
  MINED_TRANSACTION = 'MINED_TRANSACTION',
  DROPPED_TRANSACTION = 'DROPPED_TRANSACTION',
  ADDRESS_ACTIVITY = 'ADDRESS_ACTIVITY',
  NFT_ACTIVITY = 'NFT_ACTIVITY',
  NFT_METADATA_UPDATE = 'NFT_METADATA_UPDATE',
  GRAPHQL = 'GRAPHQL'
}

/**
 * A Mined Transaction Webhook is used to notify your app whenever a transaction
 * sent through your API key gets successfully mined. This is useful if you want
 * to notify customers that their transaction went through.
 */
export interface MinedTransactionWebhook extends Webhook {
  type: WebhookType.MINED_TRANSACTION;
}

/**
 * A Dropped Transaction webhook is used to notify your app whenever a
 * transaction sent through your API key gets dropped. This can be useful if you
 * want to notify customers that their transactions were dropped.
 */
export interface DroppedTransactionWebhook extends Webhook {
  type: WebhookType.DROPPED_TRANSACTION;
}

/**
 * An Address Activity Webhook tracks ETH, ERC20, ERC721, and ERC1155 transfers
 * for the provided addresses. This can be used to notify your app with
 * real-time state changes when your tracked addresses send or receive tokens.
 */
export interface AddressActivityWebhook extends Webhook {
  type: WebhookType.ADDRESS_ACTIVITY;
}

/**
 * The NFT Activity Webhook tracks all ERC721 and ERC1155 activity. This can be
 * used to notify your app with real time state changes when an NFT is
 * transferred between addresses.
 */
export interface NftActivityWebhook extends Webhook {
  type: WebhookType.NFT_ACTIVITY;
}

/**
 * The NFT Metadata Update Webhook tracks all ERC721 and ERC1155 metadata updates.
 * This can be used to notify your app with real time state changes when an NFT's
 * metadata changes.
 */
export interface NftMetadataUpdateWebhook extends Webhook {
  type: WebhookType.NFT_METADATA_UPDATE;
}

/**
 * The Custom Webhook can track any event on every block (think transfers, staking,
 * minting, burning, approvals, etc.)
 * This can be used to notify your app with real time changes whenever an
 * EOA or a smart contract performs any action on-chain.
 */
export interface CustomGraphqlWebhook extends Webhook {
  type: WebhookType.GRAPHQL;
}

/** The response for a {@link NotifyNamespace.getAllWebhooks} method. */
export interface GetAllWebhooksResponse {
  /** All webhooks attached to the provided auth token. */
  webhooks: Webhook[];
  /** The total number of webhooks. */
  totalCount: number;
}

/** Options object for the {@link NotifyNamespace.getAddresses} method. */
export interface GetAddressesOptions {
  /** Number of addresses to fetch. */
  limit?: number;

  /** Page */
  pageKey?: string;
}

/** Response object for the {@link NotifyNamespace.getAddresses} method. */
export interface AddressActivityResponse {
  /** The addresses for the webhook. */
  addresses: string[];
  /** The total number of addresses. */
  totalCount: number;
  /** Optional page key used to fetch the remaining addresses. */
  pageKey?: string;
}

/** Response object for the {@link NotifyNamespace.getGraphqlQuery} method. */
export interface CustomGraphqlWebhookConfig {
  /** The graphql query for the webhook. */
  graphqlQuery: string;
}

/**
 * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order
 * to create a {@link MinedTransactionWebhook} or {@link DroppedTransactionWebhook}.
 *
 * The webhook will be created on the app and network associated with the appId.
 * To find the app id of a project, go to the Alchemy Dashboard in the Apps tab.
 * After clicking on an app, the app id is the string in the URL following 'apps/'.
 *
 * This is a temporary workaround for now. We're planning on detecting the app
 * id from the provided api key directly. Stay tuned!
 */
export interface TransactionWebhookParams {
  /** The app id of the project to create the webhook on. */
  appId: string;
}

/**
 * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order
 * to create a {@link NftActivityWebhook} or {@link NftMetadataUpdateWebhook}.
 */
export interface NftWebhookParams {
  /** Array of NFT filters the webhook should track. */
  filters: NftFilter[];
  /**
   * Optional network to create the webhook on. If omitted, the webhook will be
   * created on network of the app provided in the api key config.
   */
  network?: Network;
}

/**
 * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order
 * to create a {@link CustomGraphqlWebhook}
 */
export interface CustomGraphqlWebhookParams {
  /** GraphQL query */
  graphqlQuery: string;
  /**
   * Optional network to create the webhook on. If omitted, the webhook will be
   * created on network of the app provided in the api key config.
   */
  network?: Network;
  /**
   * Whether to only receive webhooks if the query on the block is not empty.
   * Defaults to false.
   */
  skipEmptyMessages?: boolean;
  /**
   * App IDs are now required for graphQL webhooks. You can find the app ID
   * following the steps here:
   * {@link https://docs.alchemy.com/reference/notify-api-faq#where-can-i-find-the-app-id}.
   *
   * The webhook will be created on the app and network associated with the appId.
   * To find the app id of a project, go to the Alchemy Dashboard in the Apps tab.
   * After clicking on an app, the app id is the string in the URL following 'apps/'.
   *
   * Note that although this property is marked as optional, it is *actually required*
   * for creating a custom GraphQL webhook. This is a workaround to avoid a breaking
   * change in the API.
   */
  appId?: string;
}

/**
 * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order
 * to create a {@link AddressActivityWebhook}.
 */
export interface AddressWebhookParams {
  /** Array of addresses the webhook should activity for. */
  addresses: string[];
  /**
   * Optional network to create the webhook on. If omitted, the webhook will be
   * created on network of the app provided in the api key config.
   */
  network?: Network;
}

/** NFT to track on a {@link NftActivityWebhook} or {@link NftMetadataUpdateWebhook}. */
export interface NftFilter {
  /** The contract address of the NFT. */
  contractAddress: string;
  /**
   * The token id of the NFT to track. If this field is omitted, defaults to
   * tracking all NFTs for the provided contract address.
   */
  tokenId?: BigNumberish;
}

/** Response object for the {@link NotifyNamespace.getNftFilters} method. */
export interface NftFiltersResponse {
  /** The NFT filters on the provided webhook. */
  filters: NftFilter[];
  /** The total number of NFT filters on the webhook. */
  totalCount: number;
  /** Optional page key used to fetch the remaining filters. */
  pageKey?: string;
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to mark a
 * webhook as active or inactive.
 */
export interface WebhookStatusUpdate {
  /** Whether the webhook is active. */
  isActive: boolean;
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to add and
 * remove NFT filters for a {@link NftActivityWebhook}.
 */
export interface WebhookNftFilterUpdate {
  /** The filters to additionally track. */
  addFilters: NftFilter[];
  /** Existing filters to remove. */
  removeFilters: NftFilter[];
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to add and
 * remove NFT filters for a {@link NftMetadataUpdateWebhook}.
 */
export interface WebhookNftMetadataFilterUpdate {
  /** The filters to additionally track. */
  addMetadataFilters: NftFilter[];
  /** Existing filters to remove. */
  removeMetadataFilters: NftFilter[];
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to add and
 * remove addresses for a {@link AddressActivityWebhook}.
 */
export interface WebhookAddressUpdate {
  /** The addresses to additionally track. */
  addAddresses: string[];
  /** Existing addresses to remove. */
  removeAddresses: string[];
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to replace
 * all existing addresses for a {@link AddressActivityWebhook}.
 */
export interface WebhookAddressOverride {
  /** The new addresses to track. Existing addresses will be removed. */
  newAddresses: string[];
}

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to update a
 * {@link NftActivityWebhook}.
 */
export type NftWebhookUpdate =
  | WebhookStatusUpdate
  | RequireAtLeastOne<WebhookNftFilterUpdate>;

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to update a
 * {@link NftMetadataUpdateWebhook}.
 */
export type NftMetadataWebhookUpdate =
  | WebhookStatusUpdate
  | RequireAtLeastOne<WebhookNftMetadataFilterUpdate>;

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to update a
 * {@link CustomGraphqlWebhook}.
 */
export type CustomGraphqlWebhookUpdate = WebhookStatusUpdate;

/**
 * Params object when calling {@link NotifyNamespace.updateWebhook} to update a
 * {@link AddressActivityWebhook}.
 */
export type AddressWebhookUpdate =
  | WebhookStatusUpdate
  | RequireAtLeastOne<WebhookAddressUpdate>
  | WebhookAddressOverride;

/**
 * Transaction object used in {@link DebugNamespace.traceCall}, {@link TransactNamespace.simulateAssetChanges} and {@link TransactNamespace.simulateExecution}.
 */
export interface DebugTransaction {
  /** The address the transaction is directed to. */
  to?: string;
  /** The address the transaction is sent from. */
  from?: string;
  /** The gas provided for the transaction execution, as a hex string. */
  gas?: string;
  /** The gas price to use as a hex string. */
  gasPrice?: string;
  /** The value associated with the transaction as a hex string. */
  value?: string;
  /** The data associated with the transaction. */
  data?: string;
}

/**
 * Commitment level of the target block with using methods in the
 * {@link DebugNamespace}
 */
export enum CommitmentLevel {
  /**
   * Sample next block inferred by Alchemy built on top of the latest block.
   * This contains the set of transactions taken from the local mempool and
   * is a proxy for blocks that have not been mined yet.
   */
  PENDING = 'pending',
  /**
   * The most recent block in the canonical chain observed by Alchemy. Note that
   * this block may be re-orged out of the canonical chain.
   */
  LATEST = 'latest',
  /**
   * The most recent crypto-economically secure block that cannot be re-orged
   * outside of manual intervention driven by community coordination. This is
   * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.
   */
  SAFE = 'safe',
  /**
   * The most recent secure block that has been accepted by >2/3 of validators.
   * This block is very unlikely to be re-orged. This is only available on
   * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.
   */
  FINALIZED = 'finalized',
  /**
   * The lowest numbered block available that is usually the first block created.
   */
  EARLIEST = 'earliest'
}

/**
 * The block identifier to specify which block to run a debug call in, used for
 * methods in the {@link DebugNamespace}.
 */
export type BlockIdentifier = string | CommitmentLevel;

/**
 * The type of tracer to use when running debug methods in the
 * {@link DebugNamespace}.
 */
export enum DebugTracerType {
  CALL_TRACER = 'callTracer',
  PRESTATE_TRACER = 'prestateTracer'
}

/**
 * Tracer used with debug methods in the {@link DebugNamespace}.
 *
 * This tracer tracks all call frames executed during a transaction, including
 * depth 0. The returned result {@link DebugCallTrace} is a nested list of call
 * frames executed as part of the call.
 *
 * Here are some things to note when using the call tracer:
 * - Calls to precompiles are also included in the result.
 * - In case a frame reverts, the field output will contain the raw return data.
 * - In case the top level frame reverts, its `revertReason` field will contain
 *   the parsed reason of revert as returned by the Solidity contract
 */
export interface DebugCallTracer {
  /** Specified type is `CALL_TRACER`. */
  type: DebugTracerType.CALL_TRACER;
  /**
   * Whether to only trace the main (top-level) calls and ignore sub-calls.
   * Defaults to `false`.
   */
  onlyTopCall?: boolean;
}

/**
 * Tracer used with debug methods in the {@link DebugNamespace}.
 *
 * This tracer replays the transaction and tracks every part of state that was
 * touched during the transaction.
 *
 * Returns a {@link DebugPrestateTrace}. This contains sufficient information to
 * create a local execution of the transaction from a custom assembled genesis
 * block.
 */
export interface DebugPrestateTracer {
  /** Specified type is `PRESTATE_TRACER`. */
  type: DebugTracerType.PRESTATE_TRACER;
  /**
   * Whether to only trace the main (top-level) calls and ignore sub-calls.
   * Defaults to `false`.
   */
  onlyTopCall?: boolean;
}

/**
 * Debug result returned when using a {@link DebugCallTracer}.
 */
export interface DebugCallTrace {
  /** The type of call: `CALL` or `CREATE` for the top-level call. */
  type: string;
  /** From address of the transaction. */
  from: string;
  /** To address of the transaction. */
  to: string;
  /** Amount of value transfer as a hex string. */
  value: string;
  /** Gas provided for call as a hex string. */
  gas: string;
  /** Gas used during the call as a hex string. */
  gasUsed: string;
  /** Call data. */
  input: string;
  /** Return data. */
  output: string;
  /** Optional error field. */
  error?: string;
  /** Solidity revert reason, if the call reverted. */
  revertReason?: string;
  /** Array of sub-calls executed as part of the original call. */
  calls?: DebugCallTrace[];
}

/**
 * Filter object used to filter logs by a specific block hash when using
 * {@link CoreNamespace.getLogs}.
 */
export interface FilterByBlockHash extends EventFilter {
  /** The specific block hash to search for logs matching the filter. */
  blockHash?: string;
}

/**
 * Filter object used to filter logs by block number range when using
 * {@link CoreNamespace.getLogs}
 */
export interface Filter extends EventFilter {
  /** The starting block (inclusive) to search for logs matching the filter. */
  fromBlock?: BlockTag;
  /** The end block (inclusive) to search for logs matching the filter.*/
  toBlock?: BlockTag;
}

/**
 * Filter object used to filter logs by when using {@link CoreNamespace.getLogs}
 */
export interface EventFilter {
  /** The address to filter by. If omitted, filters for all addresses. */
  address?: string | string[];
  /** The topics to filter by, or null to match any topics. */
  topics?: Array<string | Array<string> | null>;
}

/**
 * Debug result returned by a {@link DebugPrestateTracer}.
 *
 * The keys are the addresses of the accounts, mapped to its corresponding state.
 */
export type DebugPrestateTrace = Record<string, DebugPrestate>;

/** The */
export interface DebugPrestate {
  /** Balance of the account in wei as a hex string. */
  balance: string;
  /** Nonce */
  nonce: number;
  /** Hex-encoded bytecode. */
  code: string;
  /** Storage slots of the contract. */
  storage: Record<string, string>;
}

/**
 * Requires at least one of the properties to be set.
 *
 * Implementation copied over from
 * {@link https://learn.microsoft.com/en-us/javascript/api/@azure/keyvault-certificates/requireatleastone?view=azure-node-latest}
 */
export type RequireAtLeastOne<T> = {
  [K in keyof T]-?: Required<Pick<T, K>> &
    Partial<Pick<T, Exclude<keyof T, K>>>;
}[keyof T];

/** Requires an array with at least one value. */
export type NonEmptyArray<T> = [T, ...T[]];


================================================================================
File: src\util\const.ts
Size: 11.63 kB
================================================================================

import { Network as NetworkFromEthers } from '@ethersproject/networks';

import { Network } from '../types/types';

export const DEFAULT_ALCHEMY_API_KEY = 'demo';
export const DEFAULT_NETWORK = Network.ETH_MAINNET;
export const DEFAULT_MAX_RETRIES = 5;
export const DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout

/**
 * Returns the base URL for making Alchemy API requests. The `alchemy.com`
 * endpoints only work with non eth json-rpc requests.
 *
 * @internal
 */
export function getAlchemyHttpUrl(network: Network, apiKey: string): string {
  return `https://${network}.g.alchemy.com/v2/${apiKey}`;
}

export function getAlchemyNftHttpUrl(network: Network, apiKey: string): string {
  return `https://${network}.g.alchemy.com/nft/v3/${apiKey}`;
}

export function getAlchemyWsUrl(network: Network, apiKey: string): string {
  return `wss://${network}.g.alchemy.com/v2/${apiKey}`;
}

export function getAlchemyWebhookHttpUrl(): string {
  return 'https://dashboard.alchemy.com/api';
}

export function getPricesBaseUrl(apiKey: string): string {
  return `https://api.g.alchemy.com/prices/v1/${apiKey}`;
}

export enum AlchemyApiType {
  BASE,
  NFT,
  WEBHOOK,
  PRICES
}

/**
 * Mapping of network names to their corresponding Network strings used to
 * create an Ethers.js Provider instance.
 */
export const EthersNetwork = {
  [Network.ETH_MAINNET]: 'mainnet',
  [Network.ETH_GOERLI]: 'goerli',
  [Network.ETH_SEPOLIA]: 'sepolia',
  [Network.ETH_HOLESKY]: 'holesky',
  [Network.OPT_MAINNET]: 'optimism',
  [Network.OPT_GOERLI]: 'optimism-goerli',
  [Network.OPT_SEPOLIA]: 'optimism-sepolia',
  [Network.ARB_MAINNET]: 'arbitrum',
  [Network.ARB_GOERLI]: 'arbitrum-goerli',
  [Network.ARB_SEPOLIA]: 'arbitrum-sepolia',
  [Network.MATIC_MAINNET]: 'matic',
  [Network.MATIC_MUMBAI]: 'maticmum',
  [Network.MATIC_AMOY]: 'maticamoy',
  [Network.ASTAR_MAINNET]: 'astar-mainnet',
  [Network.POLYGONZKEVM_MAINNET]: 'polygonzkevm-mainnet',
  [Network.POLYGONZKEVM_TESTNET]: 'polygonzkevm-testnet',
  [Network.POLYGONZKEVM_CARDONA]: 'polygonzkevm-cardona',
  [Network.BASE_MAINNET]: 'base-mainnet',
  [Network.BASE_GOERLI]: 'base-goerli',
  [Network.BASE_SEPOLIA]: 'base-sepolia',
  [Network.ZKSYNC_MAINNET]: 'zksync-mainnet',
  [Network.ZKSYNC_SEPOLIA]: 'zksync-sepolia',
  [Network.SHAPE_MAINNET]: 'shape-mainnet',
  [Network.SHAPE_SEPOLIA]: 'shape-sepolia',
  [Network.LINEA_MAINNET]: 'linea-mainnet',
  [Network.LINEA_SEPOLIA]: 'linea-sepolia',
  [Network.FANTOM_MAINNET]: 'fantom-mainnet',
  [Network.FANTOM_TESTNET]: 'fantom-testnet',
  [Network.ZETACHAIN_MAINNET]: 'zetachain-mainnet',
  [Network.ZETACHAIN_TESTNET]: 'zetachain-testnet',
  [Network.ARBNOVA_MAINNET]: 'arbnova-mainnet',
  [Network.BLAST_MAINNET]: 'blast-mainnet',
  [Network.BLAST_SEPOLIA]: 'blast-sepolia',
  [Network.MANTLE_MAINNET]: 'mantle-mainnet',
  [Network.MANTLE_SEPOLIA]: 'mantle-sepolia',
  [Network.SCROLL_MAINNET]: 'scroll-mainnet',
  [Network.SCROLL_SEPOLIA]: 'scroll-sepolia',
  [Network.GNOSIS_MAINNET]: 'gnosis-mainnet',
  [Network.GNOSIS_CHIADO]: 'gnosis-chiado',
  [Network.BNB_MAINNET]: 'bnb-mainnet',
  [Network.BNB_TESTNET]: 'bnb-testnet',
  [Network.AVAX_MAINNET]: 'avax-mainnet',
  [Network.AVAX_FUJI]: 'avax-fuji',
  [Network.CELO_MAINNET]: 'celo-mainnet',
  [Network.CELO_ALFAJORES]: 'celo-alfajores',
  [Network.METIS_MAINNET]: 'metis-mainnet',
  [Network.OPBNB_MAINNET]: 'opbnb-mainnet',
  [Network.OPBNB_TESTNET]: 'opbnb-testnet',
  [Network.BERACHAIN_BARTIO]: 'berachain-bartio',
  [Network.BERACHAIN_MAINNET]: 'berachain-mainnet',
  [Network.SONEIUM_MAINNET]: 'soneium-mainnet',
  [Network.SONEIUM_MINATO]: 'soneium-minato',
  [Network.WORLDCHAIN_MAINNET]: 'worldchain-mainnet',
  [Network.WORLDCHAIN_SEPOLIA]: 'worldchain-sepolia',
  [Network.ROOTSTOCK_MAINNET]: 'rootstock-mainnet',
  [Network.ROOTSTOCK_TESTNET]: 'rootstock-testnet',
  [Network.FLOW_MAINNET]: 'flow-mainnet',
  [Network.FLOW_TESTNET]: 'flow-testnet',
  [Network.ZORA_MAINNET]: 'zora-mainnet',
  [Network.ZORA_SEPOLIA]: 'zora-sepolia',
  [Network.FRAX_MAINNET]: 'frax-mainnet',
  [Network.FRAX_SEPOLIA]: 'frax-sepolia',
  [Network.POLYNOMIAL_MAINNET]: 'polynomial-mainnet',
  [Network.POLYNOMIAL_SEPOLIA]: 'polynomial-sepolia',
  [Network.CROSSFI_MAINNET]: 'crossfi-mainnet',
  [Network.CROSSFI_TESTNET]: 'crossfi-testnet',
  [Network.APECHAIN_MAINNET]: 'apechain-mainnet',
  [Network.APECHAIN_CURTIS]: 'apechain-curtis',
  [Network.LENS_SEPOLIA]: 'lens-sepolia',
  [Network.GEIST_MAINNET]: 'geist-mainnet',
  [Network.GEIST_POLTER]: 'geist-polter',
  [Network.LUMIA_PRISM]: 'lumia-prism',
  [Network.LUMIA_TESTNET]: 'lumia-testnet',
  [Network.UNICHAIN_MAINNET]: 'unichain-mainnet',
  [Network.UNICHAIN_SEPOLIA]: 'unichain-sepolia',
  [Network.SONIC_MAINNET]: 'sonic-mainnet',
  [Network.SONIC_BLAZE]: 'sonic-blaze',
  [Network.XMTP_TESTNET]: 'xmtp-testnet',
  [Network.ABSTRACT_MAINNET]: 'abstract-mainnet',
  [Network.ABSTRACT_TESTNET]: 'abstract-testnet',
  [Network.DEGEN_MAINNET]: 'degen-mainnet',
  [Network.INK_MAINNET]: 'ink-mainnet',
  [Network.INK_SEPOLIA]: 'ink-sepolia',
  [Network.SEI_TESTNET]: 'sei-testnet'
};

/**
 * Mapping of network names to their corresponding Ethers Network objects. These
 * networks are not yet supported by Ethers and are listed here to be overriden
 * in the provider.
 */
export const CustomNetworks: { [key: string]: NetworkFromEthers } = {
  'arbitrum-goerli': {
    chainId: 421613,
    name: 'arbitrum-goerli'
  },
  'arbitrum-sepolia': {
    chainId: 421614,
    name: 'arbitrum-sepolia'
  },
  'astar-mainnet': {
    chainId: 592,
    name: 'astar-mainnet'
  },
  sepolia: {
    chainId: 11155111,
    name: 'sepolia'
  },
  holesky: {
    chainId: 17000,
    name: 'holesky'
  },
  'optimism-sepolia': {
    chainId: 11155420,
    name: 'optimism-sepolia'
  },
  'polygonzkevm-mainnet': {
    chainId: 1101,
    name: 'polygonzkevm-mainnet'
  },
  'polygonzkevm-testnet': {
    chainId: 1442,
    name: 'polygonzkevm-testnet'
  },
  'polygonzkevm-cardona': {
    chainId: 2442,
    name: 'polygonzkevm-cardona'
  },
  'base-mainnet': {
    chainId: 8453,
    name: 'base-mainnet'
  },
  'base-goerli': {
    chainId: 84531,
    name: 'base-goerli'
  },
  'base-sepolia': {
    chainId: 84532,
    name: 'base-sepolia'
  },
  maticamoy: {
    chainId: 80002,
    name: 'maticamoy'
  },
  'zksync-mainnet': {
    chainId: 324,
    name: 'zksync-mainnet'
  },
  'zksync-sepolia': {
    chainId: 300,
    name: 'zksync-sepolia'
  },
  'shape-mainnet': {
    chainId: 360,
    name: 'shape-mainnet'
  },
  'shape-sepolia': {
    chainId: 11011,
    name: 'shape-sepolia'
  },
  'linea-mainnet': {
    chainId: 59144,
    name: 'linea-mainnet'
  },
  'linea-sepolia': {
    chainId: 59141,
    name: 'linea-sepolia'
  },
  'fantom-mainnet': {
    chainId: 250,
    name: 'fantom-mainnet'
  },
  'fantom-testnet': {
    chainId: 4002,
    name: 'fantom-testnet'
  },
  'zetachain-mainnet': {
    chainId: 7000,
    name: 'zetachain-mainnet'
  },
  'zetachain-testnet': {
    chainId: 7001,
    name: 'zetachain-testnet'
  },
  'arbnova-mainnet': {
    chainId: 42170,
    name: 'arbnova-mainnet'
  },
  'blast-mainnet': {
    chainId: 81457,
    name: 'blast-mainnet'
  },
  'blast-sepolia': {
    chainId: 168587773,
    name: 'blast-sepolia'
  },
  'mantle-mainnet': {
    chainId: 5000,
    name: 'mantle-mainnet'
  },
  'mantle-sepolia': {
    chainId: 5003,
    name: 'mantle-sepolia'
  },
  'scroll-mainnet': {
    chainId: 534352,
    name: 'scroll-mainnet'
  },
  'scroll-sepolia': {
    chainId: 534351,
    name: 'scroll-sepolia'
  },
  'gnosis-mainnet': {
    chainId: 100,
    name: 'gnosis-mainnet'
  },
  'gnosis-chiado': {
    chainId: 10200,
    name: 'gnosis-chiado'
  },
  'bnb-mainnet': {
    chainId: 56,
    name: 'bnb-mainnet'
  },
  'bnb-testnet': {
    chainId: 97,
    name: 'bnb-testnet'
  },
  'avax-mainnet': {
    chainId: 43114,
    name: 'avax-mainnet'
  },
  'avax-fuji': {
    chainId: 43113,
    name: 'avax-fuji'
  },
  'celo-mainnet': {
    chainId: 42220,
    name: 'celo-mainnet'
  },
  'celo-alfajores': {
    chainId: 44787,
    name: 'celo-alfajores'
  },
  'metis-mainnet': {
    chainId: 1088,
    name: 'metis-mainnet'
  },
  'opbnb-mainnet': {
    chainId: 204,
    name: 'opbnb-mainnet'
  },
  'opbnb-testnet': {
    chainId: 5611,
    name: 'opbnb-testnet'
  },
  'berachain-bartio': {
    chainId: 80084,
    name: 'berachain-bartio'
  },
  'berachain-mainnet': {
    chainId: 80094,
    name: 'berachain-mainnet'
  },
  'soneium-mainnet': {
    chainId: 1868,
    name: 'soneium-mainnet'
  },
  'soneium-minato': {
    chainId: 0x79a,
    name: 'soneium-minato'
  },
  'worldchain-mainnet': {
    chainId: 0x1e0,
    name: 'worldchain-mainnet'
  },
  'worldchain-sepolia': {
    chainId: 0x12c1,
    name: 'worldchain-sepolia'
  },
  'rootstock-mainnet': {
    chainId: 0x1e,
    name: 'rootstock-mainnet'
  },
  'rootstock-testnet': {
    chainId: 0x1f,
    name: 'rootstock-testnet'
  },
  'flow-mainnet': {
    chainId: 747,
    name: 'flow-mainnet'
  },
  'flow-testnet': {
    chainId: 545,
    name: 'flow-testnet'
  },
  'zora-mainnet': {
    chainId: 7777777,
    name: 'zora-mainnet'
  },
  'zora-sepolia': {
    chainId: 999999999,
    name: 'zora-sepolia'
  },
  'frax-mainnet': {
    chainId: 252,
    name: 'frax-mainnet'
  },
  'frax-sepolia': {
    chainId: 2522,
    name: 'frax-sepolia'
  },
  'polynomial-mainnet': {
    chainId: 8008,
    name: 'polynomial-mainnet'
  },
  'polynomial-sepolia': {
    chainId: 8009,
    name: 'polynomial-sepolia'
  },
  'crossfi-mainnet': {
    chainId: 4158,
    name: 'crossfi-mainnet'
  },
  'crossfi-testnet': {
    chainId: 4157,
    name: 'crossfi-testnet'
  },
  'apechain-mainnet': {
    chainId: 33139,
    name: 'apechain-mainnet'
  },
  'apechain-curtis': {
    chainId: 33111,
    name: 'apechain-curtis'
  },
  'lens-sepolia': {
    chainId: 0x90f7,
    name: 'lens-sepolia'
  },
  'geist-mainnet': {
    chainId: 63157,
    name: 'geist-mainnet'
  },
  'geist-polter': {
    chainId: 631571,
    name: 'geist-polter'
  },
  'lumia-prism': {
    chainId: 0x3b4c8eb9,
    name: 'lumia-prism'
  },
  'lumia-testnet': {
    chainId: 0x7467cbf8,
    name: 'lumia-testnet'
  },
  'unichain-mainnet': {
    chainId: 130,
    name: 'unichain-mainnet'
  },
  'unichain-sepolia': {
    chainId: 0x515,
    name: 'unichain-sepolia'
  },
  'sonic-mainnet': {
    chainId: 0x92,
    name: 'sonic-mainnet'
  },
  'sonic-blaze': {
    chainId: 0xdede,
    name: 'sonic-blaze'
  },
  'xmtp-testnet': {
    chainId: 241320161,
    name: 'xmtp-testnet'
  },
  'abstract-mainnet': {
    chainId: 2741,
    name: 'abstract-mainnet'
  },
  'abstract-testnet': {
    chainId: 11124,
    name: 'abstract-testnet'
  },
  'degen-mainnet': {
    chainId: 0x27bc86aa,
    name: 'degen-mainnet'
  },
  'ink-mainnet': {
    chainId: 0xdef1,
    name: 'ink-mainnet'
  },
  'ink-sepolia': {
    chainId: 0xba5ed,
    name: 'ink-sepolia'
  },
  'sei-testnet': {
    chainId: 1328,
    name: 'sei-testnet'
  }
};

export function noop(): void {
  // It's a no-op
}

export const ETH_NULL_VALUE = '0x';

export const ETH_NULL_ADDRESS = '0x0000000000000000000000000000000000000000';


================================================================================
File: src\util\inputSanitization.ts
Size: 328 B
================================================================================

import { InputNftTokenType } from '../internal/nft-api';
import { NftTokenType } from '../types/nft-types';

export function sanitizeTokenType(tokenType?: NftTokenType): InputNftTokenType {
  if (tokenType === NftTokenType.ERC1155 || tokenType === NftTokenType.ERC721) {
    return tokenType;
  }
  return undefined;
}


================================================================================
File: src\util\logger.ts
Size: 3.78 kB
================================================================================

/**
 * The SDK has 4 log levels and a 5th option for disabling all logging. By
 * default, the log level is set to INFO.
 *
 * The order is a follows: DEBUG < INFO < WARN < ERROR
 *
 * All log types above the current log level will be outputted.
 */
export enum LogLevel {
  DEBUG,
  INFO,
  WARN,
  ERROR,
  SILENT
}

/**
 * The level of verbosity for the logger.
 *
 * @public
 */
export type LogLevelString = 'debug' | 'info' | 'warn' | 'error' | 'silent';

const logLevelStringToEnum: { [key in LogLevelString]: LogLevel } = {
  debug: LogLevel.DEBUG,
  info: LogLevel.INFO,
  warn: LogLevel.WARN,
  error: LogLevel.ERROR,
  silent: LogLevel.SILENT
};

// HACKY: Use the console method as a string rather than the function itself
// in order to allow for mocking in tests.
const logLevelToConsoleFn = {
  [LogLevel.DEBUG]: 'log',
  [LogLevel.INFO]: 'info',
  [LogLevel.WARN]: 'warn',
  [LogLevel.ERROR]: 'error'
};

const DEFAULT_LOG_LEVEL = LogLevel.INFO;

/**
 * Configures the verbosity of logging. The default log level is `info`.
 *
 * @param logLevel - The verbosity of logging. Can be any of the following values:
 *
 *   - `debug`: The most verbose logging level.
 *   - `info`: The default logging level.
 *   - `warn`: A logging level for non-critical issues.
 *   - `error`: A logging level for critical issues.
 *   - `silent`: Turn off all logging.
 *
 * @public
 */
export function setLogLevel(logLevel: LogLevelString): void {
  loggerClient.logLevel = logLevelStringToEnum[logLevel];
}

export function logDebug(message: string, ...args: unknown[]): void {
  loggerClient.debug(message, args);
}

export function logInfo(message: string, ...args: unknown[]): void {
  loggerClient.info(message, args);
}

export function logWarn(message: string, ...args: unknown[]): void {
  loggerClient.warn(message, args);
}

export function logError(message: string, ...args: unknown[]): void {
  loggerClient.error(message, args);
}

export class Logger {
  /** The log level of the given Logger instance. */
  private _logLevel = DEFAULT_LOG_LEVEL;

  constructor() {}

  get logLevel(): LogLevel {
    return this._logLevel;
  }

  set logLevel(val: LogLevel) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }

  debug(...args: unknown[]): void {
    this._log(LogLevel.DEBUG, ...args);
  }

  info(...args: unknown[]): void {
    this._log(LogLevel.INFO, ...args);
  }

  warn(...args: unknown[]): void {
    this._log(LogLevel.WARN, ...args);
  }

  error(...args: unknown[]): void {
    this._log(LogLevel.ERROR, ...args);
  }

  /**
   * Forwards log messages to their corresponding console counterparts if the
   * log level allows it.
   */
  private _log(logLevel: LogLevel, ...args: unknown[]): void {
    if (logLevel < this._logLevel) {
      return;
    }
    const now = new Date().toISOString();
    const method =
      logLevelToConsoleFn[logLevel as keyof typeof logLevelToConsoleFn];
    if (method) {
      console[method as 'log' | 'info' | 'warn' | 'error'](
        `[${now}] Alchemy:`,
        ...args.map(stringify)
      );
    } else {
      throw new Error(
        `Logger received an invalid logLevel (value: ${logLevel})`
      );
    }
  }
}

function stringify(obj: unknown): string | unknown {
  if (typeof obj === 'string') {
    return obj;
  } else {
    try {
      return JSON.stringify(obj);
    } catch (e) {
      // Failed to convert to JSON, log the object directly.
      return obj;
    }
  }
}

// Instantiate default logger for the SDK.
const loggerClient: Logger = new Logger();


================================================================================
File: src\util\sendRest.ts
Size: 965 B
================================================================================

/**
 * Given a REST endpoint, method, and params, sends the request with axios and
 * returns the response.
 */
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';

import { VERSION } from '../version';
import { IS_BROWSER } from './util';

/**
 * Helper function to send http requests using Axis.
 *
 * @private
 */
export function sendAxiosRequest<Req, Res>(
  baseUrl: string,
  restApiName: string,
  methodName: string,
  params: Req,
  overrides?: AxiosRequestConfig
): Promise<AxiosResponse<Res>> {
  const requestUrl = baseUrl + '/' + restApiName;
  const config: AxiosRequestConfig = {
    ...overrides,
    headers: {
      ...overrides?.headers,
      ...(!IS_BROWSER && { 'Accept-Encoding': 'gzip' }),
      'Alchemy-Ethers-Sdk-Version': VERSION,
      'Alchemy-Ethers-Sdk-Method': methodName
    },
    method: overrides?.method ?? 'GET',
    url: requestUrl,
    params
  };
  return axios(config);
}


================================================================================
File: src\util\util.ts
Size: 6.57 kB
================================================================================

import { toHex } from '../api/util';
import {
  RawContractBaseNft,
  RawGetNftSalesResponse,
  RawNft,
  RawNftCollection,
  RawNftContract,
  RawNftContractForNft,
  RawNftContractForOwner,
  RawOwnedBaseNft
} from '../internal/raw-interfaces';
import {
  BaseNft,
  GetNftSalesResponse,
  Nft,
  NftCollection,
  NftCollectionMarketplace,
  NftContract,
  NftContractForNft,
  NftContractForOwner,
  NftSaleMarketplace,
  NftSaleTakerType,
  NftSpamClassification,
  NftTokenType
} from '../types/nft-types';
import { OpenSeaSafelistRequestStatus } from '../types/types';

export function formatBlock(block: string | number): string {
  if (typeof block === 'string') {
    return block;
  } else if (Number.isInteger(block)) {
    return toHex(block);
  }
  return block.toString();
}

function stringToEnum<T extends string>(
  x: string,
  enumb: Record<string, T>
): T | null {
  return Object.values(enumb).includes(x as T) ? (x as T) : null;
}

export function getNftContractForNftFromRaw(
  rawNftContract: RawNftContractForNft
): NftContractForNft {
  return nullsToUndefined<NftContractForNft>({
    ...getNftContractFromRaw(rawNftContract),
    spamClassifications: rawNftContract.spamClassifications.map(
      parseNftSpamClassification
    )
  });
}

export function getNftContractsForOwnerFromRaw(
  rawNftContract: RawNftContractForOwner
): NftContractForOwner {
  return nullsToUndefined<NftContractForOwner>({
    ...getNftContractFromRaw(rawNftContract),
    displayNft: rawNftContract.displayNft,
    image: rawNftContract.image,
    totalBalance: rawNftContract.totalBalance,
    numDistinctTokensOwned: rawNftContract.numDistinctTokensOwned,
    isSpam: rawNftContract.isSpam
  });
}

export function getNftContractFromRaw(
  rawNftContract: RawNftContract
): NftContract {
  return nullsToUndefined<NftContract>({
    ...rawNftContract,
    tokenType: parseNftTokenType(rawNftContract.tokenType),
    openSeaMetadata: {
      ...rawNftContract.openSeaMetadata,
      safelistRequestStatus: rawNftContract.openSeaMetadata
        ?.safelistRequestStatus
        ? stringToEnum(
            rawNftContract.openSeaMetadata.safelistRequestStatus,
            OpenSeaSafelistRequestStatus
          )
        : null
    }
  });
}

export function getNftCollectionFromRaw(
  rawNftCollection: RawNftCollection
): NftCollection {
  return nullsToUndefined<NftCollection>({
    ...rawNftCollection,
    floorPrice: {
      ...rawNftCollection.floorPrice,
      marketplace: parseNftCollectionMarketplace(
        rawNftCollection.floorPrice.marketplace
      )
    }
  });
}

export function getBaseNftFromRaw(rawBaseNft: RawOwnedBaseNft): BaseNft;
export function getBaseNftFromRaw(
  rawContractBaseNft: RawContractBaseNft,
  contractAddress: string
): BaseNft;
export function getBaseNftFromRaw(
  rawBaseNft: RawOwnedBaseNft | RawContractBaseNft,
  contractAddress?: string
): BaseNft {
  return {
    contractAddress: contractAddress
      ? contractAddress
      : (rawBaseNft as RawOwnedBaseNft).contractAddress,
    tokenId: rawBaseNft.tokenId
  };
}

export function getNftFromRaw(rawNft: RawNft): Nft {
  return nullsToUndefined<Nft>({
    ...rawNft,
    contract: getNftContractForNftFromRaw(rawNft.contract),
    tokenType: parseNftTokenType(rawNft.tokenType),
    acquiredAt: rawNft.acquiredAt,
    collection: rawNft.collection,
    mint: rawNft.mint
  });
}

export function getNftSalesFromRaw(
  rawNftSales: RawGetNftSalesResponse
): GetNftSalesResponse {
  return nullsToUndefined<GetNftSalesResponse>({
    nftSales: rawNftSales.nftSales.map(rawNftSale => ({
      ...rawNftSale,
      marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),
      taker: parseNftTaker(rawNftSale.taker)
    })),
    validAt: rawNftSales.validAt,
    pageKey: rawNftSales.pageKey
  });
}

function parseNftSaleMarketplace(marketplace: string): NftSaleMarketplace {
  switch (marketplace) {
    case 'looksrare':
      return NftSaleMarketplace.LOOKSRARE;
    case 'seaport':
      return NftSaleMarketplace.SEAPORT;
    case 'x2y2':
      return NftSaleMarketplace.X2Y2;
    case 'wyvern':
      return NftSaleMarketplace.WYVERN;
    case 'cryptopunks':
      return NftSaleMarketplace.CRYPTOPUNKS;
    case 'blur':
      return NftSaleMarketplace.BLUR;
    default:
      return NftSaleMarketplace.UNKNOWN;
  }
}

function parseNftCollectionMarketplace(
  marketplace: string | null
): NftCollectionMarketplace | undefined {
  switch (marketplace) {
    case 'OpenSea':
      return NftCollectionMarketplace.OPENSEA;
    default:
      return undefined;
  }
}

function parseNftTaker(taker: string): NftSaleTakerType {
  // The `.toLowerCase()` call is needed because the API returns the capitalized values
  switch (taker.toLowerCase()) {
    case 'buyer':
      return NftSaleTakerType.BUYER;
    case 'seller':
      return NftSaleTakerType.SELLER;
    default:
      throw new Error(`Unsupported NftSaleTakerType ${taker}`);
  }
}

function parseNftSpamClassification(s: string): NftSpamClassification {
  const res = stringToEnum(s, NftSpamClassification);
  if (res == null) {
    return NftSpamClassification.Unknown;
  }

  return res;
}

function parseNftTokenType(tokenType: string | undefined): NftTokenType {
  switch (tokenType) {
    case 'erc721':
    case 'ERC721':
      return NftTokenType.ERC721;
    case 'erc1155':
    case 'ERC1155':
      return NftTokenType.ERC1155;
    case 'no_supported_nft_standard':
    case 'NO_SUPPORTED_NFT_STANDARD':
      return NftTokenType.NO_SUPPORTED_NFT_STANDARD;
    case 'not_a_contract':
    case 'NOT_A_CONTRACT':
      return NftTokenType.NOT_A_CONTRACT;
    default:
      return NftTokenType.UNKNOWN;
  }
}

export const IS_BROWSER = typeof window !== 'undefined' && window !== null;

type WithNullableFields<T> = T extends undefined
  ? null | undefined
  : T extends (infer U)[]
  ? WithNullableFields<U>[]
  : T extends object
  ? {
      [K in keyof T]: WithNullableFields<T[K]>;
    }
  : T;

export function nullsToUndefined<U>(obj: WithNullableFields<U>): U {
  if (obj === null || obj === undefined) {
    return undefined as any;
  }

  if ((obj as any).constructor.name === 'Object' || Array.isArray(obj)) {
    for (const key in obj) {
      (obj as any)[key] = nullsToUndefined((obj as any)[key]);
    }
  }
  return obj as any;
}


================================================================================
File: src\version.ts
Size: 132 B
================================================================================

// This file is autogenerated by injectVersion.js. Any changes will be
// overwritten on commit!
export const VERSION = '3.5.3';


================================================================================
File: test\integration\alchemy.test.ts
Size: 2.24 kB
================================================================================

import { Alchemy, Network } from '../../src';
import { Deferred, loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);
describe('E2E integration tests', () => {
  beforeAll(async () => {
    await loadAlchemyEnv();
  });
  describe('handles networks', () => {
    // TODO(deprecation): Remove after removing deprecated networks.
    const deprecated = [
      'ropsten',
      'goerli',
      'kovan',
      'rinkeby',
      'mumbai',
      'polygonzkevm-testnet'
    ];
    // Filter out deprecated networks.
    const supportedNetworks = Object.values(Network).filter(
      network => !deprecated.some(key => network.includes(key))
    );

    describe('AlchemyProvider', () => {
      function testNetwork(network: Network) {
        it(`get blockNumber on ${network}`, async () => {
          console.log('testing network', network);
          const alchemy = new Alchemy({
            apiKey: process.env.ALCHEMY_API_KEY,
            network
          });
          const block = await alchemy.core.getBlockNumber();
          expect(block).toBeDefined();
        });
      }

      for (const network of supportedNetworks) {
        testNetwork(network);
      }
    });

    // Most of the new networks don't support WS, so no point running this test.
    describe.skip('AlchemyWebSocketProvider', () => {
      function testNetwork(network: Network) {
        it(`block subscription for ${network}`, () => {
          const alchemy = new Alchemy({
            apiKey: process.env.ALCHEMY_API_KEY,
            network
          });
          const done = new Deferred<void>();
          alchemy.ws.once('block', () => {
            alchemy.ws.removeAllListeners();
            done.resolve();
          });
          return done.promise;
        });
      }

      const excludedNetworks = [
        Network.ASTAR_MAINNET,
        Network.POLYGONZKEVM_MAINNET,
        Network.POLYGONZKEVM_TESTNET
      ];

      for (const network of supportedNetworks) {
        // TODO: Enable after Astar websockets work.
        if (excludedNetworks.includes(network)) {
          continue;
        }

        testNetwork(network);
      }
    });
  });
});


================================================================================
File: test\integration\core.test.ts
Size: 6.47 kB
================================================================================

import {
  Alchemy,
  AssetTransfersCategory,
  TokenBalanceType,
  fromHex
} from '../../src';
import { Utils } from '../../src/index';
import { loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);
// Integration tests for Alchemy's custom methods on top the core ethers' offerings.
describe('E2E integration tests', () => {
  let alchemy: Alchemy;

  beforeAll(async () => {
    await loadAlchemyEnv();
    alchemy = await new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY
    });

    // Skip all timeouts for testing.
    jest.setTimeout(50000);
  });

  it('checks if address is a contract', async () => {
    const contractAddress = '0x00000000006c3852cbEf3e08E8dF289169EdE581'; // Seaport contract address
    const result = await alchemy.core.isContractAddress(contractAddress);

    expect(result).toBe(true);
  });

  it('checks if address is an EOA', async () => {
    const eoaAddress = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'; // Vitalik's address
    const result = await alchemy.core.isContractAddress(eoaAddress);

    expect(result).toBe(false);
  });

  it('findContractDeployer()', async () => {
    // BAYC
    let contractAddress = '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D';
    let contractDeployer = await alchemy.core.findContractDeployer(
      contractAddress
    );
    expect(contractDeployer.deployerAddress).toEqual(
      '0xaba7161a7fb69c88e16ed9f455ce62b791ee4d03'
    );
    expect(contractDeployer.blockNumber).toEqual(12287507);

    // ENS
    contractAddress = '0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85';
    contractDeployer = await alchemy.core.findContractDeployer(contractAddress);
    expect(contractDeployer.deployerAddress).toEqual(
      '0x4fe4e666be5752f1fdd210f4ab5de2cc26e3e0e8'
    );
    expect(contractDeployer.blockNumber).toEqual(9380410);
  });

  it('getAssetTransfers()', async () => {
    // Replace with contract of your choosing
    const baycContract = '0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d';

    const allTransfers = await alchemy.core.getAssetTransfers({
      fromBlock: '0x0',
      contractAddresses: [baycContract],
      toAddress: '0xshah.eth',
      excludeZeroValue: true,
      category: [AssetTransfersCategory.ERC721],
      withMetadata: true
    });
    const firstTransfer = allTransfers.transfers[0];

    // General checks
    expect(firstTransfer.category).toEqual(AssetTransfersCategory.ERC721);
    expect(firstTransfer.rawContract.address).toEqual(baycContract);

    // First transfer specific checks
    expect(firstTransfer.blockNum).toEqual('0xc8f41b');
    expect(firstTransfer.metadata.blockTimestamp).toEqual(
      '2021-09-06T03:04:53.000Z'
    );
  });

  it('getTokenBalances()', async () => {
    // Supports ERC-20 + pageKey
    const address = 'vitalik.eth';
    const contract = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    let response = await alchemy.core.getTokenBalances(address, {
      type: TokenBalanceType.ERC20
    });
    expect(response.pageKey).toBeDefined();
    const response2 = await alchemy.core.getTokenBalances(address, {
      type: TokenBalanceType.ERC20,
      pageKey: response.pageKey
    });
    expect(response2.tokenBalances.length).toBeGreaterThan(0);
    expect(response.tokenBalances[0]).not.toEqual(response2.tokenBalances[0]);

    response = await alchemy.core.getTokenBalances(address, [contract]);
    expect(response.tokenBalances.length).toEqual(1);
  });

  it('getTransactionReceipts()', async () => {
    const blockNumber = (await alchemy.core.getBlockNumber()) - 20;
    const response = await alchemy.core.getTransactionReceipts({
      blockNumber: Utils.hexlify(blockNumber)
    });
    expect(response.receipts?.length).toBeGreaterThan(0);
    expect(fromHex(response.receipts![0].blockNumber.toString())).toEqual(
      blockNumber
    );
  });

  it('resolveName() / lookupAddress()', async () => {
    const name = 'vitalik.eth';
    const address = await alchemy.core.resolveName(name);
    expect(address).not.toBeNull();
    const finalName = await alchemy.core.lookupAddress(address!);
    expect(finalName).toEqual(name);
  });

  it('getLogs() with multiple address fields', async () => {
    const blockHash =
      '0x8243343df08b9751f5ca0c5f8c9c0460d8a9b6351066fae0acbd4d3e776de8bb';
    const address = [
      '0xb59f67a8bff5d8cd03f6ac17265c550ed8f33907',
      '0xf433089366899d83a9f26a773d59ec7ecf30355e'
    ];
    const logs = await alchemy.core.getLogs({
      blockHash,
      address
    });
    logs.forEach(log => {
      expect(log.blockHash).toEqual(blockHash);
      expect(address).toContain(log.address.toLowerCase());
    });
  });

  it('getLogs() with single and undefined address field', async () => {
    const blockHash =
      '0x8243343df08b9751f5ca0c5f8c9c0460d8a9b6351066fae0acbd4d3e776de8bb';
    const address = '0xb59f67a8bff5d8cd03f6ac17265c550ed8f33907';
    let logs = await alchemy.core.getLogs({
      blockHash,
      address
    });
    expect(logs.length).toEqual(1);
    expect(logs[0].blockHash).toEqual(blockHash);
    expect(address).toEqual(logs[0].address.toLowerCase());

    logs = await alchemy.core.getLogs({
      blockHash
    });
    expect(logs.length).toEqual(88);
  });

  it('getTokensForOwner()', async () => {
    // Works with page key
    const res = await alchemy.core.getTokensForOwner('vitalik.eth');
    expect(res.pageKey).not.toBeUndefined();
    const res2 = await alchemy.core.getTokensForOwner('vitalik.eth', {
      pageKey: res.pageKey
    });
    expect(res.tokens[0]).not.toEqual(res2.tokens[0]);

    // Works with DEFAULT_TOKENS
    const res3 = await alchemy.core.getTokensForOwner('vitalik.eth', {
      contractAddresses: TokenBalanceType.DEFAULT_TOKENS
    });
    expect(res3.tokens.length).toEqual(100);

    // Works with custom contract addresses
    const USDC_ADDRESS = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48';
    const USDT_ADDRESS = '0xdac17f958d2ee523a2206206994597c13d831ec7';
    const res4 = await alchemy.core.getTokensForOwner('vitalik.eth', {
      contractAddresses: [USDC_ADDRESS, USDT_ADDRESS]
    });
    expect(res4.tokens.length).toEqual(2);
    expect(res4.tokens[0].contractAddress).toEqual(USDC_ADDRESS);
    expect(res4.tokens[1].contractAddress).toEqual(USDT_ADDRESS);
  });
});


================================================================================
File: test\integration\debug.test.ts
Size: 3.45 kB
================================================================================

import { Alchemy, CommitmentLevel, DebugTracerType } from '../../src';
import { Utils } from '../../src/index';
import { loadAlchemyEnv } from '../test-util';

describe('DebugNamespace', () => {
  let alchemy: Alchemy;
  const from = '0xe5cb067e90d5cd1f8052b83562ae670ba4a211a8';
  const to = '0xdc66567a990b7fa10730459537620857c9e03287';

  beforeAll(async () => {
    await loadAlchemyEnv();
    alchemy = await new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY
    });

    // Skip all timeouts for testing.
    jest.setTimeout(50000);
  });

  it('traceCall() with call tracer', async () => {
    const response = await alchemy.debug.traceCall(
      {
        from,
        to,
        data: '0xae169a50000000000000000000000000000000000000000000000000000000000000000e'
      },
      '0xF118CE',
      {
        type: DebugTracerType.CALL_TRACER,
        onlyTopCall: true
      }
    );
    expect(response.calls).toBeDefined();
    expect(response.from).toEqual(from);
    expect(response.to).toEqual(to);
  });

  it('traceCall() with prestate tracer', async () => {
    const response = await alchemy.debug.traceCall(
      {
        from,
        to,
        data: '0xae169a50000000000000000000000000000000000000000000000000000000000000000e'
      },
      '0xF118CE',
      {
        type: DebugTracerType.PRESTATE_TRACER,
        onlyTopCall: false
      }
    );
    const addresses = Object.keys(response);
    expect(addresses.length).toBeGreaterThan(1);
    console.log(response[addresses[0]]);
    expect(response[addresses[0]].balance).toBeDefined();
    expect(response[addresses[0]].nonce).toBeDefined();
    expect(response[addresses[0]].code).toBeDefined();
  });

  it('traceTransaction() with call tracer', async () => {
    const response = await alchemy.debug.traceTransaction(
      '0x8fc90a6c3ee3001cdcbbb685b4fbe67b1fa2bec575b15b0395fea5540d0901ae',
      { type: DebugTracerType.CALL_TRACER }
    );
    expect(response.calls).toBeDefined();
    expect(response.from).toBeDefined();
    expect(response.to).toBeDefined();
  });

  it('traceTransaction() with prestate tracer', async () => {
    const response = await alchemy.debug.traceTransaction(
      '0x8fc90a6c3ee3001cdcbbb685b4fbe67b1fa2bec575b15b0395fea5540d0901ae',
      { type: DebugTracerType.PRESTATE_TRACER },
      '4s300ns'
    );
    const addresses = Object.keys(response);
    expect(addresses.length).toBeGreaterThan(1);
    expect(response[addresses[0]].balance).toBeDefined();
    expect(response[addresses[0]].nonce).toBeDefined();
    expect(response[addresses[0]].code).toBeDefined();
  });

  it('traceBlock()', async () => {
    const finalizedBlock = await alchemy.core.getBlock(
      CommitmentLevel.FINALIZED
    );
    const response = await alchemy.debug.traceBlock(finalizedBlock.number, {
      type: DebugTracerType.CALL_TRACER,
      onlyTopCall: true
    });
    const response2 = await alchemy.debug.traceBlock(
      Utils.hexStripZeros(Utils.hexValue(finalizedBlock.number)),
      {
        type: DebugTracerType.CALL_TRACER,
        onlyTopCall: true
      }
    );

    expect(response).toEqual(response2);

    // Check that we can call trace with commitment levels.
    await alchemy.debug.traceBlock(CommitmentLevel.FINALIZED, {
      type: DebugTracerType.CALL_TRACER,
      onlyTopCall: true
    });
  });
});


================================================================================
File: test\integration\nft.test.ts
Size: 25.77 kB
================================================================================

import {
  Alchemy,
  GetNftSalesResponse,
  GetTransfersForOwnerTransferType,
  NftCollection,
  NftContract,
  NftFilters,
  NftOrdering,
  NftSaleMarketplace,
  NftTokenType,
  OpenSeaSafelistRequestStatus,
  SortingOrder,
  fromHex
} from '../../src';
import { loadAlchemyEnv } from '../test-util';

jest.setTimeout(50000);

// These integration tests check for valid response types and protect against
// regressions in the backend.
// TODO(V3): now that types match, add automated tests to check every single field
// to make sure the schema matches
describe('E2E integration tests', () => {
  let alchemy: Alchemy;
  const ownerEns = 'vitalik.eth';
  const ownerAddress = '0x65d25E3F2696B73b850daA07Dd1E267dCfa67F2D';
  const contractAddress = '0x01234567bac6ff94d7e4f0ee23119cf848f93245';
  const collectionSlug = 'boredapeyachtclub';

  beforeAll(async () => {
    await loadAlchemyEnv();
    alchemy = await new Alchemy({
      apiKey: process.env.ALCHEMY_API_KEY
    });

    // Skip all timeouts for testing.
    jest.setTimeout(50000);
  });

  function verifyNftContractMetadata(metadata: NftContract): void {
    expect(typeof metadata.totalSupply).toEqual('string');
    expect(typeof metadata.symbol).toEqual('string');
    expect(metadata.tokenType).toEqual(NftTokenType.ERC721);
    expect(typeof metadata.name).toEqual('string');
    expect(metadata.openSeaMetadata).toBeDefined();
    expect(metadata.openSeaMetadata!.safelistRequestStatus).toBeDefined();
    expect(
      Object.values(OpenSeaSafelistRequestStatus).includes(
        metadata.openSeaMetadata?.safelistRequestStatus!
      )
    ).toEqual(true);
    expect(typeof metadata.contractDeployer).toEqual('string');
    expect(typeof metadata.deployedBlockNumber).toEqual('number');
  }

  function verifyNftCollectionMetadata(metadata: NftCollection): void {
    expect(typeof metadata.name).toEqual('string');
    expect(typeof metadata.slug).toEqual('string');
    expect(metadata.floorPrice).toBeDefined();
    expect(typeof metadata.description).toEqual('string');
    expect(typeof metadata.externalUrl).toEqual('string');
    expect(typeof metadata.twitterUsername).toEqual('string');
    expect(typeof metadata.discordUrl).toEqual('string');
  }

  function verifyNftSalesData(response: GetNftSalesResponse): void {
    expect(response.nftSales.length).toBeGreaterThan(0);
    expect(response.nftSales[0].bundleIndex).toBeDefined();
    expect(typeof response.nftSales[0].bundleIndex).toEqual('number');
    expect(response.nftSales[0].buyerAddress).toBeDefined();
    expect(typeof response.nftSales[0].buyerAddress).toEqual('string');
    expect(response.nftSales[0].contractAddress).toBeDefined();
    expect(typeof response.nftSales[0].contractAddress).toEqual('string');
    expect(response.nftSales[0].logIndex).toBeDefined();
    expect(typeof response.nftSales[0].logIndex).toEqual('number');
    expect(response.nftSales[0].marketplace).toBeDefined();
    expect(typeof response.nftSales[0].logIndex).toEqual('number');
    expect(response.nftSales[0].quantity).toBeDefined();
    expect(typeof response.nftSales[0].quantity).toEqual('string');
    expect(response.nftSales[0].sellerAddress).toBeDefined();
    expect(typeof response.nftSales[0].sellerAddress).toEqual('string');
    expect(response.nftSales[0].taker).toBeDefined();
    expect(typeof response.nftSales[0].taker).toEqual('string');
    expect(response.nftSales[0].tokenId).toBeDefined();
    expect(typeof response.nftSales[0].tokenId).toEqual('string');
    expect(response.nftSales[0].transactionHash).toBeDefined();
    expect(typeof response.nftSales[0].transactionHash).toEqual('string');
  }

  it('getNftMetadata()', async () => {
    const contractAddress = '0x0510745d2ca36729bed35c818527c4485912d99e';
    const tokenId = 403;
    const response = await alchemy.nft.getNftMetadata(
      contractAddress,
      tokenId,
      {
        tokenType: NftTokenType.UNKNOWN
      }
    );
    expect(response.image).toBeDefined();
    verifyNftContractMetadata(response.contract);
  });

  it('getNftMetadataBatch()', async () => {
    const response = await alchemy.nft.getNftMetadataBatch([
      {
        contractAddress,
        tokenId: '0x8b57f0',
        tokenType: NftTokenType.ERC721
      },
      { contractAddress, tokenId: 13596716 }
    ]);
    expect(response.nfts.length).toEqual(2);
    expect(response.nfts[0].tokenId).toEqual(fromHex('0x8b57f0').toString());
    expect(response.nfts[1].tokenId).toEqual('13596716');
  });

  it('getContractMetadata()', async () => {
    const response = await alchemy.nft.getContractMetadata(contractAddress);
    verifyNftContractMetadata(response);
  });

  it('getCollectionMetadata()', async () => {
    const response = await alchemy.nft.getCollectionMetadata(collectionSlug);
    verifyNftCollectionMetadata(response);
  });

  it('getOwnersForNft()', async () => {
    const tokenId =
      '0x00000000000000000000000000000000000000000000000000000000008b57f0';
    const response = await alchemy.nft.getOwnersForNft(
      contractAddress,
      tokenId
    );
    expect(response.owners.length).toBeGreaterThan(0);
  });

  it('getOwnersForNft() with pageSize on erc1155 contract 0x84162fE2E695Fedbf4D3bcA1c3458FB616E44735', async () => {
    const tokenId = '0';
    const response = await alchemy.nft.getOwnersForNft(
      '0x84162fE2E695Fedbf4D3bcA1c3458FB616E44735',
      tokenId,
      { pageSize: 51 }
    );
    expect(response.owners.length).toEqual(51);
  });

  it('getOwnersForNft() with pageKey on erc1155 contract 0x84162fE2E695Fedbf4D3bcA1c3458FB616E44735', async () => {
    const tokenId = '0';
    const firstPageResponse = await alchemy.nft.getOwnersForNft(
      '0x84162fE2E695Fedbf4D3bcA1c3458FB616E44735',
      tokenId,
      { pageSize: 1 }
    );
    const pageKey = firstPageResponse.pageKey;
    expect(pageKey).toBeDefined();

    const nextPageResponse = await alchemy.nft.getOwnersForNft(
      contractAddress,
      tokenId,
      { pageSize: 1, pageKey }
    );
    expect(nextPageResponse.owners.length).toEqual(1);
    // cursory check that the pages contain different data
    expect(
      firstPageResponse.owners[0] === nextPageResponse.owners[0]
    ).toBeFalsy();
  });

  it('getNftsForOwner() with pageSize', async () => {
    const response = await alchemy.nft.getNftsForOwner('vitalik.eth', {
      pageSize: 51
    });
    expect(
      response.ownedNfts.filter(
        nft => nft.contract.openSeaMetadata !== undefined
      ).length
    ).toBeGreaterThan(0);
    expect(response.ownedNfts.length).toEqual(51);
    expect(response.validAt).toBeDefined();
  });

  it('getOwnersForNft() from NFT', async () => {
    const nfts = await alchemy.nft.getNftsForOwner(ownerAddress, {
      excludeFilters: [NftFilters.SPAM],
      omitMetadata: true
    });
    expect(nfts.ownedNfts.length).toBeGreaterThan(0);

    const nfts2 = await alchemy.nft.getNftsForOwner(ownerAddress, {
      excludeFilters: [NftFilters.AIRDROPS],
      omitMetadata: true
    });

    expect(nfts.ownedNfts.length).not.toEqual(nfts2.totalCount);
    const response = await alchemy.nft.getOwnersForNft(
      nfts.ownedNfts[0].contractAddress,
      nfts.ownedNfts[0].tokenId
    );
    expect(response.owners.length).toBeGreaterThan(0);
  });

  it('getNftsForOwner() spam check', async () => {
    const withSpam = await alchemy.nft.getNftsForOwner('vitalik.eth');
    const noSpam = await alchemy.nft.getNftsForOwner('vitalik.eth', {
      excludeFilters: [NftFilters.SPAM]
    });
    expect(withSpam.totalCount).not.toEqual(noSpam.totalCount);
  });

  it('getNftsForOwner() spam info check', async () => {
    const response = await alchemy.nft.getNftsForOwner('vitalik.eth');
    const spamNfts = response.ownedNfts.filter(
      nft => nft.contract.isSpam !== undefined
    );
    expect(spamNfts[0].contract.isSpam).toEqual(true);
    expect(spamNfts[0].contract.spamClassifications.length).toBeGreaterThan(0);
  });

  it('getNftsForOwner() contract metadata check', async () => {
    const nfts = await alchemy.nft.getNftsForOwner('vitalik.eth');
    expect(
      nfts.ownedNfts.filter(
        nft =>
          nft.contract.symbol !== undefined &&
          nft.contract.totalSupply !== undefined
      ).length
    ).toBeGreaterThan(0);
  });

  it('getNftsForOwner() mint metadata check', async () => {
    const nfts = await alchemy.nft.getNftsForOwner('vitalik.eth', {
      excludeFilters: [NftFilters.SPAM]
    });
    expect(
      nfts.ownedNfts.filter(
        nft =>
          nft.mint?.mintAddress !== undefined &&
          nft.mint.timestamp !== undefined
      ).length
    ).toBeGreaterThan(0);
  });

  it('getNftForOwners() ordered', async () => {
    const response = await alchemy.nft.getNftsForOwner(
      '0x994b342dd87fc825f66e51ffa3ef71ad818b6893',
      {
        orderBy: NftOrdering.TRANSFERTIME
      }
    );
    expect(response.ownedNfts.at(0)?.acquiredAt).toBeDefined();
    expect(response.ownedNfts.at(0)?.acquiredAt?.blockNumber).toBeGreaterThan(
      0
    );
    expect(response.ownedNfts.at(0)?.acquiredAt?.blockTimestamp).toBeTruthy();
    expect(response.validAt).toBeDefined();
  });

  it('getOwnersForContract()', async () => {
    const response = await alchemy.nft.getOwnersForContract(contractAddress);
    expect(response.owners.length).toBeGreaterThan(0);
  });

  it('getOwnersForContract() with includeCount', async () => {
    const response = await alchemy.nft.getOwnersForContract(contractAddress, {
      includeCount: true
    });
    expect(response.totalCount).not.toBeUndefined();
  });

  it('getOwnersForContract()', async () => {
    const address = '0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85';
    const response = await alchemy.nft.getOwnersForContract(address, {
      withTokenBalances: true
    });

    expect(response.owners.length).toBeGreaterThan(0);
    expect(response.owners[0].tokenBalances.length).toBeGreaterThan(0);
    expect(typeof response.owners[0].tokenBalances[0].balance).toEqual(
      'string'
    );
  });

  it('getContractsForOwner()', async () => {
    const response = await alchemy.nft.getContractsForOwner(ownerAddress);

    expect(response.contracts.length).toBeGreaterThan(0);
    verifyNftContractMetadata(response.contracts[0]);
  });

  it('getContractsForOwner() with pageKey and pageSize', async () => {
    const firstPage = await alchemy.nft.getContractsForOwner(ownerEns, {
      pageSize: 4
    });

    expect(firstPage.pageKey).toBeDefined();
    expect(typeof firstPage.pageKey).toEqual('string');
    expect(firstPage.contracts.length).toEqual(4);

    const response = await alchemy.nft.getContractsForOwner(ownerEns, {
      pageKey: firstPage?.pageKey
    });