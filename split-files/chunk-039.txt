
  console.log(nfts.totalCount);
});

// Get all the image urls for all the NFTs an address owns.
async function main() {
  for await (const nft of alchemy.nft.getNftsForOwnerIterator('vitalik.eth')) {
    console.log(nft.media);
  }
}

main();

// Filter out spam NFTs.
alchemy.nft
  .getNftsForOwner('vitalik.eth', {
    excludeFilters: [NftExcludeFilters.SPAM]
  })
  .then(console.log);
```

### Getting all the owners of the BAYC NFT

```ts
import { Alchemy } from 'alchemy-sdk';

const alchemy = new Alchemy();

// Bored Ape Yacht Club contract address.
const baycAddress = '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D';

async function main() {
  for await (const nft of alchemy.nft.getNftsForContractIterator(baycAddress, {
    // Omit the NFT metadata for smaller payloads.
    omitMetadata: true
  })) {
    await alchemy.nft
      .getOwnersForNft(nft.contract.address, nft.tokenId)
      .then(response =>
        console.log('owners:', response.owners, 'tokenId:', nft.tokenId)
      );
  }
}

main();
```

### Get all outbound transfers for a provided address

```ts
import { Alchemy } from 'alchemy-sdk';

const alchemy = new Alchemy();

alchemy.core.getTokenBalances('vitalik.eth').then(console.log);
```

## Questions and Feedback

If you have any questions, issues, or feedback, please file an issue
on [GitHub](https://github.com/alchemyplatform/alchemy-sdk-js/issues), or drop us a message on
our [Discord](https://discord.com/invite/alchemyplatform) channel for the SDK.


================================================================================
File: rollup.config.js
Size: 1.49 kB
================================================================================

import commonjs from '@rollup/plugin-commonjs';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import typescriptPlugin from 'rollup-plugin-typescript2';

import pkg from './package.json';

const TRUE_ROOT = 'index';
const roots = [TRUE_ROOT, 'api/utils'];
const formats = ['cjs', 'esm', 'es'];
const plugins = [typescriptPlugin(), nodeResolve(), commonjs()];

// e.g. dirFromPath("foo/bar/baz") -> "foo/bar"
function dirFromPath(path) {
  const index = path.lastIndexOf('/');
  return index === -1 ? '' : path.slice(0, index);
}

// e.g. lastPartOfPath("foo/bar/baz") -> "baz"
function lastPartOfPath(path) {
  const index = path.lastIndexOf('/');
  return path.slice(index + 1);
}

// Returns true for any dependency listed in package.json and for any member of
// roots other than index.js, where roots is the array defined above.
const isExternalModule = (() => {
  const deps = new Set(Object.keys(pkg.dependencies ?? {}));
  const subrootEndings = new Set(
    roots.filter(root => root !== TRUE_ROOT).map(lastPartOfPath)
  );
  return id =>
    deps.has(id) ||
    (id.startsWith('.') && subrootEndings.has(lastPartOfPath(id)));
})();

function makeConfig(root) {
  return {
    input: `src/${root}.ts`,
    output: formats.map(format => ({
      dir: `dist/${format}/${dirFromPath(root)}`,
      format,
      sourcemap: true
    })),
    external: isExternalModule,
    plugins
  };
}

export default roots.map(makeConfig);


================================================================================
File: sample-alchemy.env
Size: 292 B
================================================================================

# This file is a sample config file for running integration tests. To run the
# tests yourself, rename this file to `alchemy.env` and fill in the values.
ALCHEMY_API_KEY="demo"

# Used only for Notify integration tests
ALCHEMY_AUTH_TOKEN="auth-token-here"
ALCHEMY_APP_ID="app-id-here"


================================================================================
File: src\api\alchemy-config.ts
Size: 4.93 kB
================================================================================

import { ConnectionInfo } from '@ethersproject/web';

import { AlchemySettings, Network } from '../types/types';
import {
  AlchemyApiType,
  DEFAULT_ALCHEMY_API_KEY,
  DEFAULT_MAX_RETRIES,
  DEFAULT_NETWORK,
  DEFAULT_REQUEST_TIMEOUT,
  getAlchemyHttpUrl,
  getAlchemyNftHttpUrl,
  getAlchemyWebhookHttpUrl,
  getPricesBaseUrl
} from '../util/const';
import type { AlchemyProvider } from './alchemy-provider';
import type { AlchemyWebSocketProvider } from './alchemy-websocket-provider';

/**
 * This class holds the config information for the SDK client instance and
 * exposes the underlying providers for more advanced use cases.
 *
 * @public
 */
export class AlchemyConfig {
  /** The Alchemy API key. */
  readonly apiKey: string;

  /** The Network that this SDK is associated with. */
  readonly network: Network;

  /** The maximum number of retries to perform. */
  readonly maxRetries: number;

  /** Setting to enable automatic batching on json-rpc requests. Defaults to false.*/
  readonly batchRequests: boolean;

  readonly connectionInfoOverrides?: Partial<ConnectionInfo>;

  /**
   * The optional hardcoded URL to send requests to instead of using the network
   * and apiKey.
   */
  readonly url?: string;

  /** The optional Alchemy auth token to use when sending requests with the Notify API. */
  readonly authToken?: string;

  /**
   * The optional Request timeout provided in `ms` for NFT and NOTIFY API. Defaults to 0.
   */
  readonly requestTimeout?: number;

  /**
   * Dynamically imported provider instance.
   *
   * @internal
   */
  private _baseAlchemyProvider: Promise<AlchemyProvider> | undefined;

  /**
   * Dynamically imported provider instance.
   *
   * @internal
   */
  private _baseAlchemyWssProvider:
    | Promise<AlchemyWebSocketProvider>
    | undefined;

  constructor(config?: AlchemySettings) {
    this.apiKey = config?.apiKey || DEFAULT_ALCHEMY_API_KEY;
    this.network = config?.network || DEFAULT_NETWORK;
    this.maxRetries = config?.maxRetries || DEFAULT_MAX_RETRIES;
    this.url = config?.url;
    this.authToken = config?.authToken;
    this.batchRequests = config?.batchRequests || false;
    this.requestTimeout = config?.requestTimeout || DEFAULT_REQUEST_TIMEOUT;
    this.connectionInfoOverrides = config?.connectionInfoOverrides;
  }

  /**
   * Returns the URL endpoint to send the HTTP request to. If a custom URL was
   * provided in the config, that URL is returned. Otherwise, the default URL is
   * from the network and API key.
   *
   * @param apiType - The type of API to get the URL for.
   * @internal
   */
  _getRequestUrl(apiType: AlchemyApiType): string {
    if (this.url !== undefined) {
      return this.url;
    } else if (apiType === AlchemyApiType.NFT) {
      return getAlchemyNftHttpUrl(this.network, this.apiKey);
    } else if (apiType === AlchemyApiType.WEBHOOK) {
      return getAlchemyWebhookHttpUrl();
    } else if (apiType === AlchemyApiType.PRICES) {
      return getPricesBaseUrl(this.apiKey);
    } else {
      return getAlchemyHttpUrl(this.network, this.apiKey);
    }
  }

  /**
   * Returns an AlchemyProvider instance. Only one provider is created per
   * Alchemy instance.
   *
   * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and
   * has been expanded to support Alchemy's Enhanced APIs.
   *
   * Most common methods on the provider are available as top-level methods on
   * the {@link Alchemy} instance, but the provider is exposed here to access
   * other less-common methods.
   *
   * @public
   */
  getProvider(): Promise<AlchemyProvider> {
    if (!this._baseAlchemyProvider) {
      this._baseAlchemyProvider = (async () => {
        const { AlchemyProvider } = await import('./alchemy-provider');
        return new AlchemyProvider(this);
      })();
    }
    return this._baseAlchemyProvider;
  }

  /**
   * Returns an AlchemyWebsocketProvider instance. Only one provider is created
   * per Alchemy instance.
   *
   * The AlchemyWebSocketProvider is a wrapper around ether's
   * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's
   * Subscription APIs, automatic backfilling, and other performance improvements.
   *
   * Most common methods on the provider are available as top-level methods on
   * the {@link Alchemy} instance, but the provider is exposed here to access
   * other less-common methods.
   */
  getWebSocketProvider(): Promise<AlchemyWebSocketProvider> {
    if (!this._baseAlchemyWssProvider) {
      this._baseAlchemyWssProvider = (async () => {
        const { AlchemyWebSocketProvider } = await import(
          './alchemy-websocket-provider'
        );
        return new AlchemyWebSocketProvider(this);
      })();
    }
    return this._baseAlchemyWssProvider;
  }
}


================================================================================
File: src\api\alchemy-contract.ts
Size: 606 B
================================================================================

import {
  Contract as EthersContract,
  ContractFactory as EthersContractFactory
} from '@ethersproject/contracts';

/**
 * The Contract class is a wrapper around the Contract class from ethers.js and
 * is exported here for convenience.
 *
 * @public
 */
// TODO: support passing in Alchemy instance into the contract.
export class Contract extends EthersContract {}

/**
 * The ContractFactory class is a wrapper around the ContractFactory class from
 * ethers.js and is exported here for convenience.
 *
 * @public
 */
export class ContractFactory extends EthersContractFactory {}


================================================================================
File: src\api\alchemy-provider.ts
Size: 10.28 kB
================================================================================

import {
  Network as NetworkFromEthers,
  Networkish,
  getNetwork as getNetworkFromEthers
} from '@ethersproject/networks';
import { deepCopy } from '@ethersproject/properties';
import {
  CommunityResourcable,
  JsonRpcProvider
} from '@ethersproject/providers';
import { ConnectionInfo, fetchJson } from '@ethersproject/web';

import { JsonRpcRequest, JsonRpcResponse } from '../internal/internal-types';
import { RequestBatcher } from '../internal/request-batcher';
import { Network } from '../types/types';
import {
  CustomNetworks,
  DEFAULT_ALCHEMY_API_KEY,
  DEFAULT_NETWORK,
  EthersNetwork,
  getAlchemyHttpUrl,
  getAlchemyWsUrl
} from '../util/const';
import { logWarn } from '../util/logger';
import { IS_BROWSER } from '../util/util';
import { VERSION } from '../version';
import { AlchemyConfig } from './alchemy-config';

/**
 * SDK's custom implementation of ethers.js's 'AlchemyProvider'.
 *
 * Do not call this constructor directly. Instead, instantiate an instance of
 * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.
 *
 * @public
 */
export class AlchemyProvider
  extends JsonRpcProvider
  implements CommunityResourcable
{
  readonly apiKey: string;
  readonly maxRetries: number;
  readonly batchRequests: boolean;

  /**
   * VISIBLE ONLY FOR TESTING
   *@internal
   */
  readonly batcher: RequestBatcher;

  /** @internal */
  constructor(config: AlchemyConfig) {
    // Normalize the API Key to a string.
    const apiKey = AlchemyProvider.getApiKey(config.apiKey);

    // Generate our own connection info with the correct endpoint URLs.
    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);
    let connection = AlchemyProvider.getAlchemyConnectionInfo(
      alchemyNetwork,
      apiKey,
      'http'
    );

    // If a hardcoded url was specified in the config, use that instead of the
    // provided apiKey or network.
    if (config.url !== undefined) {
      connection.url = config.url;
    }

    connection.throttleLimit = config.maxRetries;

    // Add user provided overrides if they exist.
    if (config.connectionInfoOverrides) {
      connection = {
        ...connection,
        ...config.connectionInfoOverrides
      };
    }

    // Normalize the Alchemy named network input to the network names used by
    // ethers. This allows the parent super constructor in JsonRpcProvider to
    // correctly set the network.
    const ethersNetwork = EthersNetwork[alchemyNetwork];
    super(connection, ethersNetwork);

    this.apiKey = config.apiKey;
    this.maxRetries = config.maxRetries;
    this.batchRequests = config.batchRequests;

    // TODO: support individual headers when calling batch
    const batcherConnection = {
      ...this.connection,
      headers: {
        ...this.connection.headers,
        'Alchemy-Ethers-Sdk-Method': 'batchSend'
      }
    };
    const sendBatchFn = (
      requests: JsonRpcRequest[]
    ): Promise<JsonRpcResponse[]> => {
      return fetchJson(batcherConnection, JSON.stringify(requests));
    };
    this.batcher = new RequestBatcher(sendBatchFn);

    this.modifyFormatter();
  }

  /**
   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by
   * ethers.js. Returns the API key for an Alchemy provider.
   *
   * @internal
   * @override
   */
  static getApiKey(apiKey: any): string {
    if (apiKey == null) {
      return DEFAULT_ALCHEMY_API_KEY;
    }
    if (apiKey && typeof apiKey !== 'string') {
      throw new Error(
        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`
      );
    }
    return apiKey;
  }

  /**
   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.
   *
   * This override allows the SDK to set the provider's network to values not
   * yet supported by ethers.js.
   *
   * @internal
   * @override
   */
  static getNetwork(network: Networkish): NetworkFromEthers {
    if (typeof network === 'string' && network in CustomNetworks) {
      return CustomNetworks[network];
    }

    // Call the standard ethers.js getNetwork method for other networks.
    return getNetworkFromEthers(network);
  }

  /**
   * Converts the `Networkish` input to the network enum used by Alchemy.
   *
   * @internal
   */
  static getAlchemyNetwork(network?: Networkish): Network {
    if (network === undefined) {
      return DEFAULT_NETWORK;
    }

    if (typeof network === 'number') {
      throw new Error(
        `Invalid network '${network}' provided. Network must be a string.`
      );
    }

    // Guaranteed that `typeof network === 'string`.
    const isValidNetwork = Object.values(Network).includes(network as Network);
    if (!isValidNetwork) {
      throw new Error(
        `Invalid network '${network}' provided. Network must be one of: ` +
          `${Object.values(Network).join(', ')}.`
      );
    }
    return network as Network;
  }

  /**
   * Returns a {@link ConnectionInfo} object compatible with ethers that contains
   * the correct URLs for Alchemy.
   *
   * @internal
   */
  static getAlchemyConnectionInfo(
    network: Network,
    apiKey: string,
    type: 'wss' | 'http'
  ): ConnectionInfo {
    const url =
      type === 'http'
        ? getAlchemyHttpUrl(network, apiKey)
        : getAlchemyWsUrl(network, apiKey);
    return {
      headers: IS_BROWSER
        ? {
            'Alchemy-Ethers-Sdk-Version': VERSION
          }
        : {
            'Alchemy-Ethers-Sdk-Version': VERSION,
            'Accept-Encoding': 'gzip'
          },
      allowGzip: true,
      url
    };
  }

  /**
   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This
   * method is called when calling methods on the parent class `BaseProvider`.
   *
   * @override
   */
  async detectNetwork(): Promise<NetworkFromEthers> {
    let network = this.network;
    if (network == null) {
      network = await super.detectNetwork();

      if (!network) {
        throw new Error('No network detected');
      }
    }
    return network;
  }

  _startPending(): void {
    logWarn('WARNING: Alchemy Provider does not support pending filters');
  }

  /**
   * Overrides the ether's `isCommunityResource()` method. Returns true if the
   * current api key is the default key.
   *
   * @override
   */
  isCommunityResource(): boolean {
    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;
  }

  /**
   * Overrides the base {@link JsonRpcProvider.send} method to implement custom
   * logic for sending requests to Alchemy.
   *
   * @param method The method name to use for the request.
   * @param params The parameters to use for the request.
   * @override
   * @public
   */
  // TODO: Add headers for `perform()` override.
  send(method: string, params: Array<any>): Promise<any> {
    return this._send(method, params, 'send');
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `JsonRpcProvider.send()`.
   *
   * This method is copied over directly in order to implement custom headers
   *
   * @internal
   */
  _send(
    method: string,
    params: Array<any>,
    methodName: string,
    forceBatch = false
  ): Promise<any> {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: '2.0'
    };

    // START MODIFIED CODE
    const connection = { ...this.connection };
    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;

    if (this.batchRequests || forceBatch) {
      return this.batcher.enqueueRequest(request as JsonRpcRequest);
    }
    // END MODIFIED CODE

    this.emit('debug', {
      action: 'request',
      request: deepCopy(request),
      provider: this
    });

    // We can expand this in the future to any call, but for now these
    // are the biggest wins and do not require any serializing parameters.
    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }

    const result = fetchJson(
      this.connection,
      JSON.stringify(request),
      getResult
    ).then(
      result => {
        this.emit('debug', {
          action: 'response',
          request,
          response: result,
          provider: this
        });

        return result;
      },
      error => {
        this.emit('debug', {
          action: 'response',
          error,
          request,
          provider: this
        });

        throw error;
      }
    );

    // Cache the fetch, but clear it on the next event loop
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        // @ts-ignore - This is done by ethers.
        this._cache[method] = null;
      }, 0);
    }

    return result;
  }

  /**
   * Overrides the base `Formatter` class inherited from ethers to support
   * returning custom fields in Ethers response types.
   *
   * For context, ethers has a `Formatter` class that is used to format the
   * response from a JSON-RPC request. Any fields that are not defined in the
   * `Formatter` class are removed from the returned response. By modifying the
   * `Formatter` class in this method, we can add support for fields that are
   * not defined in ethers.
   */
  private modifyFormatter(): void {
    this.formatter.formats['receiptLog']['removed'] = val => {
      if (typeof val === 'boolean') {
        return val;
      }
      return undefined;
    };
  }
}

/**
 * DO NOT MODIFY.
 *
 * Original code copied over from ether.js's
 * `@ethersproject/web/src.ts/index.ts`. Used to support
 * {@link AlchemyProvider._send}, which is also copied over.
 */
function getResult(payload: {
  error?: { code?: number; data?: any; message?: string };
  result?: any;
}): any {
  if (payload.error) {
    const error: any = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }

  return payload.result;
}


================================================================================
File: src\api\alchemy-wallet.ts
Size: 5.99 kB
================================================================================

import {
  BlockTag,
  FeeData,
  Provider,
  TransactionRequest,
  TransactionResponse
} from '@ethersproject/abstract-provider';
import { ExternallyOwnedAccount } from '@ethersproject/abstract-signer';
import { BigNumber } from '@ethersproject/bignumber';
import { BytesLike } from '@ethersproject/bytes';
import { Deferrable } from '@ethersproject/properties';
import { SigningKey } from '@ethersproject/signing-key';
import { Wallet as EthersWallet } from '@ethersproject/wallet';

import { Alchemy } from './alchemy';

/**
 * The Wallet class inherits Signer and can sign transactions and messages using
 * a private key as a standard Externally Owned Account (EOA).
 *
 * SDK's custom implementation of Ethers.js's 'Wallet'.
 *
 * Primary difference from Ethers.js 'Wallet' is that you can pass in either a
 * Provider or an Alchemy object. This implementation will intelligently detect
 * the format and set the provider accordingly.
 *
 * @public
 * @override
 */
export class Wallet extends EthersWallet {
  private alchemyProviderPromise?: Promise<Provider>;

  /**
   * Overload permits users to pass in either a standard Provider or an Alchemy
   * object. The constructor will detect the object type and handle appropriately.
   *
   * @override
   */
  constructor(
    privateKey: BytesLike | ExternallyOwnedAccount | SigningKey,
    alchemyOrProvider?: Alchemy | Provider
  ) {
    // If object passed in is a provider, send to super
    let superProvider: Provider | undefined;
    if (alchemyOrProvider && Provider.isProvider(alchemyOrProvider)) {
      superProvider = alchemyOrProvider;
    }
    super(privateKey, superProvider);

    // If object passed in is an Alchemy object, just set Alchemy
    if (alchemyOrProvider && !Provider.isProvider(alchemyOrProvider)) {
      this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();
    }
  }

  //////////////////////////////////////////////////////////////////
  // Set of overrides from Signer to handle async provider retrieval.
  //////////////////////////////////////////////////////////////////

  /**
   * Returns the balance of this wallet at blockTag.
   *
   * @param blockTag The block to check the balance of
   * @override
   */
  getBalance(blockTag?: BlockTag): Promise<BigNumber> {
    return this.getWallet().then(wallet => wallet.getBalance(blockTag));
  }

  /**
   * Returns the number of transactions this account has ever sent. This is the
   * value required to be included in transactions as the nonce.
   *
   * @param blockTag The block to check the transaction count on
   * @override
   */
  getTransactionCount(blockTag?: BlockTag): Promise<number> {
    return this.getWallet().then(wallet =>
      wallet.getTransactionCount(blockTag)
    );
  }

  /**
   * Returns the result of estimating the cost to send the transactionRequest,
   * with this account address being used as the from field.
   *
   * @param transaction Transaction to estimate the gas on
   * @override
   */
  estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {
    return this.getWallet().then(wallet => wallet.estimateGas(transaction));
  }

  /**
   * Returns the result of calling using the transactionRequest, with this
   * account address being used as the from field.
   *
   * @param transaction To make a call on
   * @param blockTag The block to make the call on
   * @override
   */
  call(
    transaction: Deferrable<TransactionRequest>,
    blockTag?: BlockTag
  ): Promise<string> {
    return this.getWallet().then(wallet => wallet.call(transaction, blockTag));
  }

  /**
   * Populates ALL keys for a transaction and checks that `from` matches this
   * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,
   * `nonce`, and `chainId` if they are not provided.
   *
   * @param transaction The transaction to populate.
   * @override
   */
  populateTransaction(
    transaction: Deferrable<TransactionRequest>
  ): Promise<TransactionRequest> {
    return this.getWallet().then(wallet =>
      wallet.populateTransaction(transaction)
    );
  }

  /**
   * Populates all fields in a transaction, signs it and sends it to the network
   *
   * @param transaction The transaction to send.
   * @override
   */
  sendTransaction(
    transaction: Deferrable<TransactionRequest>
  ): Promise<TransactionResponse> {
    return this.getWallet().then(wallet => wallet.sendTransaction(transaction));
  }

  /**
   * Returns the chain ID this wallet is connected to.
   *
   * @override
   */
  getChainId(): Promise<number> {
    return this.getWallet().then(wallet => wallet.getChainId());
  }

  /**
   * Returns the current gas price.
   *
   * @override
   */
  getGasPrice(): Promise<BigNumber> {
    return this.getWallet().then(wallet => wallet.getGasPrice());
  }

  /**
   * Returns the current recommended FeeData to use in a transaction.
   *
   * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas
   * should be used.
   *
   * For legacy transactions and networks which do not support EIP-1559, the
   * gasPrice should be used.
   *
   * @override
   */
  getFeeData(): Promise<FeeData> {
    return this.getWallet().then(wallet => wallet.getFeeData());
  }

  /**
   * Looks up the address of name. If the name is not owned, or does not have a
   * Resolver configured, or the Resolver does not have an address configured,
   * null is returned.
   *
   * @param name Name of the ENS address
   * @override
   */
  resolveName(name: string): Promise<string> {
    return this.getWallet().then(wallet => wallet.resolveName(name));
  }

  private async getWallet() {
    if (!this.alchemyProviderPromise) {
      return this.connect(this.provider);
    }
    return this.connect(await this.alchemyProviderPromise);
  }
}


================================================================================
File: src\api\alchemy-websocket-provider.ts
Size: 34.52 kB
================================================================================

import SturdyWebSocket from 'sturdy-websocket';

import { Listener } from '@ethersproject/abstract-provider';
import { BigNumber } from '@ethersproject/bignumber';
import {
  Networkish,
  getNetwork as getNetworkFromEthers
} from '@ethersproject/networks';
import { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';
import {
  CommunityResourcable,
  WebSocketProvider
} from '@ethersproject/providers';

import {
  EthersEvent,
  getAlchemyEventTag,
  isAlchemyEvent,
  verifyAlchemyEventName
} from '../internal/ethers-event';
import {
  ALCHEMY_EVENT_TYPES,
  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,
  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,
  JsonRpcRequest,
  JsonRpcResponse,
  SingleOrBatchResponse,
  SubscriptionEvent,
  WebSocketMessage
} from '../internal/internal-types';
import {
  BatchPart,
  LogsEvent,
  LogsSubscriptionFilter,
  NewHeadsEvent,
  WebsocketBackfiller,
  dedupeLogs,
  dedupeNewHeads,
  throwIfCancelled
} from '../internal/websocket-backfiller';
import { AlchemyEventType, AlchemySubscription } from '../types/types';
import {
  CustomNetworks,
  DEFAULT_ALCHEMY_API_KEY,
  EthersNetwork,
  noop
} from '../util/const';
import { VERSION } from '../version';
import { AlchemyConfig } from './alchemy-config';
import { AlchemyProvider } from './alchemy-provider';
import { fromHex } from './util';

const HEARTBEAT_INTERVAL = 30000;
const HEARTBEAT_WAIT_TIME = 10000;
const BACKFILL_TIMEOUT = 60000;
const BACKFILL_RETRIES = 5;
/**
 * Subscriptions have a memory of recent events they have sent so that in the
 * event that they disconnect and need to backfill, they can detect re-orgs.
 * Keep a buffer that goes back at least these many blocks, the maximum amount
 * at which we might conceivably see a re-org.
 *
 * Note that while our buffer goes back this many blocks, it may contain more
 * than this many elements, since in the case of logs subscriptions more than
 * one event may be emitted for a block.
 */
const RETAINED_EVENT_BLOCK_COUNT = 10;

/**
 * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.
 *
 * Do not call this constructor directly. Instead, instantiate an instance of
 * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.
 *
 * @public
 */
export class AlchemyWebSocketProvider
  extends WebSocketProvider
  implements CommunityResourcable
{
  _events: Array<EthersEvent> = [];
  readonly apiKey: string;

  // In the case of a WebSocket reconnection, all subscriptions are lost and we
  // create new ones to replace them, but we want to create the illusion that
  // the original subscriptions persist. Thus, maintain a mapping from the
  // "virtual" subscription ids which are visible to the consumer to the
  // "physical" subscription ids of the actual connections. This terminology is
  // borrowed from virtual and physical memory, which has a similar mapping.
  /** @internal */
  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =
    new Map();
  /** @internal */
  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();
  /** @internal */
  private readonly backfiller: WebsocketBackfiller;
  /** @internal */
  private heartbeatIntervalId?: NodeJS.Timeout;
  /** @internal */
  private cancelBackfill: () => void;

  /** @internal */
  constructor(config: AlchemyConfig, wsConstructor?: any) {
    // Normalize the API Key to a string.
    const apiKey = AlchemyProvider.getApiKey(config.apiKey);

    // Generate our own connection info with the correct endpoint URLs.
    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);
    const connection = AlchemyProvider.getAlchemyConnectionInfo(
      alchemyNetwork,
      apiKey,
      'wss'
    );

    const protocol = `alchemy-sdk-${VERSION}`;

    // Use the provided config URL override if it exists, otherwise use the created one.
    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {
      wsConstructor: wsConstructor ?? getWebsocketConstructor()
    });

    // Normalize the Alchemy named network input to the network names used by
    // ethers. This allows the parent super constructor in JsonRpcProvider to
    // correctly set the network.
    const ethersNetwork = EthersNetwork[alchemyNetwork];
    super(ws as any, ethersNetwork);
    this.apiKey = apiKey;

    // Start heartbeat and backfiller for the websocket connection.
    this.backfiller = new WebsocketBackfiller(this);
    this.addSocketListeners();
    this.startHeartbeat();
    this.cancelBackfill = noop;
  }

  /**
   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.
   *
   * This override allows the SDK to set the provider's network to values not
   * yet supported by ethers.js.
   *
   * @internal
   * @override
   */
  static getNetwork(network: Networkish): NetworkFromEthers {
    if (typeof network === 'string' && network in CustomNetworks) {
      return CustomNetworks[network];
    }

    // Call the standard ethers.js getNetwork method for other networks.
    return getNetworkFromEthers(network);
  }

  /**
   * Overridden implementation of ethers that includes Alchemy based subscriptions.
   *
   * @param eventName Event to subscribe to
   * @param listener The listener function to call when the event is triggered.
   * @override
   * @public
   */
  // TODO: Override `Listener` type to get type autocompletions.
  on(eventName: AlchemyEventType, listener: Listener): this {
    return this._addEventListener(eventName, listener, false);
  }

  /**
   * Overridden implementation of ethers that includes Alchemy based
   * subscriptions. Adds a listener to the triggered for only the next
   * {@link eventName} event, after which it will be removed.
   *
   * @param eventName Event to subscribe to
   * @param listener The listener function to call when the event is triggered.
   * @override
   * @public
   */
  // TODO: Override `Listener` type to get type autocompletions.
  once(eventName: AlchemyEventType, listener: Listener): this {
    return this._addEventListener(eventName, listener, true);
  }

  /**
   * Removes the provided {@link listener} for the {@link eventName} event. If no
   * listener is provided, all listeners for the event will be removed.
   *
   * @param eventName Event to unlisten to.
   * @param listener The listener function to remove.
   * @override
   * @public
   */
  off(eventName: AlchemyEventType, listener?: Listener): this {
    if (isAlchemyEvent(eventName)) {
      return this._off(eventName, listener);
    } else {
      return super.off(eventName, listener);
    }
  }

  /**
   * Remove all listeners for the provided {@link eventName} event. If no event
   * is provided, all events and their listeners are removed.
   *
   * @param eventName The event to remove all listeners for.
   * @override
   * @public
   */
  removeAllListeners(eventName?: AlchemyEventType): this {
    if (eventName !== undefined && isAlchemyEvent(eventName)) {
      return this._removeAllListeners(eventName);
    } else {
      return super.removeAllListeners(eventName);
    }
  }

  /**
   * Returns the number of listeners for the provided {@link eventName} event. If
   * no event is provided, the total number of listeners for all events is returned.
   *
   * @param eventName The event to get the number of listeners for.
   * @public
   * @override
   */
  listenerCount(eventName?: AlchemyEventType): number {
    if (eventName !== undefined && isAlchemyEvent(eventName)) {
      return this._listenerCount(eventName);
    } else {
      return super.listenerCount(eventName);
    }
  }

  /**
   * Returns an array of listeners for the provided {@link eventName} event. If
   * no event is provided, all listeners will be included.
   *
   * @param eventName The event to get the listeners for.
   * @public
   * @override
   */
  listeners(eventName?: AlchemyEventType): Array<Listener> {
    if (eventName !== undefined && isAlchemyEvent(eventName)) {
      return this._listeners(eventName);
    } else {
      return super.listeners(eventName);
    }
  }

  /**
   * Overrides the method in `BaseProvider` in order to properly format the
   * Alchemy subscription events.
   *
   * @internal
   * @override
   */
  _addEventListener(
    eventName: AlchemyEventType,
    listener: Listener,
    once: boolean
  ): this {
    if (isAlchemyEvent(eventName)) {
      verifyAlchemyEventName(eventName);
      const event = new EthersEvent(
        getAlchemyEventTag(eventName),
        listener,
        once
      );
      this._events.push(event);
      this._startEvent(event);
      return this;
    } else {
      return super._addEventListener(eventName, listener, once);
    }
  }

  /**
   * Overrides the `_startEvent()` method in ethers.js's
   * {@link WebSocketProvider} to include additional alchemy methods.
   *
   * @param event
   * @override
   * @internal
   */
  _startEvent(event: EthersEvent): void {
    // Check if the event type is a custom Alchemy subscription.
    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];
    if (customLogicTypes.includes(event.type)) {
      this.customStartEvent(event);
    } else {
      super._startEvent(event);
    }
  }

  /**
   * Overridden from ethers.js's {@link WebSocketProvider}
   *
   * Modified in order to add mappings for backfilling.
   *
   * @internal
   * @override
   */
  async _subscribe(
    tag: string,
    param: Array<any>,
    processFunc: (result: any) => void,
    event?: EthersEvent
  ): Promise<void> {
    let subIdPromise = this._subIds[tag];

    // BEGIN MODIFIED CODE
    const startingBlockNumber = await this.getBlockNumber();
    // END MODIFIED CODE

    if (subIdPromise == null) {
      subIdPromise = Promise.all(param).then(param => {
        return this.send('eth_subscribe', param);
      });
      this._subIds[tag] = subIdPromise;
    }
    const subId = await subIdPromise;

    // BEGIN MODIFIED CODE
    const resolvedParams = await Promise.all(param);
    this.virtualSubscriptionsById.set(subId, {
      event: event!,
      method: 'eth_subscribe',
      params: resolvedParams,
      startingBlockNumber,
      virtualId: subId,
      physicalId: subId,
      sentEvents: [],
      isBackfilling: false,
      backfillBuffer: []
    });
    this.virtualIdsByPhysicalId.set(subId, subId);

    // END MODIFIED CODE

    this._subs[subId] = { tag, processFunc };
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `BaseProvider`.
   *
   * This method is copied over directly in order to implement Alchemy's unique
   * subscription types. The only difference is that this method calls
   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
   * order to parse the Alchemy subscription event.
   *
   * @internal
   * @override
   */
  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {
    if (isAlchemyEvent(eventName)) {
      let result = false;

      const stopped: Array<EthersEvent> = [];

      // This line is the only modified line from the original method.
      const eventTag = getAlchemyEventTag(eventName);

      this._events = this._events.filter(event => {
        if (event.tag !== eventTag) {
          return true;
        }

        setTimeout(() => {
          event.listener.apply(this, args);
        }, 0);

        result = true;

        if (event.once) {
          stopped.push(event);
          return false;
        }

        return true;
      });

      stopped.forEach(event => {
        this._stopEvent(event);
      });

      return result;
    } else {
      return super.emit(eventName, ...args);
    }
  }

  /** @internal */
  async sendBatch(parts: BatchPart[]): Promise<any[]> {
    let nextId = 0;
    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {
      return {
        method,
        params,
        jsonrpc: '2.0',
        id: `alchemy-sdk:${nextId++}`
      };
    });

    return this.sendBatchConcurrently(payload);
  }

  /** @override */
  destroy(): Promise<void> {
    this.removeSocketListeners();
    this.stopHeartbeatAndBackfill();
    return super.destroy();
  }

  /**
   * Overrides the ether's `isCommunityResource()` method. Returns true if the
   * current api key is the default key.
   *
   * @override
   */
  isCommunityResource(): boolean {
    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.
   *
   * This method is copied over directly in order to support Alchemy's
   * subscription type by allowing the provider to properly stop Alchemy's
   * subscription events.
   *
   * @internal
   */
  _stopEvent(event: EthersEvent): void {
    let tag = event.tag;

    // START MODIFIED CODE
    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {
      // There are remaining pending transaction listeners.
      if (
        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length
      ) {
        return;
      }
      // END MODIFIED CODE
    } else if (event.type === 'tx') {
      // There are remaining transaction event listeners
      if (this._events.filter(e => e.type === 'tx').length) {
        return;
      }
      tag = 'tx';
    } else if (this.listenerCount(event.event)) {
      // There are remaining event listeners
      return;
    }

    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }

    delete this._subIds[tag];
    void subId.then(subId => {
      if (!this._subs[subId]) {
        return;
      }
      delete this._subs[subId];
      void this.send('eth_unsubscribe', [subId]);
    });
  }

  /** @internal */
  private addSocketListeners(): void {
    this._websocket.addEventListener('message', this.handleMessage);
    this._websocket.addEventListener('reopen', this.handleReopen);
    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);
  }

  /** @internal */
  private removeSocketListeners(): void {
    this._websocket.removeEventListener('message', this.handleMessage);
    this._websocket.removeEventListener('reopen', this.handleReopen);
    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);
  }

  /**
   * The underlying ethers {@link WebSocketProvider} already handles and emits
   * messages. To allow backfilling, track all messages that are emitted.
   *
   * This is a field arrow function in order to preserve `this` context when
   * passing the method as an event listener.
   *
   * @internal
   */
  private handleMessage = (event: MessageEvent): void => {
    const message: WebSocketMessage = JSON.parse(event.data);
    if (!isSubscriptionEvent(message)) {
      return;
    }
    const physicalId = message.params.subscription;
    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);
    if (!virtualId) {
      return;
    }
    const subscription = this.virtualSubscriptionsById.get(virtualId)!;
    if (subscription.method !== 'eth_subscribe') {
      return;
    }

    switch (subscription.params[0]) {
      case 'newHeads': {
        const newHeadsSubscription = subscription as NewHeadsSubscription;
        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;
        const { isBackfilling, backfillBuffer } = newHeadsSubscription;
        const { result } = newHeadsMessage.params;
        if (isBackfilling) {
          addToNewHeadsEventsBuffer(backfillBuffer, result);
        } else if (physicalId !== virtualId) {
          // In the case of a re-opened subscription, ethers will not emit the
          // event, so the SDK has to.
          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
        } else {
          // Ethers subscription mapping will emit the event, just store it.
          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);
        }
        break;
      }
      case 'logs': {
        const logsSubscription = subscription as LogsSubscription;
        const logsMessage = message as SubscriptionEvent<LogsEvent>;
        const { isBackfilling, backfillBuffer } = logsSubscription;
        const { result } = logsMessage.params;
        if (isBackfilling) {
          addToLogsEventsBuffer(backfillBuffer, result);
        } else if (virtualId !== physicalId) {
          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
        } else {
          this.rememberEvent(virtualId, result, getLogsBlockNumber);
        }
        break;
      }
      default:
        if (physicalId !== virtualId) {
          // In the case of a re-opened subscription, ethers will not emit the
          // event, so the SDK has to.
          const { result } = (message as SubscriptionEvent<unknown>).params;
          this.emitEvent(virtualId, result);
        }
    }
  };

  /**
   * When the websocket connection reopens:
   *
   * 1. Resubscribe to all existing subscriptions and start backfilling
   * 2. Restart heart beat.
   *
   * This is a field arrow function in order to preserve `this` context when
   * passing the method as an event listener.
   *
   * @internal
   */
  private handleReopen = () => {
    this.virtualIdsByPhysicalId.clear();
    const { cancel, isCancelled } = makeCancelToken();
    this.cancelBackfill = cancel;
    for (const subscription of this.virtualSubscriptionsById.values()) {
      void (async () => {
        try {
          await this.resubscribeAndBackfill(isCancelled, subscription);
        } catch (error) {
          if (!isCancelled()) {
            console.error(
              `Error while backfilling "${subscription.params[0]}" subscription. Some events may be missing.`,
              error
            );
          }
        }
      })();
    }
    this.startHeartbeat();
  };

  /**
   * Reopens the backfill based on
   *
   * @param isCancelled
   * @param subscription
   * @internal
   */
  private async resubscribeAndBackfill(
    isCancelled: () => boolean,
    subscription: VirtualSubscription
  ): Promise<void> {
    const {
      virtualId,
      method,
      params,
      sentEvents,
      backfillBuffer,
      startingBlockNumber
    } = subscription;
    subscription.isBackfilling = true;
    backfillBuffer.length = 0;
    try {
      const physicalId = await this.send(method, params);
      throwIfCancelled(isCancelled);
      subscription.physicalId = physicalId;
      this.virtualIdsByPhysicalId.set(physicalId, virtualId);
      switch (params[0]) {
        case 'newHeads': {
          const backfillEvents = await withBackoffRetries(
            () =>
              withTimeout(
                this.backfiller.getNewHeadsBackfill(
                  isCancelled,
                  sentEvents,
                  startingBlockNumber
                ),
                BACKFILL_TIMEOUT
              ),
            BACKFILL_RETRIES,
            () => !isCancelled()
          );
          throwIfCancelled(isCancelled);
          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);
          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));
          break;
        }
        case 'logs': {
          const filter: LogsSubscriptionFilter = params[1] || {};
          const backfillEvents = await withBackoffRetries(
            () =>
              withTimeout(
                this.backfiller.getLogsBackfill(
                  isCancelled,
                  filter,
                  sentEvents,
                  startingBlockNumber
                ),
                BACKFILL_TIMEOUT
              ),
            BACKFILL_RETRIES,
            () => !isCancelled()
          );
          throwIfCancelled(isCancelled);
          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);
          events.forEach(event => this.emitLogsEvent(virtualId, event));
          break;
        }
        default:
          break;
      }
    } finally {
      subscription.isBackfilling = false;
      backfillBuffer.length = 0;
    }
  }

  /**
   * Cancels the heartbeat and any pending backfills being performed. This is
   * called when the websocket connection goes down or is disconnected.
   *
   * This is a field arrow function in order to preserve `this` context when
   * passing the method as an event listener.
   *
   * @internal
   */
  private stopHeartbeatAndBackfill = () => {
    if (this.heartbeatIntervalId != null) {
      clearInterval(this.heartbeatIntervalId);
      this.heartbeatIntervalId = undefined;
    }
    this.cancelBackfill();
  };

  /** @internal */
  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {
    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
  }

  /** @internal */
  private emitLogsEvent(virtualId: string, result: LogsEvent): void {
    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
  }

  /**
   * Emits an event to consumers, but also remembers it in its subscriptions's
   * `sentEvents` buffer so that we can detect re-orgs if the connection drops
   * and needs to be reconnected.
   *
   * @internal
   */
  private emitAndRememberEvent<T>(
    virtualId: string,
    result: T,
    getBlockNumber: (result: T) => number
  ): void {
    this.rememberEvent(virtualId, result, getBlockNumber);
    this.emitEvent(virtualId, result);
  }

  private emitEvent<T>(virtualId: string, result: T): void {
    const subscription = this.virtualSubscriptionsById.get(virtualId);
    if (!subscription) {
      return;
    }
    this.emitGenericEvent(subscription, result);
  }

  /** @internal */
  private rememberEvent<T>(
    virtualId: string,
    result: T,
    getBlockNumber: (result: T) => number
  ): void {
    const subscription = this.virtualSubscriptionsById.get(virtualId);
    if (!subscription) {
      return;
    }
    // Web3 modifies these event objects once we pass them on (changing hex
    // numbers to numbers). We want the original event, so make a defensive
    // copy.
    addToPastEventsBuffer(
      subscription.sentEvents,
      { ...result },
      getBlockNumber
    );
  }

  /** @internal */
  private emitGenericEvent(
    subscription: VirtualSubscription,
    result: any
  ): void {
    const emitFunction = this.emitProcessFn(subscription.event);
    emitFunction(result);
  }

  /**
   * Starts a heartbeat that pings the websocket server periodically to ensure
   * that the connection stays open.
   *
   * @internal
   */
  private startHeartbeat(): void {
    if (this.heartbeatIntervalId != null) {
      return;
    }
    this.heartbeatIntervalId = setInterval(async () => {
      try {
        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);
      } catch {
        this._websocket.reconnect();
      }
    }, HEARTBEAT_INTERVAL);
  }

  /**
   * This method sends the batch concurrently as individual requests rather than
   * as a batch, which was the original implementation. The original batch logic
   * is preserved in this implementation in order for faster porting.
   *
   * @param payload
   * @internal
   */
  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.
  // TODO(errors): Use allSettled() once we have more error handling.
  private async sendBatchConcurrently(
    payload: JsonRpcRequest[]
  ): Promise<unknown[]> {
    return Promise.all(payload.map(req => this.send(req.method, req.params)));
  }

  /** @internal */
  private customStartEvent(event: EthersEvent): void {
    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
      const { fromAddress, toAddress, hashesOnly } = event;
      void this._subscribe(
        event.tag,
        [
          AlchemySubscription.PENDING_TRANSACTIONS,
          { fromAddress, toAddress, hashesOnly }
        ],
        this.emitProcessFn(event),
        event
      );
    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
      const { addresses, includeRemoved, hashesOnly } = event;
      void this._subscribe(
        event.tag,
        [
          AlchemySubscription.MINED_TRANSACTIONS,
          { addresses, includeRemoved, hashesOnly }
        ],
        this.emitProcessFn(event),
        event
      );
    } else if (event.type === 'block') {
      void this._subscribe(
        'block',
        ['newHeads'],
        this.emitProcessFn(event),
        event
      );
    } else if (event.type === 'filter') {
      void this._subscribe(
        event.tag,
        ['logs', this._getFilter(event.filter)],
        this.emitProcessFn(event),
        event
      );
    }
  }

  /** @internal */
  private emitProcessFn(event: EthersEvent): (result: any) => void {
    switch (event.type) {
      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:
        return result =>
          this.emit(
            {
              method: AlchemySubscription.PENDING_TRANSACTIONS,
              fromAddress: event.fromAddress,
              toAddress: event.toAddress,
              hashesOnly: event.hashesOnly
            },
            result
          );
      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:
        return result =>
          this.emit(
            {
              method: AlchemySubscription.MINED_TRANSACTIONS,
              addresses: event.addresses,
              includeRemoved: event.includeRemoved,
              hashesOnly: event.hashesOnly
            },
            result
          );
      case 'block':
        return result => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit('block', blockNumber);
        };
      case 'filter':
        return result => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        };
      default:
        throw new Error('Invalid event type to `emitProcessFn()`');
    }
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `BaseProvider.off()`.
   *
   * This method is copied over directly in order to implement Alchemy's unique
   * subscription types. The only difference is that this method calls
   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
   * order to parse the Alchemy subscription event.
   *
   * @private
   */
  private _off(eventName: AlchemyEventType, listener?: Listener): this {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }

    const stopped: Array<EthersEvent> = [];

    let found = false;
    const eventTag = getAlchemyEventTag(eventName);
    this._events = this._events.filter(event => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });

    stopped.forEach(event => {
      this._stopEvent(event);
    });

    return this;
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.
   *
   * This method is copied over directly in order to implement Alchemy's unique
   * subscription types. The only difference is that this method calls
   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
   * order to parse the Alchemy subscription event.
   *
   * @private
   */
  private _removeAllListeners(eventName: AlchemyEventType): this {
    let stopped: Array<EthersEvent> = [];
    if (eventName == null) {
      stopped = this._events;

      this._events = [];
    } else {
      const eventTag = getAlchemyEventTag(eventName);
      this._events = this._events.filter(event => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }

    stopped.forEach(event => {
      this._stopEvent(event);
    });

    return this;
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.
   *
   * This method is copied over directly in order to implement Alchemy's unique
   * subscription types. The only difference is that this method calls
   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
   * order to parse the Alchemy subscription event.
   *
   * @private
   */
  private _listenerCount(eventName?: AlchemyEventType): number {
    if (!eventName) {
      return this._events.length;
    }

    const eventTag = getAlchemyEventTag(eventName);
    return this._events.filter(event => {
      return event.tag === eventTag;
    }).length;
  }

  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `BaseProvider.listeners()`.
   *
   * This method is copied over directly in order to implement Alchemy's unique
   * subscription types. The only difference is that this method calls
   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
   * order to parse the Alchemy subscription event.
   *
   * @private
   */
  private _listeners(eventName?: AlchemyEventType): Array<Listener> {
    if (eventName == null) {
      return this._events.map(event => event.listener);
    }

    const eventTag = getAlchemyEventTag(eventName);
    return this._events
      .filter(event => event.tag === eventTag)
      .map(event => event.listener);
  }
}

function getWebsocketConstructor(): any {
  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;
}

function isNodeEnvironment(): boolean {
  return (
    typeof process !== 'undefined' &&
    process != null &&
    process.versions != null &&
    process.versions.node != null
  );
}

/** @internal */
interface CancelToken {
  cancel(): void;
  isCancelled(): boolean;
}

interface VirtualSubscription {
  event: EthersEvent;
  virtualId: string;
  physicalId: string;
  method: string;
  params: any[];
  isBackfilling: boolean;
  startingBlockNumber: number;
  sentEvents: any[];
  backfillBuffer: any[];
}

interface NewHeadsSubscription extends VirtualSubscription {
  method: 'eth_subscribe';
  params: ['newHeads'];
  isBackfilling: boolean;
  sentEvents: NewHeadsEvent[];
  backfillBuffer: NewHeadsEvent[];
}

interface LogsSubscription extends VirtualSubscription {
  method: 'eth_subscribe';
  params: ['logs', LogsSubscriptionFilter?];
  isBackfilling: boolean;
  sentEvents: LogsEvent[];
  backfillBuffer: LogsEvent[];
}

// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.
function makeCancelToken(): CancelToken {
  let cancelled = false;
  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };
}

// TODO(cleanup): replace with SDK's backoff implementation
const MIN_RETRY_DELAY = 1000;
const RETRY_BACKOFF_FACTOR = 2;
const MAX_RETRY_DELAY = 30000;

async function withBackoffRetries<T>(
  f: () => Promise<T>,
  retryCount: number,
  shouldRetry: (error: unknown) => boolean = () => true
): Promise<T> {
  let nextWaitTime = 0;
  let i = 0;
  while (true) {
    try {
      return await f();
    } catch (error) {
      i++;
      if (i >= retryCount || !shouldRetry(error)) {
        throw error;
      }
      await delay(nextWaitTime);
      if (!shouldRetry(error)) {
        throw error;
      }
      nextWaitTime =
        nextWaitTime === 0
          ? MIN_RETRY_DELAY
          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);
    }
  }
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), ms)
    )
  ]);
}

function getNewHeadsBlockNumber(event: NewHeadsEvent): number {
  return fromHex(event.number);
}

function getLogsBlockNumber(event: LogsEvent): number {
  return fromHex(event.blockNumber);
}

function isResponse(
  message: WebSocketMessage
): message is SingleOrBatchResponse {
  return (
    Array.isArray(message) ||
    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)
  );
}

function isSubscriptionEvent(
  message: WebSocketMessage
): message is SubscriptionEvent {
  return !isResponse(message);
}

function addToNewHeadsEventsBuffer(
  pastEvents: NewHeadsEvent[],
  event: NewHeadsEvent
): void {
  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);
}

function addToLogsEventsBuffer(
  pastEvents: LogsEvent[],
  event: LogsEvent
): void {
  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);
}

/**
 * Adds a new event to an array of events, evicting any events which are so old
 * that they will no longer feasibly be part of a reorg.
 */
function addToPastEventsBuffer<T>(
  pastEvents: T[],
  event: T,
  getBlockNumber: (event: T) => number
): void {
  const currentBlockNumber = getBlockNumber(event);
  // Find first index of an event recent enough to retain, then drop everything
  // at a lower index.
  const firstGoodIndex = pastEvents.findIndex(
    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT
  );
  if (firstGoodIndex === -1) {
    pastEvents.length = 0;
  } else {
    pastEvents.splice(0, firstGoodIndex);
  }
  pastEvents.push(event);
}


================================================================================
File: src\api\alchemy.ts
Size: 2.85 kB
================================================================================

import { AlchemySettings } from '../types/types';
import { AlchemyConfig } from './alchemy-config';
import { CoreNamespace } from './core-namespace';
import { DebugNamespace } from './debug-namespace';
import { NftNamespace } from './nft-namespace';
import { NotifyNamespace } from './notify-namespace';
import { PricesNamespace } from './prices-namespace';
import { TransactNamespace } from './transact-namespace';
import { WebSocketNamespace } from './websocket-namespace';

/**
 * The Alchemy SDK client. This class is the main entry point into Alchemy's
 * APIs and separates functionality into different namespaces.
 *
 * Each SDK instance is associated with a specific network and API key. To use a
 * different network or API key, create a new instance of {@link Alchemy}.
 *
 * @public
 */
export class Alchemy {
  /**
   * The `core` namespace contains the core eth json-rpc calls and Alchemy's
   * Enhanced APIs.
   */
  readonly core: CoreNamespace;

  /** The `nft` namespace contains methods for Alchemy's NFT API. */
  readonly nft: NftNamespace;

  /** The `ws` namespace contains methods for using WebSockets and creating subscriptions. */
  readonly ws: WebSocketNamespace;

  /**
   * The `transact` namespace contains methods for sending transactions and
   * checking on the state of submitted transasctions.
   */
  readonly transact: TransactNamespace;

  /**
   * Holds the setting information for the instance of the Alchemy SDK client
   * and allows access to the underlying providers.
   */
  readonly config: AlchemyConfig;

  /**
   * The `notify` namespace contains methods for creating and managing webhooks
   * as part of the Notify API.
   */
  readonly notify: NotifyNamespace;

  /**
   * The `debug` namespace contains methods for inspecting and debugging
   * transactions.
   */
  readonly debug: DebugNamespace;

  /** The `prices` namespace contains methods for getting token price data. */
  readonly prices: PricesNamespace;

  /**
   * @param {string} [settings.apiKey] - The API key to use for Alchemy
   * @param {Network} [settings.network] - The network to use for Alchemy
   * @param {number} [settings.maxRetries] - The maximum number of retries to attempt
   * @param {number} [settings.requestTimeout] - The timeout after which request should fail
   * @public
   */
  constructor(settings?: AlchemySettings) {
    this.config = new AlchemyConfig(settings);

    this.core = new CoreNamespace(this.config);
    this.nft = new NftNamespace(this.config);
    this.ws = new WebSocketNamespace(this.config);
    this.transact = new TransactNamespace(this.config);
    this.notify = new NotifyNamespace(this.config);
    this.debug = new DebugNamespace(this.config);
    this.prices = new PricesNamespace(this.config);
  }
}


================================================================================
File: src\api\core-namespace.ts
Size: 23.34 kB
================================================================================

import type {
  Block,
  BlockTag,
  BlockWithTransactions,
  FeeData,
  Log,
  TransactionReceipt,
  TransactionRequest,
  TransactionResponse
} from '@ethersproject/abstract-provider';
import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
import type { Network as EthersNetworkAlias } from '@ethersproject/networks/lib/types';
import type { Deferrable } from '@ethersproject/properties';

import {
  getAssetTransfers,
  getLogs,
  getTransactionReceipts
} from '../internal/core-api';
import {
  AssetTransfersParams,
  AssetTransfersResponse,
  AssetTransfersWithMetadataParams,
  AssetTransfersWithMetadataResponse,
  DeployResult,
  Filter,
  FilterByBlockHash,
  GetTokensForOwnerOptions,
  GetTokensForOwnerResponse,
  OwnedToken,
  TokenBalanceType,
  TokenBalancesOptionsDefaultTokens,
  TokenBalancesOptionsErc20,
  TokenBalancesResponse,
  TokenBalancesResponseErc20,
  TokenMetadataResponse,
  TransactionReceiptsParams,
  TransactionReceiptsResponse
} from '../types/types';
import { ETH_NULL_VALUE } from '../util/const';
import { nullsToUndefined } from '../util/util';
import { AlchemyConfig } from './alchemy-config';
import { toHex } from './util';
import { formatUnits } from './utils';

/**
 * The core namespace contains all commonly-used [Ethers.js
 * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)
 * methods. If you are already using Ethers.js, you should be simply able to
 * replace the Ethers.js Provider object with `alchemy.core` when accessing
 * provider methods and it should just work.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the core namespace
 * via `alchemy.core`.
 */
export class CoreNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Returns the balance of a given address as of the provided block.
   *
   * @param addressOrName The address or name of the account to get the balance for.
   * @param blockTag The optional block number or hash to get the balance for.
   *   Defaults to 'latest' if unspecified.
   * @public
   */
  async getBalance(
    addressOrName: string | Promise<string>,
    blockTag?: BlockTag | Promise<BlockTag>
  ): Promise<BigNumber> {
    const provider = await this.config.getProvider();
    return provider.getBalance(addressOrName, blockTag);
  }

  /**
   * Checks if the provided address is a smart contract.
   *
   * @param address The address to check type for.
   * @public
   */
  async isContractAddress(address: string): Promise<boolean> {
    const provider = await this.config.getProvider();
    const code = await provider.getCode(address);
    return code !== '0x';
  }

  /**
   * Returns the contract code of the provided address at the block. If there is
   * no contract deployed, the result is `0x`.
   *
   * @param addressOrName The address or name of the account to get the code for.
   * @param blockTag The optional block number or hash to get the code for.
   *   Defaults to 'latest' if unspecified.
   * @public
   */
  async getCode(
    addressOrName: string | Promise<string>,
    blockTag?: BlockTag | Promise<BlockTag>
  ): Promise<string> {
    const provider = await this.config.getProvider();
    return provider.getCode(addressOrName, blockTag);
  }

  /**
   * Return the value of the provided position at the provided address, at the
   * provided block in `Bytes32` format.
   *
   * @param addressOrName The address or name of the account to get the code for.
   * @param position The position of the storage slot to get.
   * @param blockTag The optional block number or hash to get the code for.
   *   Defaults to 'latest' if unspecified.
   * @public
   */
  async getStorageAt(
    addressOrName: string | Promise<string>,
    position: BigNumberish | Promise<BigNumberish>,
    blockTag?: BlockTag | Promise<BlockTag>
  ): Promise<string> {
    const provider = await this.config.getProvider();
    return provider.getStorageAt(addressOrName, position, blockTag);
  }

  /**
   * Returns the number of transactions ever sent from the provided address, as
   * of the provided block tag. This value is used as the nonce for the next
   * transaction from the address sent to the network.
   *
   * @param addressOrName The address or name of the account to get the nonce for.
   * @param blockTag The optional block number or hash to get the nonce for.
   * @public
   */
  async getTransactionCount(
    addressOrName: string | Promise<string>,
    blockTag?: BlockTag | Promise<BlockTag>
  ): Promise<number> {
    const provider = await this.config.getProvider();
    return provider.getTransactionCount(addressOrName, blockTag);
  }

  /**
   * Returns the block from the network based on the provided block number or
   * hash. Transactions on the block are represented as an array of transaction
   * hashes. To get the full transaction details on the block, use
   * {@link getBlockWithTransactions} instead.
   *
   * @param blockHashOrBlockTag The block number or hash to get the block for.
   * @public
   */
  async getBlock(
    blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>
  ): Promise<Block> {
    const provider = await this.config.getProvider();
    return provider.getBlock(blockHashOrBlockTag);
  }

  /**
   * Returns the block from the network based on the provided block number or
   * hash. Transactions on the block are represented as an array of
   * {@link TransactionResponse} objects.
   *
   * @param blockHashOrBlockTag The block number or hash to get the block for.
   * @public
   */
  async getBlockWithTransactions(
    blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>
  ): Promise<BlockWithTransactions> {
    const provider = await this.config.getProvider();
    return provider.getBlockWithTransactions(blockHashOrBlockTag);
  }

  /**
   * Returns the {@link EthersNetworkAlias} Alchemy is connected to.
   *
   * @public
   */
  async getNetwork(): Promise<EthersNetworkAlias> {
    const provider = await this.config.getProvider();
    return provider.getNetwork();
  }

  /**
   * Returns the block number of the most recently mined block.
   *
   * @public
   */
  async getBlockNumber(): Promise<number> {
    const provider = await this.config.getProvider();
    return provider.getBlockNumber();
  }

  /**
   * Returns the best guess of the current gas price to use in a transaction.
   *
   * @public
   */
  async getGasPrice(): Promise<BigNumber> {
    const provider = await this.config.getProvider();
    return provider.getGasPrice();
  }

  /**
   * Returns the recommended fee data to use in a transaction.
   *
   * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas
   * should be used.
   *
   * For legacy transactions and networks which do not support EIP-1559, the
   * gasPrice should be used.
   *
   * @public
   */
  async getFeeData(): Promise<FeeData> {
    const provider = await this.config.getProvider();
    return provider.getFeeData();
  }

  /**
   * Returns a Promise which will stall until the network has heen established,
   * ignoring errors due to the target node not being active yet.
   *
   * This can be used for testing or attaching scripts to wait until the node is
   * up and running smoothly.
   *
   * @public
   */
  async ready(): Promise<EthersNetworkAlias> {
    const provider = await this.config.getProvider();
    return provider.ready;
  }

  /**
   * Returns the result of executing the transaction, using call. A call does
   * not require any ether, but cannot change any state. This is useful for
   * calling getters on Contracts.
   *
   * @param transaction The transaction to execute.
   * @param blockTag The optional block number or hash to get the call for.
   * @public
   */
  async call(
    transaction: Deferrable<TransactionRequest>,
    blockTag?: BlockTag | Promise<BlockTag>
  ): Promise<string> {
    const provider = await this.config.getProvider();
    return provider.call(transaction, blockTag);
  }

  /**
   * Returns an estimate of the amount of gas that would be required to submit
   * transaction to the network.
   *
   * An estimate may not be accurate since there could be another transaction on
   * the network that was not accounted for, but after being mined affects the
   * relevant state.
   *
   * This is an alias for {@link TransactNamespace.estimateGas}.
   *
   * @param transaction The transaction to estimate gas for.
   * @public
   */
  async estimateGas(
    transaction: Deferrable<TransactionRequest>
  ): Promise<BigNumber> {
    const provider = await this.config.getProvider();
    return provider.estimateGas(transaction);
  }

  /**
   * Returns the transaction with hash or null if the transaction is unknown.
   *
   * If a transaction has not been mined, this method will search the
   * transaction pool. Various backends may have more restrictive transaction
   * pool access (e.g. if the gas price is too low or the transaction was only
   * recently sent and not yet indexed) in which case this method may also return null.
   *
   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.
   *
   * @param transactionHash The hash of the transaction to get.
   * @public
   */
  async getTransaction(
    transactionHash: string | Promise<string>
  ): Promise<TransactionResponse | null> {
    const provider = await this.config.getProvider();
    return provider.getTransaction(transactionHash);
  }

  /**
   * Returns the transaction receipt for hash or null if the transaction has not
   * been mined.
   *
   * To stall until the transaction has been mined, consider the
   * waitForTransaction method below.
   *
   * @param transactionHash The hash of the transaction to get.
   * @public
   */
  async getTransactionReceipt(
    transactionHash: string | Promise<string>
  ): Promise<TransactionReceipt | null> {
    const provider = await this.config.getProvider();
    return provider.getTransactionReceipt(transactionHash);
  }

  /**
   * Submits transaction to the network to be mined. The transaction must be
   * signed, and be valid (i.e. the nonce is correct and the account has
   * sufficient balance to pay for the transaction).
   *
   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.
   *
   * @param signedTransaction The signed transaction to send.
   * @public
   */
  async sendTransaction(
    signedTransaction: string | Promise<string>
  ): Promise<TransactionResponse> {
    const provider = await this.config.getProvider();
    return provider.sendTransaction(signedTransaction);
  }

  /**
   * Returns a promise which will not resolve until specified transaction hash is mined.
   *
   * If {@link confirmations} is 0, this method is non-blocking and if the
   * transaction has not been mined returns null. Otherwise, this method will
   * block until the transaction has confirmed blocks mined on top of the block
   * in which it was mined.
   *
   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.
   *
   * @param transactionHash The hash of the transaction to wait for.
   * @param confirmations The number of blocks to wait for.
   * @param timeout The maximum time to wait for the transaction to confirm.
   * @public
   */
  async waitForTransaction(
    transactionHash: string,
    confirmations?: number,
    timeout?: number
  ): Promise<TransactionReceipt | null> {
    const provider = await this.config.getProvider();
    return provider.waitForTransaction(transactionHash, confirmations, timeout);
  }

  /**
   * Returns an array of logs that match the provided filter.
   *
   * @param filter The filter object to use.
   * @public
   */
  async getLogs(
    filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>
  ): Promise<Array<Log>> {
    return getLogs(this.config, filter);
  }

  /**
   * Allows sending a raw message to the Alchemy backend.
   *
   * @param method The method to call.
   * @param params The parameters to pass to the method.
   * @public
   */
  async send(method: string, params: Array<any>): Promise<any> {
    const provider = await this.config.getProvider();
    return provider.send(method, params);
  }

  /**
   * Finds the address that deployed the provided contract and block number it
   * was deployed in.
   *
   * NOTE: This method performs a binary search across all blocks since genesis
   * and can take a long time to complete. This method is a convenience method
   * that will eventually be replaced by a single call to an Alchemy endpoint
   * with this information cached.
   *
   * @param contractAddress - The contract address to find the deployer for.
   * @beta
   */
  async findContractDeployer(contractAddress: string): Promise<DeployResult> {
    const provider = await this.config.getProvider();
    const currentBlockNum = await provider.getBlockNumber();
    if (
      (await provider.getCode(contractAddress, currentBlockNum)) ===
      ETH_NULL_VALUE
    ) {
      throw new Error(`Contract '${contractAddress}' does not exist`);
    }

    // Binary search for the block number that the contract was deployed in.
    const firstBlock = await binarySearchFirstBlock(
      0,
      currentBlockNum + 1,
      contractAddress,
      this.config
    );

    // Find the first transaction in the block that matches the provided address.
    const txReceipts = await getTransactionReceipts(
      this.config,
      {
        blockNumber: toHex(firstBlock)
      },
      'findContractDeployer'
    );
    const matchingReceipt = txReceipts.receipts?.find(
      receipt => receipt.contractAddress === contractAddress.toLowerCase()
    );
    return {
      deployerAddress: matchingReceipt?.from,
      blockNumber: firstBlock
    };
  }

  /**
   * Returns the ERC-20 token balances for a specific owner address.
   *
   * @param addressOrName The owner address to get the token balances for.
   * @public
   */
  async getTokenBalances(
    addressOrName: string
  ): Promise<TokenBalancesResponseErc20>;

  /**
   * Returns the token balances for a specific owner address given a list of contracts.
   *
   * @param addressOrName The owner address to get the token balances for.
   * @param contractAddresses A list of contract addresses to check. If omitted,
   *   all ERC-20 tokens will be checked.
   * @public
   */
  async getTokenBalances(
    addressOrName: string,
    contractAddresses?: string[]
  ): Promise<TokenBalancesResponse>;

  /**
   * Returns the ERC-20 token balances for a specific owner.
   *
   * This overload covers the erc-20 token type which includes a page key in the response.
   *
   * @param addressOrName The owner address to get the token balances for.
   * @param options Token type options set to ERC-20 with optional page key.
   * @public
   */
  async getTokenBalances(
    addressOrName: string,
    options: TokenBalancesOptionsErc20
  ): Promise<TokenBalancesResponseErc20>;

  /**
   * Returns the token balances for a specific owner, fetching from the top 100
   * tokens by 24 hour volume.
   *
   * This overload covers the default token type which includes a page key in
   * the response.
   *
   * @param addressOrName The owner address to get the token balances for.
   * @param options Token type options set to ERC-20 with optional page key.
   * @public
   */
  async getTokenBalances(
    addressOrName: string,
    options: TokenBalancesOptionsDefaultTokens
  ): Promise<TokenBalancesResponse>;

  async getTokenBalances(
    addressOrName: string,
    contractAddressesOrOptions?:
      | string[]
      | TokenBalancesOptionsDefaultTokens
      | TokenBalancesOptionsErc20
  ) {
    const provider = await this.config.getProvider();
    const address = await provider._getAddress(addressOrName);
    if (Array.isArray(contractAddressesOrOptions)) {
      if (contractAddressesOrOptions.length > 1500) {
        throw new Error(
          'You cannot pass in more than 1500 contract addresses to getTokenBalances()'
        );
      }
      if (contractAddressesOrOptions.length === 0) {
        throw new Error(
          'getTokenBalances() requires at least one contractAddress when using an array'
        );
      }
      return provider._send(
        'alchemy_getTokenBalances',
        [address, contractAddressesOrOptions],
        'getTokenBalances'
      );
    } else {
      const tokenType =
        contractAddressesOrOptions === undefined
          ? TokenBalanceType.ERC20
          : contractAddressesOrOptions.type;
      const params: Array<string | { pageKey: string }> = [address, tokenType];
      if (
        contractAddressesOrOptions?.type === TokenBalanceType.ERC20 &&
        contractAddressesOrOptions.pageKey
      ) {
        params.push({ pageKey: contractAddressesOrOptions.pageKey });
      }
      return provider._send(
        'alchemy_getTokenBalances',
        params,
        'getTokenBalances'
      );
    }
  }

  /**
   * Returns the tokens that the specified address owns, along with the amount
   * of each token and the relevant metadata.
   *
   * @param addressOrName The owner address to get the tokens with balances for.
   * @param options Additional options to pass to the request.
   * @public
   */
  async getTokensForOwner(
    addressOrName: string,
    options?: GetTokensForOwnerOptions
  ): Promise<GetTokensForOwnerResponse> {
    const provider = await this.config.getProvider();
    const address = await provider._getAddress(addressOrName);
    const params: any[] = [
      address,
      options?.contractAddresses ?? TokenBalanceType.ERC20
    ];
    if (options?.pageKey) {
      params.push({ pageKey: options.pageKey });
    }
    const response = (await provider._send(
      'alchemy_getTokenBalances',
      params,
      'getTokensForOwner'
    )) as TokenBalancesResponseErc20;

    const formattedBalances = response.tokenBalances.map(balance => ({
      contractAddress: balance.contractAddress,
      rawBalance: BigNumber.from(balance.tokenBalance!).toString()
    }));

    const metadataPromises = await Promise.allSettled(
      response.tokenBalances.map(token =>
        provider._send(
          'alchemy_getTokenMetadata',
          [token.contractAddress],
          'getTokensForOwner',
          /* forceBatch= */ true
        )
      )
    );
    const metadata: TokenMetadataResponse[] = metadataPromises.map(p =>
      p.status === 'fulfilled'
        ? p.value
        : {
            name: null,
            symbol: null,
            decimals: null,
            logo: null
          }
    );
    const ownedTokens = formattedBalances.map((balance, index) => ({
      ...balance,
      ...metadata[index],
      balance:
        metadata[index].decimals !== null
          ? formatUnits(balance.rawBalance, metadata[index].decimals!)
          : undefined
    }));

    return {
      tokens: ownedTokens.map(t => nullsToUndefined<OwnedToken>(t)),
      pageKey: response.pageKey
    };
  }

  /**
   * Returns metadata for a given token contract address.
   *
   * @param address The contract address to get metadata for.
   * @public
   */
  async getTokenMetadata(address: string): Promise<TokenMetadataResponse> {
    const provider = await this.config.getProvider();
    return provider._send(
      'alchemy_getTokenMetadata',
      [address],
      'getTokenMetadata'
    );
  }

  /**
   * Get transactions for specific addresses. See the web documentation for the
   * full details:
   * https://docs.alchemy.com/alchemy/enhanced-apis/transfers-api#alchemy_getassettransfers
   *
   * This overload requires {@link AssetTransfersWithMetadataParams.withMetadata}
   * to be set to `true`, which results in additional metadata returned in the
   * response object.
   *
   * @param params An object containing fields for the asset transfer query
   * @public
   */
  async getAssetTransfers(
    params: AssetTransfersWithMetadataParams
  ): Promise<AssetTransfersWithMetadataResponse>;

  /**
   * Get transactions for specific addresses. See the web documentation for the
   * full details:
   * https://docs.alchemy.com/alchemy/enhanced-apis/transfers-api#alchemy_getassettransfers
   *
   * @param params An object containing fields for the asset transfer query.
   * @public
   */
  async getAssetTransfers(
    params: AssetTransfersParams
  ): Promise<AssetTransfersResponse>;
  async getAssetTransfers(
    params: AssetTransfersWithMetadataParams | AssetTransfersParams
  ): Promise<AssetTransfersResponse | AssetTransfersWithMetadataResponse> {
    return getAssetTransfers(this.config, params);
  }

  /**
   * Gets all transaction receipts for a given block by number or block hash.
   *
   * @param params An object containing fields for the transaction receipt query.
   * @public
   */
  async getTransactionReceipts(
    params: TransactionReceiptsParams
  ): Promise<TransactionReceiptsResponse> {
    return getTransactionReceipts(this.config, params);
  }

  /**
   * Returns the underlying owner address for the provided ENS address, or `null`
   * if the ENS name does not have an underlying address.
   *
   * @param name The ENS address name to resolve.
   */
  async resolveName(name: string): Promise<string | null> {
    const provider = await this.config.getProvider();
    return provider.resolveName(name);
  }

  /**
   * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.
   *
   * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.
   *
   * @param address The address to look up the ENS domain name for.
   */
  async lookupAddress(address: string): Promise<string | null> {
    const provider = await this.config.getProvider();
    return provider.lookupAddress(address);
  }
}

/**
 * Perform a binary search between an integer range of block numbers to find the
 * block number where the contract was deployed.
 *
 * @internal
 */
async function binarySearchFirstBlock(
  start: number,
  end: number,
  address: string,
  config: AlchemyConfig
): Promise<number> {
  if (start >= end) {
    return end;
  }

  const mid = Math.floor((start + end) / 2);
  const provider = await config.getProvider();
  const code = await provider.getCode(address, mid);
  if (code === ETH_NULL_VALUE) {
    return binarySearchFirstBlock(mid + 1, end, address, config);
  }
  return binarySearchFirstBlock(start, mid, address, config);
}


================================================================================
File: src\api\debug-namespace.ts
Size: 6.55 kB
================================================================================

import {
  BlockIdentifier,
  DebugCallTrace,
  DebugCallTracer,
  DebugPrestateTrace,
  DebugPrestateTracer,
  DebugTransaction
} from '../types/types';
import { AlchemyConfig } from './alchemy-config';
import { hexStripZeros, hexValue, isHexString } from './utils';

/**
 * The Debug namespace contains methods to access the non-standard RPC methods
 * for inspecting and debugging transactions.
 *
 * For more information on the different methods and use cases please read our
 * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the debug namespace
 * via `alchemy.debug`.
 */
export class DebugNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Runs an `eth_call` with the context of the provided block execution using the
   * final state of the parent block as the base.
   *
   * @param transaction The transaction to debug trace.
   * @param blockIdentifier The block to debug the transaction in. Can be a
   * block hash, block number hex string, or commitment level.
   * @param tracer Tracer type and configuration.
   */
  traceCall(
    transaction: DebugTransaction,
    blockIdentifier: BlockIdentifier,
    tracer: DebugCallTracer
  ): Promise<DebugCallTrace>;

  /**
   * Runs an `eth_call` with the context of the provided block execution using the
   * final state of the parent block as the base.
   *
   * @param transaction The transaction to debug trace.
   * @param blockIdentifier The block to debug the transaction in. Can be a
   * block hash, block number hex string, or commitment level.
   * @param tracer Tracer type and configuration.
   */
  traceCall(
    transaction: DebugTransaction,
    blockIdentifier: BlockIdentifier,
    tracer: DebugPrestateTracer
  ): Promise<DebugPrestateTrace>;
  async traceCall(
    transaction: DebugTransaction,
    blockIdentifier: BlockIdentifier,
    tracer: DebugCallTracer | DebugPrestateTracer
  ): Promise<DebugCallTrace | DebugPrestateTrace> {
    const provider = await this.config.getProvider();
    const params = [transaction, blockIdentifier, parseTracerParams(tracer)];
    return provider._send('debug_traceCall', params, 'traceCall');
  }

  /**
   * Attempts to run the transaction in the exact same manner as it was executed
   * on the network. It will replay any transaction that may have been executed
   * prior to this one before it and will then attempt to execute the transaction
   * that corresponds to the given hash.
   *
   * @param transactionHash The transaction hash of the transaction to trace.
   * @param tracer Tracer type and configuration.
   * @param timeout  A duration string of decimal numbers that overrides the
   * default timeout of 5 seconds for JavaScript-based tracing calls. Max
   * timeout is "10s". Valid time units are "ns", "us", "ms", "s" each with
   * optional fraction, such as "300ms" or "2s45ms".
   */
  async traceTransaction(
    transactionHash: string,
    tracer: DebugCallTracer,
    timeout?: string
  ): Promise<DebugCallTrace>;

  /**
   * Attempts to run the transaction in the exact same manner as it was executed
   * on the network. It will replay any transaction that may have been executed
   * prior to this one before it and will then attempt to execute the transaction
   * that corresponds to the given hash.
   *
   * @param transactionHash The transaction hash of the transaction to trace.
   * @param tracer Tracer type and configuration.
   * @param timeout  A duration string of decimal numbers that overrides the
   * default timeout of 5 seconds for JavaScript-based tracing calls. Max
   * timeout is "10s". Valid time units are "ns", "us", "ms", "s" each with
   * optional fraction, such as "300ms" or "2s45ms".
   */
  async traceTransaction(
    transactionHash: string,
    tracer: DebugPrestateTracer,
    timeout?: string
  ): Promise<DebugPrestateTrace>;
  async traceTransaction(
    transactionHash: string,
    tracer: DebugCallTracer | DebugPrestateTracer,
    timeout?: string
  ): Promise<DebugCallTrace | DebugPrestateTrace> {
    const provider = await this.config.getProvider();
    const params = [transactionHash, parseTracerParams(tracer, timeout)];
    return provider._send('debug_traceTransaction', params, 'traceTransaction');
  }

  /**
   * Replays a block that has already been mined.
   *
   * @param blockIdentifier The block to debug the transaction in. Can be a
   * block hash, block number hex string, or commitment level.
   * @param tracer Tracer type and configuration.
   */
  traceBlock(
    blockIdentifier: BlockIdentifier | number,
    tracer: DebugCallTracer
  ): Promise<DebugCallTrace>;
  /**
   * Replays a block that has already been mined.
   *
   * @param blockIdentifier The block to debug the transaction in. Can be a
   * block hash, block number hex string, or commitment level.
   * @param tracer Tracer type and configuration.
   */
  traceBlock(
    blockIdentifier: BlockIdentifier | number,
    tracer: DebugPrestateTracer
  ): Promise<DebugPrestateTrace>;
  async traceBlock(
    blockIdentifier: BlockIdentifier | number,
    tracer: DebugCallTracer | DebugPrestateTracer
  ): Promise<DebugCallTrace | DebugPrestateTrace> {
    const provider = await this.config.getProvider();
    let method: string;
    let params: [string, RawTracer];
    if (isHexString(blockIdentifier, 32)) {
      method = 'debug_traceBlockByHash';
      params = [blockIdentifier as string, parseTracerParams(tracer)];
    } else {
      method = 'debug_traceBlockByNumber';
      const block =
        typeof blockIdentifier === 'number'
          ? hexStripZeros(hexValue(blockIdentifier))
          : blockIdentifier;
      params = [block as string, parseTracerParams(tracer)];
    }
    return provider._send(method, params, 'traceBlock');
  }
}

interface RawTracer {
  tracer: string;
  tracerConfig?: {
    onlyTopCall?: boolean;
    timeout?: string;
  };
}

function parseTracerParams(
  tracer: DebugCallTracer | DebugPrestateTracer,
  timeout?: string
): RawTracer {
  return {
    tracer: tracer.type,
    ...(tracer.onlyTopCall !== undefined && {
      tracerConfig: {
        onlyTopCall: tracer.onlyTopCall,
        timeout
      }
    })
  };
}


================================================================================
File: src\api\nft-namespace.ts
Size: 20.41 kB
================================================================================

import type { BigNumberish } from '@ethersproject/bignumber';

import {
  computeRarity,
  getCollectionMetadata,
  getContractMetadata,
  getContractMetadataBatch,
  getContractsForOwner,
  getFloorPrice,
  getMintedNfts,
  getNftMetadata,
  getNftMetadataBatch,
  getNftSales,
  getNftsForContract,
  getNftsForContractIterator,
  getNftsForOwner,
  getNftsForOwnerIterator,
  getOwnersForContract,
  getOwnersForNft,
  getSpamContracts,
  getTransfersForContract,
  getTransfersForOwner,
  isAirdropNft,
  isSpamContract,
  refreshContract,
  refreshNftMetadata,
  reportSpam,
  searchContractMetadata,
  summarizeNftAttributes,
  verifyNftOwnership
} from '../internal/nft-api';
import {
  BaseNft,
  ComputeRarityResponse,
  GetBaseNftsForContractOptions,
  GetBaseNftsForOwnerOptions,
  GetContractMetadataBatchResponse,
  GetContractsForOwnerOptions,
  GetContractsForOwnerResponse,
  GetFloorPriceResponse,
  GetMintedNftsOptions,
  GetNftMetadataBatchResponse,
  GetNftMetadataOptions,
  GetNftSalesOptions,
  GetNftSalesOptionsByContractAddress,
  GetNftSalesResponse,
  GetNftsForContractOptions,
  GetNftsForOwnerOptions,
  GetOwnersForContractOptions,
  GetOwnersForContractResponse,
  GetOwnersForContractWithTokenBalancesOptions,
  GetOwnersForContractWithTokenBalancesResponse,
  GetOwnersForNftOptions,
  GetOwnersForNftResponse,
  GetSpamContractsResponse,
  GetTransfersForContractOptions,
  IsAirdropNftResponse,
  IsSpamContractResponse,
  Nft,
  NftAttributesResponse,
  NftCollection,
  NftContract,
  NftContractBaseNftsResponse,
  NftContractNftsResponse,
  NftMetadataBatchOptions,
  NftMetadataBatchToken,
  NftTokenType,
  OwnedBaseNft,
  OwnedBaseNftsResponse,
  OwnedNft,
  OwnedNftsResponse,
  SearchContractMetadataResponse,
  TransfersNftResponse
} from '../types/nft-types';
import {
  GetTransfersForOwnerOptions,
  GetTransfersForOwnerTransferType,
  RefreshContractResult
} from '../types/types';
import { AlchemyConfig } from './alchemy-config';

/**
 * The NFT namespace contains all the functionality related to NFTs.
 *
 * Do not call this constructor directly. Instead, instantiate an Alchemy object
 * with `const alchemy = new Alchemy(config)` and then access the core namespace
 * via `alchemy.nft`.
 */
export class NftNamespace {
  /** @internal */
  constructor(private readonly config: AlchemyConfig) {}

  /**
   * Get the NFT metadata associated with the provided parameters.
   *
   * @param contractAddress - The contract address of the NFT.
   * @param tokenId - Token id of the NFT.
   * @param options - Options for the request.
   * @public
   */
  getNftMetadata(
    contractAddress: string,
    tokenId: BigNumberish,
    options?: GetNftMetadataOptions
  ): Promise<Nft>;
  getNftMetadata(
    contractAddress: string,
    tokenId: BigNumberish,
    optionsOrTokenType?: GetNftMetadataOptions | NftTokenType,
    tokenUriTimeoutInMs?: number
  ): Promise<Nft> {
    let options: GetNftMetadataOptions;
    if (typeof optionsOrTokenType === 'object') {
      options = {
        tokenType: optionsOrTokenType.tokenType,
        tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,
        refreshCache: optionsOrTokenType.refreshCache
      };
    } else {
      options = {
        tokenType: optionsOrTokenType,
        tokenUriTimeoutInMs
      };
    }
    return getNftMetadata(this.config, contractAddress, tokenId, options);
  }

  /**
   * Gets the NFT metadata for multiple NFT tokens.
   *
   * @param tokens An array of NFT tokens to fetch metadata for.
   * @param options Configuration options for making the request.
   */
  getNftMetadataBatch(
    tokens: Array<NftMetadataBatchToken>,
    options?: NftMetadataBatchOptions
  ): Promise<GetNftMetadataBatchResponse> {
    return getNftMetadataBatch(this.config, tokens, options);
  }

  /**
   * Get the NFT contract metadata associated with the provided parameters.
   *
   * @param contractAddress - The contract address of the NFT.
   * @public
   */
  getContractMetadata(contractAddress: string): Promise<NftContract> {
    return getContractMetadata(this.config, contractAddress);
  }

  /**
   * Get the NFT contract metadata for multiple NFT contracts in a single request.
   *
   * @param contractAddresses - An array of contract addresses to fetch metadata for.
   */
  getContractMetadataBatch(
    contractAddresses: string[]
  ): Promise<GetContractMetadataBatchResponse> {
    return getContractMetadataBatch(this.config, contractAddresses);
  }

  /**
   * Get the NFT collection metadata associated with the provided parameters.
   *
   * @param collectionSlug - The OpenSea collection slug of the NFT.
   * @beta
   */
  getCollectionMetadata(collectionSlug: string): Promise<NftCollection> {
    return getCollectionMetadata(this.config, collectionSlug);
  }

  /**
   * Fetches all NFTs for a given owner and yields them in an async iterable.
   *
   * This method returns the full NFT for the owner and pages through all page
   * keys until all NFTs have been fetched.
   *
   * @param owner - The address of the owner.